# File: uint128.go

uint128.go 文件是 Go 语言标准库中的一个文件，在 net 包中负责实现一个 128 位无符号整数的类型 uint128。

该类型主要用于在网络编程中处理 IPv6 地址，因为 IPv6 地址的长度为 128 位，而 Go 语言中的 int 类型只有 64 位，因此需要一个更大的整数类型来表示 IPv6 地址。

这个文件定义了一个名为 uint128 的类型，它是一个结构体，包含两个无符号整数 low 和 high，分别表示低位和高位。此外，该文件还定义了一些操作 uint128 类型的函数，如加法、减法、左移、右移、比较等。

这些函数的实现使用了一些位运算的技巧，以便实现对 128 位整数的快速操作。这些操作可以对 uint128 类型的变量进行数学运算、移位、与其他类型进行比较等操作。

由于 IPv6 地址是一个 128 位的整数，因此在网络编程中需要使用 uint128 类型来存储和处理 IPv6 地址，以确保数据的完整性和正确性。这个文件的实现，为网络编程提供了强大、高效、安全的工具和功能。




---

### Structs:

### uint128

在Go语言的net包中，uint128是一个结构体，用于表示128位无符号整数。由于Go语言中最大的内置整数类型uint64只能表示2¹⁶⁵-1的整数，而有些网络协议中需要传输128位整数，因此这个结构体被设计出来以解决这个问题。

uint128结构体定义：

type uint128 struct {
    hi uint64 // 高64位
    lo uint64 // 低64位
}

这个结构体包含两个无符号整数类型的成员变量hi和lo，分别用于表示128位整数的高64位和低64位。由于当前的Go语言版本中还没有原生支持128位整数，因此使用结构体的方式来模拟表示。

这个结构体还提供了一系列的方法来支持对128位整数进行各种运算操作，比如加减乘除、位移和位运算等。这些操作都是按照128位整数的运算规则进行操作，保证了计算结果的正确性。

总之，uint128结构体的作用是支持在Go语言中进行128位无符号整数的运算操作，以满足某些需要传输128位整数的网络协议的需求。



## Functions:

### mask6

在Go语言的net包中，uint128.go文件包含与128位无符号整数相关的函数和类型。其中，mask6函数是其中的一个函数。

mask6函数的作用是生成6位掩码，用于对128位无符号整数进行按位与操作。具体来说，生成的掩码有如下特点：

- 前6位为1，后122位为0；
- 用于对128位无符号整数的第7到第12位进行按位与操作，将其余位设为0。

mask6函数的实现代码如下：

```go
func mask6(i uint) uint128 {
    if i == 0 {
        return uint128{}
    }
    a := i << 116
    b := uint128{lo: ^uint64(0), hi: (1<<6 - 1) << 122}
    return b.lsh(a)
}
```

代码中首先判断输入的参数i是否为0，如果是0则返回一个全0的uint128类型，否则生成6位掩码。

生成6位掩码的过程如下：

- 首先将参数i左移116位，即将其二进制表示的第7到第12位移动到掩码的第123到第128位；
- 然后生成一个uint128类型的变量b，将其低64位设为全1，高64位设为6位全1的数左移122位，这样就得到一个前6位为1，后122位为0的128位数；
- 最后对b执行lsh(left shift)操作，将其和a进行按位与操作，得到掩码。

生成的掩码可以用于对128位无符号整数的第7到第12位进行按位与操作，将其余位设为0。这在IPv6地址的处理中非常有用，因为IPv6地址中的前6个16位字段描述地址的前缀，后面的16位字段描述主机号，用mask6函数生成的掩码可以方便地对这些字段进行处理。



### isZero

isZero函数是一个无符号128位整数类型（uint128）的方法，用于检查当前值是否为零。如果uint128类型的值为零，则isZero函数将返回true，否则返回false。

该函数的代码如下：

```
// isZero reports whether n == 0.
func (n uint128) isZero() bool { return n.lo == 0 && n.hi == 0 }
```

其中，n.lo表示低64位，n.hi表示高64位。

在网络编程中，uint128通常用于表示大数据包的序列号或者从网络中接收到的大数据块的偏移量等。因此，isZero函数可以帮助程序员检查序列号或偏移量是否为零，从而避免出现不必要的错误。例如，当一个数据块还未接收到，程序会将其序列号设置为零，在接收到数据时，程序会通过isZero函数检查序列号是否为零，以此判断接收是否成功，从而避免处理错误的数据。



### and

在go/src/net/uint128.go文件中，and函数是用于比较两个128位无符号整数的按位与操作的函数。具体来说，and函数接受两个参数a和b，它们都是128位的无符号整数。and函数通过按位与操作返回一个新的128位的无符号整数，该整数所有位数均为1，当且仅当a和b都为1时。

该函数的实现如下：

func and(a, b uint128) uint128 {
    return uint128{a.Lo & b.Lo, a.Hi & b.Hi}
}

其中，a.Lo和b.Lo分别是a和b的低64位，a.Hi和b.Hi分别是a和b的高64位。and函数首先对a.Lo和b.Lo进行按位与操作，并同时对a.Hi和b.Hi进行按位与操作，然后组合在一起形成一个新的128位无符号整数，这个整数仅在a和b的相应位都为1时才为1，其他所有位都为0。

在网络编程中，and函数通常用于子网掩码计算，以确定一个IP地址是否在特定的子网中。子网掩码是一个32位的无符号整数，它用于将IP地址分成网络地址和主机地址两部分。子网掩码通常表示为“CIDR表示法”，即“IP地址/子网掩码位数”。例如，“192.168.1.0/24”表示一个子网，该子网包含192.168.1.0到192.168.1.255之间的所有IP地址。在计算机网络中，and函数通常用于将IP地址和子网掩码进行按位与操作，以得到网络地址部分。



### xor

在go/src/net中的uint128.go文件中，xor（）是一个函数，用于计算两个128位无符号整数的异或值。

具体来说，xor（）函数遍历两个输入uint128（a和b），将它们的每个位上的值进行异或（XOR）运算，并返回一个新的uint128，其中每个位都是a和b对应位的值进行异或操作的结果。

此函数主要用于IPv6地址的操作，因为IPv6地址通常表示为128位无符号整数。其中某些比特可能用于特定的指示符或其他标识符，因此在处理IPv6地址时需要对其进行逐位操作。使用xor（）函数可以轻松地对两个IPv6地址进行异或操作，从而实现各种网络编程需求，如唯一标识符计算、地址池分配等。

总之，xor（）函数是一个简单而实用的功能，使我们能够方便地操作128位整数，并在网络编程、加密、哈希等应用中发挥重要作用。



### or

在go/src/net中，uint128.go文件中的or()函数是用于对于两个128位无符号整数进行按位或运算的函数。

该函数接受两个参数，即两个128位无符号整数a和b，并返回一个新的128位无符号整数，该值为a和b按位或的结果。

函数的实现使用了一种优化的算法，即将两个128位整数分别拆分为两个64位整数，然后对这四个64位整数逐个进行按位或运算，并重新组合为一个128位整数返回。

该函数的作用是提供一个高效的按位或运算实现，并且支持128位无符号整数类型，可以广泛用于网络编程中需要使用较大整数的场景，例如IPv6地址处理、网络协议解析等。



### not

在 go/src/net/uint128.go 文件中，not 是一个函数，用于计算无符号 128 位整数（uint128）的按位取反。具体来说，该函数对 uint128 类型的值执行按位取反操作，并返回一个新的 uint128 值。

函数签名如下：

```go
func (x Uint128) not() Uint128
```

其中，x 是要取反的 uint128 值。

该函数的实现非常简单，只需要将 x 的低位和高位分别取反，然后生成一个新的 uint128 值即可。具体的代码如下：

```go
func (x Uint128) not() Uint128 {
    return Uint128{^x.Lo, ^x.Hi}
}
```

这里，^ 表示按位取反操作（即“自反一元运算符”），^x.Lo 表示取反 x 的低位，^x.Hi 表示取反 x 的高位。然后，使用取反后的低位和高位创建一个新的 Uint128 值，并将其返回。

按位取反操作将每个二进制位取反（0 变成 1，1 变成 0），因此 not 函数的作用是将一个 uint128 值的所有二进制位反转。这通常用于加密和网络协议中，以确保消息或数据的机密性和完整性。



### subOne

在uint128.go文件中，subOne()函数用于对一个128位无符号整数进行减一操作。具体来说，它会将指定的128位无符号整数的最低位减去1。

该函数的代码如下：

func (z *Uint128) subOne() *Uint128 {
    if z.Lo == 0 {
        z.Hi--
    }
    z.Lo--
    return z
}

此函数的参数是指向Uint128类型结构体变量的指针，返回值也是该指针。在函数主体中，它首先检查该无符号整数的最低位是否为0。如果是0，它将向该无符号整数的高位减去1。然后，它将该无符号整数的最低位减1。

这个subOne()函数的作用在于将一个128位无符号整数进行减一操作，该操作通常用于计算机算法中的一些计算过程中。



### addOne

在go/src/net的uint128.go文件中，addOne函数用于对一个128位的无符号整数进行加1运算。具体来说，它会对这个128位的整数的低64位进行加1运算，并判断是否有进位（carry）。如果有进位，就继续往高位进行加1运算，直到最高位。

这个函数的作用是用来支持128位无符号整数的算术运算，因为在go语言中，没有内置的类型能够表示128位无符号整数。因此，在net包中，需要通过自定义类型来实现这个功能。而addOne函数则是这个自定义类型中的其中一个运算。

需要注意的是，虽然addOne函数非常简短，但是它的实现涉及到了对二进制数学的深刻理解和技巧，因此，在不了解具体实现原理的情况下，最好不要试图去修改它。



### halves

在go/src/net中的uint128.go文件中，halves这个函数的作用是将128位无符号整数拆分成两个64位无符号整数，即将原数字的高64位和低64位分别保存在两个变量中。

具体实现是，将128位无符号整数的低64位保存在一个变量中，将高64位保存在另一个变量中，然后返回这两个变量。这个函数的定义如下：

func (x Uint128) halves() (hi, lo uint64)

其中，x是一个128位无符号整数，hi和lo是两个64位无符号整数，分别表示x的高64位和低64位。

函数的实现方式是：

	func (x Uint128) halves() (hi, lo uint64) {
		lo = x.Lo
		hi = x.Hi
		return
	}

该函数的作用在于方便对128位无符号整数进行操作，例如计算128位整数的平方等。通过将一个128位无符号整数拆分成两个64位无符号整数来进行计算，可以避免进行128位整数运算引起的性能问题。



### bitsSetFrom

bitsSetFrom函数是用于计算IPv6地址的哈希值的辅助函数。它接受一个IPv6地址作为参数，并将其解析为一个128位的整数，并将其中每个16位块转换为一个uint64类型的值。然后从这些uint64值中生成一个位集，其中每个位表示相应的uint64值中是否有1位。

例如，对于IPv6地址"2001:0db8:85a3:0000:0000:8a2e:0370:7334"，bitsSetFrom函数将返回一个包含以下信息的位集：

000000000000000000000000000000010000000100000000100000011011100010000000000000000000000000000000000000000000000000001000001000100000000001000010101000011100011100

这个位集将用于IPv6地址的哈希值计算，以便在IPv6路由表中查找和匹配条目。具体而言，位集将与预计算的IPv6路由表条目的哈希值的位集进行比较，以确定是否匹配。如果匹配，则此IPv6地址将路由到与此哈希值相关联的路由表条目。



### bitsClearedFrom

bitsClearedFrom() 函数是一个用于计算 uint128 类型值中某一位开始后全部位清零的辅助函数，其算法原理非常简单。

在 uint128 类型值中，最高位为 bit 127，最低位为 bit 0。函数的第一个参数 i 表示要从第几位开始进行清零操作。具体的清零操作是将 i 后全部的位都置为0。

函数的返回值是 uint128 类型值，表示清零操作后的结果。这里使用了 Go 语言的左移运算符（<<）和位或运算符（|）。

具体实现方式如下：

- 先将 0x01 左移 i 位得到一个数，该数表示从第 i 位开始的所有位都是1，其余位都是0。这个数可以通过左移运算符 << 实现。
- 然后将这个数取反，得到一个数，该数表示从第 i 位开始的所有位都是0，其余位都是1。这个数可以通过取反运算符 ^ 实现。
- 最后将该数与原数进行按位或运算(|)，得到的结果就是清零操作后的结果。

例如，如果 i=64，那么从第64位开始的所有位都会被清零（包括第64位）。函数的实现方式可以表示为：

func bitsClearedFrom(i uint) uint128 {
    return uint128(^uint64(0)) | (uint128(^uint64(0)) << i)
}

这个函数的作用是在编写代码时，方便地对 uint128 类型进行位操作。因为在 Go 语言中没有原生支持的 uint128 类型，因此需要使用库文件实现该类型，同时还需要编写一些辅助函数来支持常见的位操作。



