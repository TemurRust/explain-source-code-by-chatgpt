# File: initorder.go

initorder.go文件是Go编译器的一部分，它负责确定Go程序中包级别初始化函数（init）的执行顺序。在Go程序中，每个包可以定义多个init函数，它们用于在程序启动时初始化一些变量或执行一些特定的操作。这些函数在编译时被自动调用，但它们的执行顺序在不同的包之间是不确定的。

为了确保包级别的初始化函数在正确的顺序被执行，Go编译器使用了一种叫做“init依赖分析”的技术。它会从包的依赖关系中推导出每个包的初始化函数执行顺序，并在程序启动时按照正确的顺序调用它们。

initorder.go文件中包含了实现这种“init依赖分析”的逻辑代码。它会遍历整个程序包的依赖关系图，并确定每个包初始化函数的执行顺序。在遍历过程中，它会考虑需要等待其他依赖包初始化完成的情况，并在需要的时候等待。

总而言之，initorder.go文件的作用是确保Go程序中包级别初始化函数的正确执行顺序，从而保证程序的正确性和稳定性。




---

### Structs:

### InitOrder

InitOrder结构体在initorder.go文件中用于保存标准库中所有包的初始化顺序。具体来说，它是一个存储多个初始化函数的列表，每个初始化函数都对应一个包。每个初始化函数都会在程序启动时被自动调用，以确保初始化所有依赖项和全局状态。

该结构体的定义如下：

type InitOrder []InitNode

其中，InitNode是一个结构体，它包含了一个包名和一个初始化函数。定义如下：

type InitNode struct {
    pkg        string      // 包名
    path       string      // 包路径
    impure     bool        // 是否含有副作用（如修改全局变量）
    haveExport bool        // 是否拥有导出符号
    fn         func()      // 初始化函数
}

在程序启动时，初始化顺序通过init函数从所有包中提取并记录，按照依赖关系排序，确保没有循环依赖，可以安全地进行初始化。最终，InitOrder结构体将包名和初始化函数存储在一个有序列表中，供程序在启动时按照顺序自动调用。这些初始化函数在main函数开始执行前自动调用，以确保在程序运行过程中使用它们之前已正确初始化所有依赖项和全局状态。



### initDeps

在Go语言中，每个包都可以包含一个或多个init函数，用于执行一些在程序运行时必须执行的初始化操作。当我们引入一个包时，其中的所有init函数都会被执行。这些init函数的执行顺序是有一定规则的。

initDeps结构体的作用是记录init函数之间的依赖关系。init函数之间可能存在依赖关系，比如某个init函数需要先执行另外一个init函数，才能正确地执行。为了满足这种依赖关系，Go语言使用了一种类似于拓扑排序的算法来对init函数的执行顺序进行排序。

initDeps结构体中包含了一个deps map，这个map记录了每个init函数的依赖关系。其中，key是init函数的地址，value是一个字符串切片，表示所有依赖该init函数的其他init函数。

在程序启动时，Go语言会根据这些依赖关系来确定init函数的执行顺序。具体来说，它会先找到所有没有依赖的init函数，将它们放入一个队列中。然后，依次从队列中取出init函数并执行，同时更新它的依赖关系。

如果当前init函数执行时发现某个依赖的init函数还没有被执行过，那么它就会暂时把自己从队列中取出，把依赖的init函数加入队列中。待依赖的init函数执行完毕后，当前init函数再被放回队列中执行。

通过这种方式，可以确保所有init函数的依赖关系得到正确地处理，并且它们按照正确的顺序被执行。



### declOrder

在Go语言中，包（package）的初始化顺序可以影响程序的运行结果。initorder.go文件中的declOrder结构体用于记录包的变量和函数的声明顺序，以便在包初始化时按照正确的顺序进行初始化。

具体来说，当一个Go程序中有多个包时，每个包的初始化会按照以下顺序进行：

1. 首先初始化包级别的变量和常量，这些变量和常量可能依赖于其他包级别的变量和常量。
2. 接着按照依赖顺序初始化包级别的函数，这些函数可能依赖于其他包中的变量或函数。

declOrder结构体用于记录每个包中所有的变量和函数，以及它们被声明的顺序。当一个包需要进行初始化时，会根据declOrder结构体中记录的声明顺序按照正确的顺序进行初始化。这样可以确保在初始化过程中不会出现依赖关系的问题。

需要注意的是，为了确保一个包能够在初始化时得到正确的顺序，我们需要手动按照依赖关系记录变量和函数的声明顺序。如果不记录或记录错误的顺序，就会导致程序在初始化时出现依赖关系问题，从而出现意料之外的错误。



## Functions:

### initOrder

initOrder是一个用于计算包的初始化顺序的函数。在 Go 语言中，每个包都可以包含一个或多个 init 函数，并且这些 init 函数会按照一定顺序被自动调用。initOrder 函数的作用就是确定这些 init 函数的执行顺序，以确保所有的依赖关系被正确地处理。

initOrder 函数会通过依赖分析来确定 init 函数的执行顺序。具体来说，它会维护一个依赖关系的图，其中包之间的依赖关系被表示为有向边。然后，它会进行拓扑排序，以得到一个合适的执行顺序。排好序之后，每个包的 init 函数就会按照这个顺序被调用，以确保各个包之间的依赖关系不会出现问题。

在 Go 语言中，init 函数的执行顺序是非常重要的，因为它可以影响程序的正确性和性能。通过使用 initOrder 函数，我们可以确保 init 函数的执行顺序是正确的，并且可以提高程序的可维护性和稳定性。



### processAssign

initorder.go中的processAssign函数是用于处理赋值语句的函数。具体来说，它用于提取赋值语句中的变量名和变量值，并将变量名与变量值进行关联。

在Go的初始化过程中，所有的包和其内部的其他文件都会被编译，并以特定的顺序进行初始化。在这个过程中，如果包中有全局变量需要被初始化，则会先执行赋值语句。由于Go允许多个赋值语句出现在一个声明语句中，因此需要使用processAssign函数来解析这些复合的赋值语句。

processAssign函数的输入参数是一个*ast.AssignStmt类型的节点，并返回一个map[string]*symbol类型的值。它会遍历赋值语句中的所有左侧和右侧的表达式，并将左侧的变量名与右侧的变量值进行关联，并返回一个存储了所有变量名和变量值的map。

具体来说，processAssign函数会判断赋值语句中左侧的表达式的类型，如果是一个标识符，则说明它是一个变量名，将其加入到map中；如果是一个复合表达式，则需要继续遍历其子表达式，以此类推。当遍历完所有的表达式后，就可以得到一个存储了变量名和变量值的map，供后面的初始化过程使用。



### flushReady

在Go语言中，函数和变量的初始化顺序是很重要的。在初始化过程中，如果存在循环依赖的情况，就会导致程序无法正常运行。

initorder.go文件中的flushReady函数就是负责处理初始化过程中的循环依赖问题的。它的作用是将所有已经初始化好的函数和变量从待初始化队列中移除，以确保它们不会被重复初始化。

具体的实现方式是，在执行完一个函数或变量的初始化后，判断它是不是其他函数或变量的依赖项。如果是，就将依赖项的状态设置为已经初始化完成。然后，再次遍历待初始化的函数和变量，查找处于“即将初始化”状态并且所有依赖项都已经初始化完成的函数和变量，将它们从待初始化队列中移除，加入到已初始化队列中。

这样，就保证了所有的函数和变量都按照正确的顺序进行初始化，避免了循环依赖问题的出现。



### findInitLoopAndExit

findInitLoopAndExit函数的作用是在程序的初始化过程中，检查任何可能导致死循环的循环依赖关系，并在必要时向用户报告错误消息和退出程序。

该函数采用深度优先搜索算法遍历整个初始化函数列表，查找循环依赖关系。如果发现任何循环依赖关系，则会生成错误消息并打印出来。如果未发现循环依赖关系，则该函数返回。如果发现循环依赖关系，并且用户设置了环境变量“GOINITCHECK”，则该函数会打印错误消息并调用os.Exit(2)终止程序。

因此，findInitLoopAndExit函数的作用是确保程序的初始化过程中没有循环依赖关系，以避免导致死循环和其他错误。



### reportInitLoopAndExit

reportInitLoopAndExit函数的作用是在程序初始化时检测循环依赖关系，如果发现循环依赖则打印错误信息并退出程序。

在Go语言中，程序初始化工作主要是由init函数完成，并且init函数可以定义在任意包中。init函数的调用顺序由依赖关系决定，即在调用一个包的init函数之前需要先调用它所依赖的其它包的init函数。

当存在循环依赖时，比如A依赖B、B依赖C、C依赖A，就会形成一个环形依赖关系。这种情况下程序初始化流程就会陷入无限循环，从而导致程序无法启动或抛出异常。因此，需要在程序初始化时检测并避免循环依赖的情况出现。

reportInitLoopAndExit函数的实现方法是使用了深度优先搜索算法来遍历包之间的依赖关系，并标记已访问的包。如果在这个过程中发现了一个已经被访问过的包，则表明存在一个循环依赖关系。此时，函数会以错误信息的形式输出循环依赖的包名，并调用os.Exit函数退出程序。

正常情况下，reportInitLoopAndExit函数不会被调用。只有在包的依赖关系出现错误时才会调用该函数。因此，该函数的作用是确保Go程序能够在正确的顺序下完成初始化过程，并避免在程序启动时遇到不可预测的错误。



### collectDeps

collectDeps函数的作用是收集一个包的所有依赖，然后返回一个按照依赖关系排序的包的列表。具体的实现过程如下：

1. 创建一个map类型的 visited 变量，用于记录每个包是否已经被访问过。
2. 在循环中遍历每一个传入的包，对每个包递归进行访问，如果已经被访问过，则直接跳过；否则，先将该包标记为已访问，然后递归访问该包的所有直接依赖包。
3. 如果某个直接依赖包已经被访问过，则说明存在循环依赖，此时 collectDeps 函数会抛出一个 panic；
4. 递归访问每个直接依赖包的依赖，将依赖关系保存下来。
5. 最后将所有包按照依赖关系排序，返回一个排好序的包的列表。

通过 collectDeps 函数的执行结果，可以得到一个按照依赖关系顺序排列的包的列表，这可以帮助我们在程序运行时按照正确的顺序初始化各个包，从而避免由于依赖关系错误导致的运行时错误。



### cachedVisit

cachedVisit是一个闭包函数，用于缓存已经访问过的包，并避免循环依赖的问题。

在initorder.go文件中，使用importGraph函数生成了一个表示包之间依赖关系的有向图，cachedVisit函数用于遍历这个图，找到所有需要进行init函数调用的包，并按正确的顺序进行调用。

当cachedVisit函数第一次访问一个包时，它将该包加入一个map中，表示该包已被访问。当函数在遍历图时遇到之前已经访问过的包，它将返回已经缓存的结果，避免重复计算。同时，如果遍历过程中发现有环路存在（循环依赖），则该函数会通过panic函数将错误抛出。这是因为循环依赖会导致无法确定初始化函数的正确顺序，因此程序必须强制退出以避免出现不可预知的行为。

因此，cachedVisit函数是initorder.go文件中实现包初始化顺序的一个关键函数，它可以帮助程序正确地执行包的初始化函数，并处理任何循环依赖的情况。



### inspect

在 go/src/cmd 中，initorder.go 文件实现了一个工具，可以显示 Go 包中所有可见的 init 函数和它们的顺序。

其中，inspect 这个函数的作用是读取 Go 包的 AST，寻找其中的 init 函数，并记录它们的顺序。具体而言，inspect 函数会遍历 AST 中的所有节点，当发现一个函数调用节点时，判断它是否是 init 函数，如果是则记录它所在的文件、行数和顺序。

这个函数使用了 go/parser 和 go/token 两个标准库，它们可以帮助我们解析 Go 代码的 AST，并提供了丰富的方法来分析代码。inspect 函数最终会返回一个 initList 类型的结构体，其中包含了所有 init 函数的信息，例如文件名、行号和顺序。

这个工具有助于我们了解 Go 包中各个 init 函数的执行顺序，确保它们按照正确的顺序初始化，从而避免一些潜在的 bug。同时，它也可以帮助我们分析代码中出现的一些问题，例如重复的 init 函数等。



### inspectList

在 Go 语言中，程序的初始化过程是一个比较复杂的过程，需要考虑多个因素的影响。initorder.go 文件中的 inspectList 函数主要的作用是为了分析程序的初始化顺序，并根据依赖关系对所有初始化函数进行排序。

具体来说，inspectList 函数会对所有已知包的初始化函数进行分析，主要是检查它们之间的依赖关系。如果发现某个初始化函数依赖于另一个初始化函数，那么该函数就必须排在被依赖函数的后面执行。这样可以保证程序的正确执行顺序，避免出现依赖关系错误导致的错误。

inspectList 函数还会检查每个包的所有初始化函数是否有循环依赖的情况。如果存在循环依赖，则会报错并终止程序的编译过程。

最后，inspectList 函数会将所有初始化函数按照正确的顺序排序，并返回排序后的列表。这个列表将会被编译器用于生成初始化代码，确保程序能够正确地初始化整个环境。

总之，inspectList 函数是 Go 语言初始化过程中的一个重要环节，它能够保证程序在初始化阶段的正确执行，避免出现依赖关系错误等问题。



### visit

在initorder.go文件中，visit函数用于遍历整个包并确定每个init函数的调用顺序。init函数是在程序运行时自动调用的一种特殊函数，用于执行包的初始化操作。

visit函数会首先遍历包中所有依赖的包，然后对每个包中的init函数进行排序。排序依据是每个init函数中的调用关系，即如果一个init函数依赖另一个init函数，则先调用被依赖的函数。

visit函数的返回值是一个排好序的init函数列表，这个列表将作为程序运行时init函数的调用顺序。如果存在循环依赖，则visit函数会返回一个错误。

因此，visit函数的作用是确定包中多个init函数之间的调用顺序，确保程序能够正确的初始化并运行。



### foundDep

foundDep是在initorder.go文件中的函数，它的作用是遍历Go程序中所有的包，查找包之间的依赖关系，并在完成查找后返回所有包的依赖顺序。

具体来说，它实现了一个依赖图的遍历算法，从Go程序的入口包开始，按照拓扑排序的方式遍历所有依赖关系，直到找到所有的包。在遍历的过程中，它使用了一个标记，用于避免重复遍历，以及一个栈，用于记录被访问的包以及它们的依赖顺序。同时，它还会考虑一些特殊情况，例如循环依赖的情况。

最终，foundDep函数返回一个列表，其中包含所有Go程序中的包，并按照它们的依赖顺序进行排序。这个排序对于Go编译器来说很重要，因为它能够确保所有依赖项被正确地加载和初始化，从而使程序能够正确地运行。



### Len

在initorder.go文件中，Len函数是一个排序功能中的参数，它返回排序所涉及到的数据集的长度。

具体来说，它用于在初始化函数按照一定顺序调用时排序的操作中。在Go语言中，通过使用init函数来实现初始化操作，而且会按照一定的顺序来执行，具体规则是：

1. 首先执行引用其它包的init()函数；
2. 每个包按照它们所在的包依赖关系顺序执行它们的init()函数；
3. 同一个包中的多个init()函数按照它们在源文件中的顺序执行。

因此，为了确保代码的正确性和可读性，需要对这些init函数进行排序。而在initorder.go文件中，Len函数的作用就是在排序前返回需要排序的函数数目（具体为函数的地址的数量），以便于进行后续的操作。

总的来说，Len函数的作用是计算一组元素的长度，并且配合其它排序算法一起使用，对元素进行排序。在Go语言中，Len函数通常作为排序算法中的参数，例如在sort包中，排序函数需要使用Len函数来获取需要排序的数据集合的长度，以便对它们进行比较和排序。



### Less

在initorder.go文件中，Less函数用于比较两个程序包的依赖关系，返回值为一个布尔值，表示第一个程序包是否依赖于第二个程序包。具体来说，该函数会检查两个程序包中的依赖关系数组，如果第一个程序包依赖于第二个程序包，则返回true，否则返回false。

对于一个给定的可执行程序或库，GO语言会根据程序包的依赖关系来进行编译。因此，了解程序包之间的依赖关系非常重要。而Less函数则提供了一种简单而有效的方法来比较两个程序包之间的依赖关系，以此来确定它们之间的编译顺序。

在实际运用中，Less函数通常会被用在Go语言自带的构建工具中，比如go build、go install等命令中，以确保程序包的编译顺序是正确的，避免在编译过程中出现错误或警告。



### Swap

在go/src/cmd/initorder.go文件中，Swap函数实现了对Dependency类型的切片中的两个元素进行互换。

具体来说，Swap方法将切片中两个元素的位置进行互换。这是在对依赖关系切片进行排序时非常重要的一步。这个方法通常被sort.Sort的实现所调用，因为它需要互换切片中的元素，并在排序期间执行这些操作。

在initorder.go中，Dependency切片是用于记录初始化函数之间的依赖关系，保证初始化的顺序能够正确。Swap方法被用于在对这个依赖关系切片进行排序时，确保依赖先被初始化。如果有两个初始化函数间存在依赖关系（即其中一个初始化函数依赖于另一个初始化函数），则需要将它们的位置进行互换，以确保依赖被正确地初始化。

因此，Swap方法确保了依赖关系切片中的元素能够被正确排序，以确认初始化函数之间的依赖关系被满足。



### Push

在go/src/cmd/initorder.go文件中，Push函数的作用是将一个新的导入路径与与其关联的包级别初始化函数的集合添加到导入路径的顺序列表中。

在Go语言中，包级别的初始化函数是在程序开始执行前自动调用的函数。initorder包中的Push函数将导入路径与与其关联的包级别初始化函数的集合添加到导入路径的顺序列表中，以便可以按顺序执行这些初始化函数。

具体来说，Push函数将导入路径和其关联的初始化函数集合添加到pkgInits列表中，并将导入路径添加到order中。pkgInits列表中的项是initFuncs类型的对象，它是一个包含多个初始化函数的切片。order列表是包含导入路径的切片。

在整个程序开始执行前，initorder包会首先按照导入路径的顺序遍历order列表。对于每个导入路径，initorder会按顺序执行与之关联的所有初始化函数。每个初始化函数是一个在包中定义的不带参数不返回值的函数，用于完成一些预处理工作，例如初始化变量或连接到数据库。

因此，Push函数在Go语言应用程序的初始化过程中发挥了重要的作用，确保按正确的顺序执行包初始化函数。



### Pop

Pop函数是一个堆(lifo)弹出函数，它从一个slice中弹出一个元素并返回它。在initorder.go中，Pop函数用于从initEdges heap中弹出权重最大的元素(边缘)并返回它。具体来说，Pop函数从initEdges slice中弹出具有最大权重的元素，并将其转换为*edge类型。然后，它将它与slice中的最后一个元素交换，然后缩小slice的长度，返回已弹出的元素。这个函数是用在Kahn's algorithm 部分代码中，用于按照依赖关系的权重对init函数进行排序。



### firstLHS

在initorder.go文件中，firstLHS函数的作用是尝试从赋值语句的左侧中提取一个名称并返回。该函数被用于查找Go程序中的所有init函数，并确定它们应该如何排序以便正确初始化程序。

具体来说，该函数会分析传入的赋值语句（包括名称以及值），并尝试从左侧（LHS）中提取名称。如果左侧是一个标识符，则返回该标识符的名称。如果左侧是一个选择器表达式，则递归调用该函数以获得表达式的主体部分，并将该部分后面的名称作为结果返回。如果左侧为其他类型，则返回空字符串。

在init排序算法中，提取赋值语句左侧的名称非常重要，因为该名称通常用于标识init函数。通过将所有init函数按照名称进行排序，可以确保它们以正确的顺序执行，而不会出现由于依赖关系而导致某些函数未被正确初始化的情况。



