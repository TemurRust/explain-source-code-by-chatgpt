# File: biasedsparsemap.go

biasedsparsemap.go是Go语言标准库中的一个文件，主要用于实现BiasedSparseMap类型的数据结构。这个数据结构是一种稀疏位图，用于表示一个大的布尔型数组，其中大部分元素均为false。它的设计目标是在高效地使用内存的同时提供高效的随机访问和迭代。

这个文件中的主要结构体是BiasedSparseMap，它包含了两个主要的成员变量：baseMap和bias。其中，baseMap是一个map[int]uint64类型的映射表，用于存储具有非零值的位的位置和其对应的值，而bias则是一个基准值，表示所有零值的位置都相对于该基准值偏移一定量，以进一步减少存储量和提高访问速度。

这个数据结构支持的主要操作包括：
- Get和Set：获取和设置指定索引处的值。
- Clear：清空数据结构中所有的位。
- Iterator：按顺序迭代所有的非零位，并返回其位置和对应的值。

BiasedSparseMap可以用于许多需要存储大量布尔值的应用程序中，例如位图索引、稀疏矩阵等。它可以避免浪费大量内存来存储无用的false值，同时又提供了高效的存储和访问方法，符合现代计算机系统的内存和速度特点。




---

### Structs:

### biasedSparseMap

biasedSparseMap结构体是Go语言标准库中的一部分，它主要用于实现一种基于分段哈希表的稀疏数据结构，用于存储大量键值对，并支持对这些键值对的快速查找、插入和删除操作。

具体来说，biasedSparseMap结构体内部维护了一个由多个sparseSegment结构体组成的分段哈希表，每个sparseSegment结构体就是一个包含若干个键值对的哈希桶。在进行键值对操作时，biasedSparseMap结构体会根据待操作的键的哈希值，从分段哈希表中选择相应的哈希桶进行操作，从而实现快速的查找、插入和删除。

为了实现更高效的性能，biasedSparseMap结构体还采用了一些优化策略。例如，它会尽可能地利用稀疏性，避免为每个可能的键都分配一个哈希桶，从而降低了内存开销。此外，biasedSparseMap结构体还采用了复杂的动态比率调整方法来动态平衡每个哈希桶的填充率，从而保证各个哈希桶的平均查找时间尽可能地短。

总之，biasedSparseMap结构体是一种高效的稀疏数据结构，可以广泛应用于各种需要高效键值对存储与操作的场景。



## Functions:

### newBiasedSparseMap

newBiasedSparseMap是创建一个新的基于偏移量的稀疏映射的函数。它的作用是创建一个将key映射到value的映射表。在实现过程中，它使用了一个偏移量来降低映射表对内存的占用，因为只有比偏移量大的键才会被添加到映射表中，而小于偏移量的键则会被忽略。在访问映射表时，它会先将要访问的键值减去偏移量，然后在映射表中查找这个键的值。这种实现方式可以减小映射表的内存占用，提高性能，特别是应用于稀疏数据结构的情况下。



### cap

在biasedsparsemap.go文件中，cap函数被定义为：

```
// cap returns the capacity of the bucket array.
func (m *Map) cap() int {
    return int(uintptr(1)<<(uintptr(m.p))) + m.noverflow
}
```

该函数的主要作用是计算哈希桶数组的容量。哈希桶是一个固定长度的数组，用于存储存放键值对的位置。在哈希表中，每个键都被分配到一个桶中，而每个桶中存储的则是由键值对组成的链表。哈希桶数组的容量最好是一个2的整数次幂，以便使用位运算进行计算。

在biasedsparsemap.go文件中，哈希桶数组的长度是通过指数的方式进行计算的。这个指数是通过p值计算出来的，p是一个表示当前哈希桶数组长度的指数。因此，cap函数计算哈希桶数组所占用的内存为2的p次方，加上未使用的溢出槽。

在以空间换时间为主要目的的算法中，正确的容量计算非常重要。合理的容量设计可以减少空间的浪费，同时提高哈希表的效率和性能。cap函数提供了对哈希桶数组容量的准确计算，节省空间却不影响哈希表的性能。



### size

在go/src/cmd/biasedsparsemap.go文件中，size函数用于返回打包键/值对后map的大小。在内部实现中，它通过遍历map中的每一项来计算map的大小。

具体来说，size函数会遍历位向量和数据数组，统计每个集合单元中键/值对的数量，然后将它们相加，最终得到map的大小。

这个函数的作用在于为map提供一种快速获取大小的方法，而不需要遍历整个map来计算它。这对于需要频繁获取或比较map大小的情况非常有用，可以提高代码的效率和性能。

总之，size函数是一个非常重要且有用的函数，它帮助我们快速获取map的大小，并且可以大大提高代码的效率和性能。



### contains

contains是biasedsparsemap中的一个方法，用于检查给定的key是否存在于map中。

该方法通过调用getBucket方法查找给定key所对应的bucket，然后遍历bucket中的所有key，如果找到匹配的key，则返回true，表示key存在于map中。

这个方法的作用是为了实现map的基本功能，即存储键值对及通过键来查找对应的值。contains方法是其中的一个基础方法，它提供了在map中检查某个键是否存在的能力，可以帮助调用者确定是否需要进一步操作该键所对应的值。



### get

get函数是 BiasedSparseMap 类型的方法，用于从地图中获取键值。 BiasedSparseMap 是 Go 语言中用于高效存储大量稀疏布尔值的数据结构。

get函数的作用是通过给定的偏好值查找地图中对应键的值。如果该键的值不存在，则返回默认值false。该函数的关键在于选择偏好值。偏好值是一个非常低的值，从0到1。偏好值越低，查找键时的局部性越高，这有利于提高查找效率。在实际应用中，偏好值通常设置在0.01以下。

具体来说，get函数会首先根据给定偏好值直接查找地图中是否存在给定键。如果存在，则返回相应的布尔值。如果不存在，则将偏好值增加10倍并在地图中查找以此偏好值作为后缀的键。如果找到了，返回布尔值。否则，继续增加偏好值并尝试查找，直到找到最接近的键为止。

总之，get函数通过尝试不同的偏好值来提高查找效率，并确保了搜索过程的高效性。



### getEntry

在Go语言的cmd包中，biasedsparsemap.go文件是为了实现一种自适应的稀疏哈希表（Biased Sparse Map）而创建的。而getEntry函数是该哈希表中的一部分，它用于查找并返回给定键的条目。

具体来说，getEntry函数有以下作用：

1. 通过计算哈希值，找到对应的桶（Bucket）。

2. 在该桶中找到与给定键匹配的条目（Entry）。

3. 如果没有找到匹配项，则从高速缓存中获取相似项。

4. 如果找到了相似项，则对比相似项中的键和给定键，找到最相似的那个并返回。

5. 如果没有相似项，或者相似项与给定键的相似度低于一定阈值，则创建一个新条目，并返回它。

总之，getEntry函数是实现稀疏哈希表的关键步骤之一。它主要负责查找并返回对应键的条目，并通过相似度计算来提高查找效率。同时，也涉及了一些高速缓存和自适应性的技术，从而让哈希表在不同的场景下有较好的表现。



### add

文件路径为go/src/cmd/biasedsparsemap.go中的add函数是用于向稀疏映射添加一个键值对的函数。稀疏映射是指其键值对的密度很低，即包含了很多空值或默认值，因此实际存储的值数量要比键值对的总数少得多。BiasedSparseMap是一种特殊的稀疏映射，它采用了一种称为偏向位图（biased bitmap）的数据结构来提高查找速度。

具体来说，add函数的作用是将给定的键值对添加到BiasedSparseMap中。如果该键已存在，则更新其对应的值；否则，将键值对添加到map中。BiasedSparseMap使用了位图来存储键的集合，每个位表示一个键是否存在于map中。为了降低实际存储的位图的大小，BiasedSparseMap采用了一种策略来偏向某些位；也就是说，在位图中，特定的位权重更高，因为它们更可能被访问到。这样可以减少位图所需存储的位数，从而节省了内存空间。

在add函数中，首先获取键的哈希值，并计算出在位图中对应的位。然后，如果该键已经存在于位图中，则更新其对应的值；否则，将其添加到位图和映射中，并更新位图的偏向位。最后，如果位图的大小大于等于阈值（默认为512），则执行rehash操作以重新计算所有键的哈希值，并将它们分配到新的桶中。

总之，add函数是BiasedSparseMap数据结构中非常关键的一个操作，能够向稀疏映射中添加新的键值对，并且通过位图和偏向位优化查找速度和内存占用。



### set

在Go中，biasedsparsemap.go是一种实现称为“偏稀疏地图”的数据结构的代码文件。set（）函数是该数据结构中的一个方法，旨在将键值对插入到地图中。

偏稀疏图是一个类似于散列表的数据结构，它的目标是解决散列表中空间浪费的问题，尤其是对于只包含少量键值对的情况。该结构使用两个数组，分别用于存储键和值。这使得偏稀疏图在某些情况下比散列表更有效。在调用set（）方法时，偏稀疏图首先使用哈希函数将键转换为索引，然后在该索引处插入键和值。

由于偏稀疏图只使用真正需要的空间，因此它可以在需要时快速增长，而不会像散列表那样可预测地增长。此外，由于它使用两个数组，而不是链表或其他结构，因此它可以更快地访问键和值。这使得偏稀疏图在某些情况下比散列表更为实用。

总之，set（）方法是偏稀疏图数据结构中的一个方法，在插入键值对时使用哈希函数计算键的索引，并在该索引处存储键和值。



### remove

在biasedsparsemap.go文件中，remove函数的作用是从有偏稀疏映射中删除指定的键及其相应的值。具体来说，remove函数接受一个键作为参数，首先使用哈希函数计算该键的哈希值，然后通过这个哈希值来找到有偏稀疏映射中存储该键的桶。接下来，函数会遍历桶中的所有元素，找到与给定键匹配的元素，并将其从桶中删除。最后，函数会更新有偏稀疏映射的统计信息，将已删除元素的数量从计数器中减去。

在有偏稀疏映射中，remove函数的实现与insert函数的实现类似，都需要考虑到键的哈希冲突和桶的动态扩展等问题。因此，在实现remove函数时，需要仔细处理这些细节，并保证删除操作的正确性和效率。



### clear

函数名称：clear

作用：将位图中的所有位清零，相当于将神经网络的权重全部初始化为零。

函数实现：

该函数为biasedsparsemap类型的方法，其代码实现如下：

```
// clear sets all bits in the bitmap to 0.
func (m *biasedSparseMap) clear() {
        for i := range m.dense {
                m.dense[i] = 0
        }
        for i := range m.sparse { // iterate over the non-nil elements
                for j := range m.sparse[i] {
                        m.sparse[i][j] = 0
                }
        }
}
```

该方法首先遍历了dense数组中的所有元素，将其设置为0。然后遍历了sparse数组中非nil的所有值，并将其设置为0。由于biasedSparseMap使用sparse数组来存储非零权重，所以只需要遍历sparse数组中的元素即可。

该方法保证了将整个位图的所有位初始化为0，从而对应的所有权重被初始化为零。

应用场景：

在神经网络的训练过程中，通常需要随机初始化网络中的权重。该函数可以在训练开始前，将网络中的所有权重初始化为零，为后续的训练做好准备。



