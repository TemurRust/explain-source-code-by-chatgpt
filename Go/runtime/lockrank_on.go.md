# File: lockrank_on.go

lockrank_on.go文件是Go语言运行时中的一个文件，主要作用是为了在运行时对已经锁定的goroutine进行排名，以便在goroutine争夺锁时进行优先级调度。

具体来说，当一个goroutine需要获取一个已经被锁定的锁时，它会被加入到该锁的等待队列中。在等待队列中，每一个等待的goroutine都会被标记上一个锁级别（lock rank），表示它在等待队列中的优先级。

go/src/runtime/lockrank_on.go这个文件中的代码会对所有等待队列中的goroutine进行计算排名。排名的计算基于以下几个因素：

- 当前goroutine所等待的锁的锁级别
- 当前goroutine已经Waiting/Running的时间
- 当前goroutine还需要等待的时间

通过对这些因素的计算，就可以确定每个等待队列中goroutine的排名。在争夺锁时，排名较高的goroutine将被优先选择执行。

总之，lockrank_on.go文件中的代码用于帮助Go语言的运行时实现更加高效公平的goroutine调度。




---

### Var:

### worldIsStopped

在Go语言中，当某个goroutine需要访问共享资源时，为了确保多个goroutine之间的访问不会相互干扰，需要使用锁进行同步。锁本质上是一种机制，用于防止多个goroutine同时访问共享资源。在锁的背后，是一种名为“world stop”的技术，它用于停止整个Go程序，以便在获得锁之后顺利执行相应的代码。当锁处于活动状态时，无法进行上下文切换，因此需要一个重要的变量：worldIsStopped。

worldIsStopped是一个布尔变量，在lockrank_on.go文件中定义，并且是用来控制世界是否停止的。当它被设置为true时，所有goroutines都将被暂停，即所有goroutines都陷入了等待状态，直到世界被重新启动时才能继续执行。在锁机制中，当一个goroutine尝试获取锁时，如果锁已经被占用了，那么它将等待锁释放，并且在等待期间会将worldIsStopped设置为true。这样，所有其他goroutines都将被暂停，以确保该goroutine可以成功获取锁并执行对共享资源的操作。因此，worldIsStopped是锁机制中非常重要的一个变量，它确保了锁的正确性和顺利的执行。

总之，worldIsStopped是一个用于保护共享资源的锁机制的关键变量。它确保了锁的正确性和同步性，以防止多个goroutine同时访问共享资源。






---

### Structs:

### lockRankStruct

lockRankStruct是一个锁结构体，用于记录线程和提供锁访问信息。该结构体主要包含以下字段：

- rank：代表当前线程的锁等级，用于指示锁的使用顺序，遵循先上高级锁再上低级锁的原则。
- m：指向当前线程的锁，可以是任何类型的锁对象，如互斥锁、读写锁等。
- locked：指示锁是否被持有，如果locked=true，则表示该锁已被持有，如果locked=false，则表示该锁未被持有。
- next：指向下一个等待锁的线程，用于构成等待队列。如果next=nil，则表示当前线程不在等待队列中。
- prev：指向前一个等待锁的线程，用于构成等待队列。如果prev=nil，则表示当前线程是等待队列的首个线程。

lockRankStruct结构体的作用是为了确保锁的正确使用顺序，从而避免死锁。在使用不同类型的锁时，不同的线程可能会以不同的顺序申请和释放锁，这可能会导致死锁。为了避免这种情况，go语言设计了一种锁等级机制，使得线程在访问锁时按照固定的顺序进行，从而有效避免死锁的发生。

lockRankStruct结构体的字段rank和m是锁等级和锁对象的映射关系，通过设置不同的rank可以表示不同的锁等级，而通过m指向不同的锁对象可以实现对不同类型的锁的支持。locked字段表明该锁是否被其他线程持有，如果已被持有，则当前线程需要等待。next和prev是构成等待队列的指针，用于实现线程的阻塞和唤醒，从而保证锁等级的正确性和线程的安全性。



## Functions:

### lockInit

在 runtime 中，lockInit 函数的作用是初始化锁的排名信息。锁的排名是指根据锁的使用顺序给锁编号，从而实现对锁的有序使用，防止死锁。当一个 goroutine 获取一个锁的同时，如果另一个 goroutine 正在等待获取该锁，则该锁的排名被设置成一个高于当前锁等待 goroutine 的排名。

具体来说，lockInit 函数会创建一个锁排名的链表，并将该链表初始化为一个空链表。同时，该函数还会将所有可重入锁（例如 mutex、rwmutex 等）添加到排名链表中，从而对它们进行排序。这个过程依赖于 Go 语言的反射机制，因为可以通过反射来获取可重入锁结构体的字段。

总之，lockInit 函数是 runtime 中实现锁排名机制的关键函数之一，它确保了锁的有序使用，从而提高了并发程序的效率和稳定性。



### getLockRank

getLockRank是一个函数，它的作用是返回当前线程持有的锁的ranking值。在Go的运行时系统中，锁是用来控制并发访问共享资源的重要机制。每个锁都有一个ranking值，ranking值越高的锁越可能出现死锁和其它并发访问问题。

getLockRank函数背后的设计目的是为了帮助诊断并发问题。当程序出现并发问题时，调用getLockRank函数可以获取每个线程持有的锁的ranking值，从而定位出问题所在。比如，如果一个线程持有了ranking值较高的锁并阻塞了另一个线程，那么可能会产生死锁或者其他的并发问题。

具体来说，getLockRank函数的实现方式是，遍历当前线程持有的所有锁，并计算出其中ranking值最高的那个锁的ranking值。如果线程持有多个锁，那么最高的ranking值就是这些锁中ranking值最高的那个。最后，该函数返回最高的ranking值。

总之，getLockRank函数是Go运行时系统提供的一个用于排查并发问题的工具函数，它可以帮助程序员快速定位并发问题并进行调试。



### lockWithRank

lockWithRank是用于实现锁的函数，它的作用是加锁。它是在锁竞争的背景下设计的，它包含一个锁定的标识符和一个等级。

这个函数通过检查相邻的锁的等级，来判断当前线程是否在竞争锁的过程中。如果是，它就会检查锁的等级和当前线程的等级，并比较锁的等级与当前线程的等级，以确定哪个线程将获得锁。

在LockWithRank函数内，它会用for循环去判断当前的锁的等级是否比传入函数的rank大，如果大了，则将锁的等级降为rank，表示此线程的等级较高，需要优先获取锁。最后将此锁的mutex字段设为锁定状态并返回。

如果当前线程的等级比预测获得锁的线程的等级高，则当前线程获得锁，否则当前线程会阻塞等待。这种等级机制可以避免锁饥饿，确保高等级线程获得锁的优先权，从而提高并发性能。

总之，lockWithRank函数实现了一种基于优先级的锁机制，使得高优先级的线程可以优先获取锁，提高了并发性能。



### printHeldLocks

lockrank_on.go文件是 Go 语言的运行时库中与锁竞争检测相关的文件之一，该文件中的printHeldLocks函数用于打印持有的锁的信息。

具体地说，printHeldLocks函数会在应用程序关闭时被调用，它会将当前的 Goroutine 持有的锁的信息打印出来，包括锁对象的地址和锁的类型，以及获取锁的位置和调用堆栈。

这些信息可以帮助开发人员更好地了解应用程序中的锁竞争情况，进而优化代码以减少锁竞争问题。同时，这些信息也可以用于分析和排查应用程序中的死锁和饥饿问题。

总之，printHeldLocks函数是锁竞争检测过程中非常重要的组成部分，它帮助开发人员更好地了解和解决锁竞争问题。



### acquireLockRank

acquireLockRank函数是用于在运行时中获取排它锁申请的锁级别的函数。锁级别是一个用来标识锁的重要性和它在锁竞争中的优先级的数字。在运行时中，如果两个goroutine都需要获取同一种类型的锁，那么它们之间的锁竞争就会发生。在这种情况下，拥有更高锁级别的锁持有者会成功地获取锁，而持有较低锁级别的锁的goroutine会被阻塞。

acquireLockRank函数的作用是返回一个表示某种类型的锁的锁级别的值。锁级别的值是在运行时中动态计算的，它会考虑某个goroutine已经持有的锁，以及其他正在竞争锁的goroutine的情况。在获取锁时，如果一个goroutine要获取一个锁，它会调用acquireLockRank函数来获取这个锁的锁级别，然后根据锁级别来决定是否等待或放弃锁。如果一个锁的锁级别比其他正在竞争的锁的锁级别高，那么当前的goroutine就可以成功获取锁。如果锁级别低于其他正在竞争的锁的锁级别，那么当前的goroutine就会被阻塞，直到更高级别的锁被释放。

acquireLockRank函数的实现比较复杂，需要检查所有正在竞争锁的goroutine，以及这些goroutine已经持有的锁的锁级别，以便计算出当前的锁应该有多高的锁级别。这个函数是运行时中实现锁竞争的关键所在，它可以保证锁的竞争顺序，避免死锁，并且让运行时更加高效。



### checkRanks

checkRanks函数是在标准库中runtime包lockrank_on.go文件中的一个函数，它的主要作用是检查goroutine被锁定的数量和锁定等级。该函数会遍历所有goroutine的锁定等级，并将其与全局锁定等级进行比较，以确保所有goroutine的锁定等级匹配。

具体而言，checkRanks函数会在runtime执行期间，检查所有goroutine的锁定状态并与全局锁定等级进行比较。如果有任何goroutine的锁定等级高于全局锁定等级，将会触发panic，以保证程序不会在高锁定等级的情况下运行。

checkRanks函数的主要目的是确保在runtime期间，所有goroutine的锁定等级是可以接受的，以便保证程序运行的可靠性和稳定性。这个函数在保障程序正确性方面起到了非常重要的作用。



### unlockWithRank

unlockWithRank函数的作用是解锁排名锁，根据排名锁的规则，只有持有排名锁的goroutine可以解锁它，而且只能解锁比自己rank小的锁。在unlockWithRank函数中，需要传入持有排名锁的goroutine的rank，然后将对应的锁解锁。

在实际的排名锁使用中，由于锁的数量是有限的，而且每个锁只能被特定的goroutine持有和解锁，因此需要对锁进行动态分配和管理。每个goroutine根据需要获取排名锁时，都会先申请一个rank，然后根据rank去获取对应的锁。而且每个goroutine所持有锁的数量也是受限制的，因此需要根据实际情况来合理分配锁资源。因为排名锁需要实现的功能较为复杂，所以使用排名锁的代码会相对较为复杂。

总之，unlockWithRank函数是排名锁实现中的核心之一，它负责解锁锁，实现锁的释放功能。在排名锁的实现中，需要特别注意锁的数量和分配，以保证锁的效率和正确性。



### releaseLockRank

releaseLockRank函数主要用于释放锁级别，并将锁级别状态从"拥有"转换为"可获取"。在Go语言中，为了避免死锁等问题，引入了锁级别的概念，每个协程（goroutine）都有一个关联的锁级别，用来表示可以同时保持的锁的数量。在锁级别高于0的情况下，如果某个协程尝试获取已被其他协程持有的锁，则会导致该协程阻塞等待锁的释放。

releaseLockRank函数的实现主要分为两个步骤：

1. 将当前协程的锁级别减1，这表示已释放一个锁。

2. 如果当前协程的锁级别变为0，则将该协程的锁级别状态设置为"可获取"，表示可以再次尝试获取锁。

这个函数的作用是确保锁的正确性以及减少死锁的风险。由于Go语言中的锁级别机制，协程只能在锁归还后才能继续执行，如果一个协程一直处于等待状态，则可能会导致系统资源的浪费。因此，释放锁级别可以让其他协程有机会获取锁，从而提高系统的吞吐量和响应性能。



### lockWithRankMayAcquire

lockWithRankMayAcquire函数是一个被用于锁定和解锁互斥锁的内部函数。它使用一个基于排名的锁来实现，以确保不会产生死锁和优先级反转。

该函数的作用是尝试获取指定互斥锁的锁，并执行一系列的锁状态检查以确保锁的正确性。如果当前没有其他goroutine持有互斥锁，则该函数会立即获得锁并将排名设置为1。否则，如果有锁被占用，则会执行一个排队等待的过程。在这个过程中，该函数会根据占有锁的goroutine的排名和当前goroutine的排名之间的比较来确定等待或放弃等待的锁。

通过使用基于排名的锁系统，可以避免死锁和优先级反转的问题，确保锁的所有用户都能够获得良好的性能和资源管理。因此，lockWithRankMayAcquire函数在确保并发中正确性的同时也提高了系统的性能和稳定性。



### checkLockHeld

checkLockHeld函数用于检查当前goroutine是否持有一个给定的锁（LockRank），如果没有，函数将会阻塞等待直到持有该锁为止。

具体来说，checkLockHeld函数会将当前goroutine的LockRank状态设置为waitLockHeld，并且将其加入到等待该锁的goroutine队列中。然后会调用park函数将goroutine挂起，等待被唤醒。当其它goroutine释放该锁时，会使用unlockWithRank函数将其它等待该锁的goroutine唤醒。唤醒的goroutine会继续执行checkLockHeld函数，检查是否持有该锁。

checkLockHeld函数的作用是保证锁的正确性和避免死锁。在使用LockRank时，确保每个goroutine都按照规定的顺序获取和释放锁，否则会引发死锁。使用checkLockHeld函数可以确保每个goroutine不会因为等待某个锁而死锁，同时保证了锁的正确性。



### assertLockHeld

assertLockHeld函数的作用是检查当前goroutine是否持有特定类型的锁。如果当前goroutine没有持有该类型的锁，则引发panic。

在Go的运行时系统中，锁是保护共享资源的一种机制。在某些情况下，我们需要检查当前goroutine是否具有对锁的特定类型的所有权。如果当前goroutine没有正确持有锁，则可能会导致竞态条件和数据损坏。

assertLockHeld函数是为了帮助开发人员在调试和开发过程中更容易地发现此类错误。它接受一个lockRank参数，该参数指定要检查的锁的类型。如果当前goroutine没有持有该类型的锁，则会引发一个panic。这使开发人员可以立即知道该goroutine的状态，从而更快地排查问题。

总之，assertLockHeld函数通过检查当前goroutine是否持有特定类型的锁来提高程序的健壮性和稳定性。它是Go语言运行时系统的核心组件之一，可以帮助我们编写更可靠和安全的代码。



### assertRankHeld

assertRankHeld函数用于确保当前goroutine持有锁的rank（排序等级）。在这个文件中，锁是基于rank排序的，因此确保持有正确的rank是非常重要的。

如果一个goroutine试图释放它没有持有的锁，或者试图获得一个它已经持有的锁，那么就会导致锁的排序错误。

assertRankHeld函数的实现很简单，它只是使用了一个检查锁rank是否是当前goroutine持有的rank的if语句。如果这个条件不成立，那么就会产生一个panic，让程序崩溃，从而防止出现锁排序错误。

总之，通过assertRankHeld函数，可以有效地确保在使用锁的过程中，排除一些人为错误，保证程序的正确性。



### worldStopped

lockrank_on.go中的worldStopped函数是用于检查是否所有的Goroutine都停止以及mutex是否锁定的函数。在Go语言中，一个Goroutine是一个轻量级的线程，它可以在单个操作系统线程中运行。在某些情况下，我们需要确保所有的Goroutine都已经停止了，例如在退出程序之前，需要等待后台任务完成。

worldStopped函数中，首先将当前的世界锁定，以防止其他Goroutine对其进行操作。然后检查worldStopped标志是否为真，如果为真，则说明goroutine已经停止，并且在全局等待锁上等待的goroutine要么已经退出，要么正在退出。如果worldStopped标志为假，则将其设置为真，并返回true，表示所有的Goroutine都已经停止。如果mutex锁定失败，则返回false，表示还有Goroutine正在运行。最后释放世界锁，以允许其他Goroutine对其进行操作。

在Go语言的运行时中，锁和条件变量被广泛使用。例如，互斥锁（mutex）是用于保护临界区，条件变量（cond）则是用于线程之间的同步。而在运行时中，要确保正确的使用锁和条件变量，而不会出现死锁或竞态条件等问题，则需要借助worldStopped函数等辅助函数来实现整个系统的可靠性和稳定性。



### worldStarted

lockrank_on.go文件中的worldStarted函数是用于通知运行时系统一个世界的启动，它的作用是在一系列的goroutine开始执行之前对锁排序表进行初始化。锁排序表是用于记录所有加锁操作发生的顺序的数据结构，因此在多个goroutine并发执行的情况下，它可以确保锁的获取与释放是按照正确的顺序发生的。

具体来说，worldStarted函数会首先检查锁排序表是否已经被初始化过，如果没有，则会创建一个新的锁排序表。接着，它会记录当前世界的ID，并将其存储在世界ID的映射表中。然后，它会向当前世界的锁排序表中插入一个虚拟的“前置锁”，以保证所有加锁操作都能够有一个先后顺序。

总之，worldStarted函数提供了一个在多线程环境下正确获得和释放锁所需的基础机制。在Go语言的运行时系统中，锁排序表是一个非常重要的数据结构，它可以确保程序在处理共享资源时所涉及的锁定顺序不会导致死锁或其他线程安全问题。



### checkWorldStopped

checkWorldStopped函数的作用是检查世界是否已经停止。

在Go语言中，有一个称为全局状态的概念，它可以通过调用runtime.LockOSThread和runtime.UnlockOSThread函数来操纵。全局状态表示当前Goroutine是否可以访问系统资源，例如文件、网络等，以及当前Goroutine是否可以进行调度。当锁定当前线程时，该线程仅能够与同一线程相互作用。当解锁线程时，线程又可以随时被调度。

在checkWorldStopped函数中，它检查了全局状态的标志是否已设置为中止状态。如果设置为中止状态，则表示世界已经停止，并且禁止对全局状态进行任何更改。如果尝试进行更改，checkWorldStopped函数将引发panic。

这个函数的主要目的是在程序出现错误的情况下帮助用户快速定位问题，并提供清晰的诊断信息。同时，它也避免了在全局状态未正确设置时对运行时状态的意外修改，从而防止程序出现更严重的错误。



### assertWorldStopped

文件lockrank_on.go是Go语言的运行时包（runtime）中的一部分，其中assertWorldStopped函数的作用是检查当前世界（world）是否已经停止。

在Go语言中，Goroutine是一种轻量级线程，和线程一样，它们可以并发执行。为了管理Goroutine的执行和调度，Go语言提供了一个叫做Scheduler的系统组件，它负责在多个P（Processor）上调度和执行Goroutine。

Scheduler在执行Goroutine时需要使用一些全局状态（如调度队列、Goroutine状态等）来跟踪Goroutine的执行状态和调度状态。在某些情况下，如停止所有Goroutine（Stop The World），暂停Goroutine的执行以进行垃圾回收等，Scheduler需要暂停所有Goroutine的执行，并停止全局状态的修改，这时就需要使用world机制。

在assertWorldStopped函数中，它会检查当前的world是否已经停止，如果没有停止，则会引发panic。该函数主要是用于检查和确定world状态的正确性和一致性，通过这种方式保证了在暂停Goroutine的执行期间可以确保全局状态不被修改，这是实现Stop The World的关键。



### assertWorldStoppedOrLockHeld

在Go语言中，Goroutines是在多个线程之间调度的。为了保证数据的正确性和一致性，在Go的运行时中会使用锁机制来同步不同Goroutines之间对共享数据的访问。

在runtime/lockrank_on.go文件中，assertWorldStoppedOrLockHeld这个函数就是用来检查锁的状态的。该函数的作用是通过检查锁状态来确保当前线程在进行操作时，要么持有锁，要么整个系统都已经停止了。

具体来说，该函数首先会检查当前是否已经持有了排他锁，如果已经持有锁，则函数直接返回，否则，函数会检查整个系统是否已经停止。如果整个系统已经停止了，那么函数也直接返回。而如果锁没有被持有，且整个系统也没有停止，那么函数就会抛出异常，表示当前线程正在非法地访问共享数据。

该函数的作用是确保在对共享数据进行操作时，不会出现数据混乱或竞态条件，从而保证程序的正确性和可靠性。



