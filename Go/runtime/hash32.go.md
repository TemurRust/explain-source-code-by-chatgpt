# File: hash32.go

hash32.go这个文件的作用是实现了一系列的哈希算法，用于在Go语言的运行时系统中计算哈希值。这些哈希算法可以用于数据结构中的键值对存储、字符串哈希和其他一些应用场景中。

这个文件中实现的哈希算法包括：

1. DJBHash：使用了DJB算法，这是一种简单快速的哈希算法。

2. FNVHash1和FNVHash1a：使用了FNV算法，这是一种广泛使用的哈希算法，效率较高，哈希结果足够随机。

3. JenkinsHash：使用了Jenkins算法，这是一种在优化哈希性能和保证哈希结果随机性之间取得平衡的算法。

4. Murmur32Hash：使用了Murmur算法，这是一种性能优秀、哈希结果随机性好的哈希算法。

这些哈希算法的实现主要依赖于一些基本的操作，比如位运算、数值计算、移位等，这些操作都是在Go语言的底层中实现的，并且都是针对不同数据类型的。因此，这个文件中除了哈希算法之外，还包括了一些针对不同数据类型的基本操作实现。

## Functions:

### memhash32Fallback

memhash32Fallback是runtime包中hash32.go文件中的一个函数，用于在key长度小于等于4个字节时计算key的哈希值。

在该函数中，首先将key转换为一个uint32类型的值。如果key长度小于4字节，则使用特殊的转换方式填充key值，以确保key的uint32类型值的高位和低位都被正确设置。

接下来，使用一个magic常数（0x9e3779b9）对该值进行扰动，并进行一定的移位和异或操作。最后，将结果一定程度上随机化，确保哈希结果的分布性。

该函数主要用于处理小键值的哈希，是一种简单且高效的哈希算法。在大多数情况下，该函数不需要进行调用，因为大部分key都比4个字节长，可以直接采用更复杂的哈希算法进行计算。



### memhash64Fallback

memhash64Fallback是runtime库中的一个函数，用于将一个字节数组转换成一个64位的哈希值。它的作用是为Go语言中的map数据结构提供一个散列函数，以便快速地访问和查找其中的数据。

在这个函数中，首先会根据字节数组的长度和指针计算出一个哈希掩码，用于对字节数组进行哈希。接着，使用一个循环和一个累加器来计算哈希值。循环会遍历字节数组中的每一个字节数，将其与累加器进行异或运算并左移一定的位数，然后将其加到累加器中。最后，根据一个称为“乘数”的常量和哈希掩码对累加器进行调整和限制，得到一个最终的64位哈希值。

也就是说，memhash64Fallback函数的作用是生成一个64位的哈希值，以便在查找和存储键值对时能够快速地定位到所需的数据。这个函数在Go语言的map中被广泛使用，可以提高程序的性能和效率。



### memhashFallback

func memhashFallback(p unsafe.Pointer, seed uintptr, s uintptr) uintptr 是一个用于实现散列函数的函数，当不能使用（或不希望使用）硬件支持的快速哈希函数时使用。

在一些硬件体系结构中，处理器有一个指令或指令序列，可以对数据块（字节序列）进行哈希操作。这些哈希函数通常使用专用的哈希硬件来加速散列计算。如果在这些平台上运行Go程序，则会使用这些硬件优化哈希计算。然而，在某些平台上，哈希硬件是不存在的，或者Go编译器没有为它们生成优化的汇编代码来利用硬件。在这种情况下，将会使用memhashFallback函数来实现哈希运算。这个函数采用了一个比较简单和通用的哈希算法，如果硬件支持的哈希函数不可用，就会自动调用此函数。这种情况下，性能会受到一定影响，但是可以保证运行正确。



### mix32

mix32函数的作用是将32位无符号整数进行混淆，增加哈希函数的随机性和分布性。具体来说，mix32函数将输入的32位无符号整数按照一定的方式进行移位、异或等操作，得到混淆后的结果。

该函数使用了一系列的位操作和数学计算，其目的是将输入的32位无符号整数进行混淆，增加哈希函数的随机性和分布性。具体来说，mix32函数将输入的32位无符号整数x进行以下操作：

1. 将输入的x与0xffc5c5ff按位异或。

2. 将异或后的结果进行左移15位。

3. 将输入的x向右旋转17位。

4. 将左移后的结果与右旋后的结果进行异或运算。

5. 将异或后的结果与0xe6546b64按位异或。

最终得到的结果是一个32位无符号整数，具有一定的随机性和分布性。这个结果可以用于哈希表的键的哈希值计算中，以保证哈希表具有更好的性能。



