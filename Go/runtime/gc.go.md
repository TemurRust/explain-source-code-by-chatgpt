# File: gc.go

gc.go是Go语言运行时中垃圾回收模块的实现文件。垃圾回收（Garbage Collection，简称GC）是Go语言的一项重要特性，它可以自动管理内存分配和释放，避免了手动内存管理可能带来的错误和麻烦。

在Go语言中，垃圾回收是通过运行时（runtime）来实现的。在系统运行时，runtime会自动跟踪和管理内存的使用情况，当发现某个内存块没有被任何指针所引用时，便会将其视为垃圾并进行回收。

gc.go实现了Go语言垃圾回收模块的核心执行逻辑，包括：

1. 内存分配：垃圾回收器通过runtime.MSpan结构体来管理堆中的内存，gc.go实现了对MSpan结构体的分配和管理。

2. 标记：在垃圾回收过程中，需要标记哪些内存块是活动的，哪些是垃圾。gc.go实现了标记阶段的算法和逻辑。

3. 清除：当垃圾回收发现某段内存为垃圾时，需要进行清除操作。gc.go实现了垃圾回收器的清除算法和逻辑。

4. 并发：Go语言的垃圾回收是并发进行的，可以在应用程序继续运行的同时进行垃圾回收操作。gc.go实现了并发垃圾回收的算法和逻辑。

总之，gc.go是Go语言垃圾回收机制的核心实现，保证了程序的稳定性和可靠性。它也是Go语言运行时系统中非常重要的一个文件。




---

### Var:

### sink

在Go语言中，GC（垃圾回收）是如何管理内存的一个重要部分。GC会定期启动，并且会遍历程序的内存空间，找到那些已经不再使用的内存块，然后将其释放，并返回给操作系统。

在go/src/runtime/gc.go文件中，`sink`是一个用于避免编译器对程序进行过度优化的临时变量。具体来说，这个变量在内存扫描（或称为“traversal”）的过程中被使用。

在GC进行内存扫描时，它会遍历内存中的每个对象，并且会将每个对象的指针写入`sink`中。因为`sink`被放在了一个函数的参数列表中，所以编译器不能将其优化掉。这样做就可以确保编译器不会删除那些看起来未被使用的对象，防止出现错误地回收内存的情况。

简而言之，`sink`变量是在GC运行时防止编译器对程序进行过度优化的一个占位符变量。它的作用是确保所有的变量都得到了正确的GC处理。



### sink2

在Go语言中，gc.go文件包含了垃圾回收器的实现代码。其中，sink2是一个全局变量，它的作用是用于保持指向一个对象的指针（或间接指针）的引用，从而防止该对象被GC回收。

具体来讲，当垃圾回收器开始运行时，它会扫描所有的堆内存，并将所有引用对象的指针进行标记。在标记完成后，GC会遍历所有堆内存中的对象，对没有被标记的对象进行标记为可回收对象，并且回收它们所占用的空间。

然而，如果在GC过程中某个对象的所有指针都被标记为不可达，那么这个对象就可以被回收。但是，有些情况下，某些指针并没有被标记为不可达，却不可用，例如在编译时被优化掉等情况。如果这种指针被使用，那么程序就可能出现不可预期的错误。为了避免这种情况，Go语言中使用了sink2变量。

当垃圾回收器进行标记时，如果一个指针没有被使用，那么它会被进行消除处理。然而，如果这个指针被sink2引用，那么垃圾回收器就不会将这个指针进行消除，从而确保了对象不被回收。同时，sink2变量的使用可以通过编译器被优化掉，从而不会对程序的性能造成影响。



### memLimitSink

变量memLimitSink是用于限制堆大小的。它的作用是在堆大小接近限制时通知垃圾回收器，以防止堆继续增长。 如果堆大小接近或超过此限制，则垃圾回收器将立即开始工作。

memLimitSink的具体实现是利用了系统资源限制，通过获取系统的资源限制，可以确定进程可用的虚拟内存大小。在每次堆增长或关键事件(如垃圾回收结束后)时，都会检查当前进程是否超出可用内存大小的限制，如果超出，则立即触发垃圾回收。

通常，堆大小受到两个因素的限制：系统资源限制和Go应用程序设置的最大堆大小。memLimitSink变量专门用于处理系统资源限制的情况，而不是设置最大堆大小。 常用的系统资源限制是Linux系统中的ulimit。在默认情况下，Linux系统的ulimit值通常会限制进程的虚拟内存大小，因此使用memLimitSink变量可以在超出系统资源限制之前避免堆大小过大的问题。

总之，memLimitSink变量是用于限制堆大小的重要变量，通过检测进程可用内存大小，可以及时触发垃圾回收，保证应用程序的健康运行。



## Functions:

### init

在go/src/runtime/gc.go中，init函数主要有两个作用：

1. 设置GC相关参数

init函数会在进程启动时被调用，其中会设置一些与GC相关的参数。这些参数包括标记压缩、并发GC等。这些参数会在GC过程中被使用，并影响着GC的性能和效果。通过设置这些参数可以优化GC的效率和内存占用。

2. 创建GC的goroutine

init函数还会创建一个用于GC的goroutine。这个goroutine会在整个进程的生命周期中一直存在，负责执行GC的各个阶段。GC过程是一个相对耗时的过程，将其独立成一个goroutine可以避免对主程序的卡顿和性能影响。此外，通过使用goroutine，GC也可以充分利用多核处理器的优势，进一步提高GC的效率。

总结：

go/src/runtime/gc.go中的init函数主要用于设置GC参数和创建GC goroutine。这个函数对整个进程的内存管理和性能起着至关重要的作用。



### GCSys

GCSys函数是Go语言运行时的垃圾回收器（GC）的一部分，它的作用是获取系统信息。具体来说，它会获取用于内存管理的系统资源，包括堆、栈和其他内存区域的大小和位置。

当GC开始工作时，它首先需要知道当前堆中已分配了多少内存以及内存的排列方式，以便能够有效地执行垃圾回收。在这个函数中，会向操作系统发出请求，获取仍存活的内存块的信息，并将这些信息用于内存管理。

此外，GCSys还会进行一些常规的系统调用，用于告诉操作系统如何释放已分配但不再使用的内存。这些调用包括mmap、munmap和mprotect等系统调用。

总之，GCSys函数是垃圾回收器的重要组成部分，它可以获取与内存管理相关的系统信息，并通过一些系统调用来管理内存。通过这些操作，可以让Go语言的垃圾回收机制更加高效、安全、健壮。



### workthegc

workthegc函数是 Go 语言运行时（runtime）中的一个函数，它的作用是唤醒并执行垃圾收集器（GC）（这也是 work the GC 这个函数名字的含义，“work” 表示 “工作”，“the GC” 表示 “垃圾收集器”）。

具体来说，workthegc 函数会做以下几件事情：

1. 检查当前是否已经有 GC 正在运行，如果是则直接返回，避免重复运行 GC，浪费系统资源。

2. 将标记停止阶段的状态置为 "GC mark termination"，并设置 GOMAXPROCS（最大 P 数量），使得后续的 GC 引导阶段可以顺利进行。

3. 停止所有正在运行的 Go 程序，等待它们进入 GC 标记阶段之后再运行。

4. 调用 gcBgMarkWorker 函数，在后台执行 GC 标记阶段。

5. 等待 gcBgMarkWorker 函数完成并退出。

6. 恢复所有被停止的 Go 程序的运行。

总的来说，workthegc 函数的作用就是调度和执行垃圾收集器的工作，让垃圾回收可以在后台进行，不影响正在运行的 Go 程序的执行，并尽可能地利用多核处理器的性能优势，提高垃圾收集效率。



### GCFairness

在Go语言中，垃圾回收器（GC）是负责管理堆内存的重要组件之一。而GCFairness函数是GC中的一个方法，其主要作用是调整和平衡垃圾回收操作的时间。具体来说，它旨在确保GC可以在不影响程序性能的情况下管理堆内存。

GCFairness函数主要依靠以下两个指标来调整GC操作：

1. 系统负载

程序的负载水平和系统资源消耗情况是影响GC操作的重要因素。当系统负载较轻、资源充足时，GC可以更快地完成其工作。因此，GCFairness函数会根据系统负载情况动态地调整GC的执行速度，以便更好地平衡性能和GC效率。

2. 堆状态

堆状态是另一个影响GC操作的因素。例如，如果堆中存储大量垃圾数据，则GC可能需要更长时间来进行回收操作。 GCFairness函数会监视堆状态，并动态地调整GC的执行顺序和速度，以便更高效地回收垃圾。

在实际应用中，GCFairness函数的主要作用是确保GC操作能够适应各种应用场景和系统负载，以保证应用程序的正确运行和高性能。



### GCFairness2

GCFairness2函数是Go语言运行时中垃圾回收系统的一部分，它的主要作用是为了保证在执行垃圾回收时，对各个goroutine的公平性和正确性进行监控和控制。

具体来说，GCFairness2函数会根据当前系统负载和垃圾回收的需要，计算出需要回收的内存量，并为每个P（Processor）分配一个gcWork枚举类型的任务。然后它会按照一定的策略，为每个处于就绪状态的goroutine分配一个P，并根据goroutine的优先级和运行状态，以及P的运行状态和负载情况，将任务分配给相应的P，最终实现垃圾回收和线程调度的公平性和正确性。

具体来说，GCFairness2函数的主要步骤如下：

1.获取当前系统负载需要回收的内存量；

2.为每个P分配一个gcWork任务；

3.按照一定策略为每个处于就绪状态的goroutine分配一个P；

4.将分配到每个P的任务按照优先级和运行状态进行排序；

5.根据P的运行状态和负载情况，将任务分配给相应的P执行；

6.在整个垃圾回收过程中保证各个P的运行状态和负载情况的均衡，保证垃圾回收和线程调度的公平性和正确性。

总之，GCFairness2函数是Go语言运行时中垃圾回收系统的重要组成部分，它通过监控和控制各个goroutine和P的运行状态和负载情况，保证了垃圾回收和线程调度的公平性和正确性，是Go语言实现高效并发编程的重要保障。



### GCPhys

在Go语言的运行时系统中，GCPhys函数在垃圾回收过程中用于计算堆对象物理地址。具体来说，它可以将任意指向堆上的对象的指针转化为其相对于堆起始地址的偏移量。

GCPhys函数的实现依赖于前面的几个函数，其中包括findObject和findObjectIndex。findObject函数用于查找指定地址处的对象，并返回其堆索引。findObjectIndex函数用于查找对象在堆中的索引。

GCPhys函数首先检查待计算地址是否在堆内，如果不在，则退出计算。否则，它使用findObject函数获得该地址所属的对象，并使用findObjectIndex函数计算该对象在堆中的索引。最终，它将该对象在堆中的偏移量和待计算地址相减得到物理地址。

总的来说，GCPhys函数的作用是提供了一种对堆对象地址进行计算和转换的方法，从而帮助实现垃圾回收。



### DeferLiveness

DeferLiveness这个函数是在垃圾收集器（GC）期间调用的，用于处理defer语句中的对象的存活性（liveness）。

在Go语言中，defer语句提供了一种在函数返回之前执行代码的机制。当函数中存在defer语句时，编译器会将这些defer语句转换为一个defer表，并在函数退出时，按照先进后出的顺序依次执行这些defer语句。

当defer语句中涉及到需要垃圾回收的对象时，就需要考虑这些对象的生命周期。如果在defer语句执行时，这些对象已经被回收了，那么这些defer语句就不会正确执行。

为了解决这个问题，GC在执行垃圾回收时，会调用DeferLiveness函数，该函数会检查defer语句中的对象是否仍然存活（live）。如果这些对象没有被回收，则将它们标记为活着，以确保defer语句能够正确执行。

DeferLiveness函数的具体流程如下：

1. 遍历所有的defer表，对于每个defer表，将defer语句中的对象添加到扫描队列中。
2. 从扫描队列中取出一个对象。
3. 如果该对象已经被标记为活着，直接跳过。
4. 否则，将该对象标记为活着，并将其指向的所有对象添加到扫描队列中。
5. 重复步骤2-4，直到扫描队列为空。

通过DeferLiveness函数，GC能够检查defer语句中的对象的存活性，确保defer语句正确执行，同时也能够优化垃圾回收的效率。



### escape

在Go语言中，当一个变量或一个布置在堆上的数据被引用时，我们称其为“逃逸”（escape）。通常情况下，当变量逃逸到堆上时，它会增加垃圾回收的负担，降低性能。

因此，逃逸分析在编译时进行，可以优化代码，减少堆上分配的对象数量，从而提高性能。escape()函数就是进行逃逸分析的函数。

具体来说，escape()函数会遍历函数的所有语句和表达式，并标记每个变量和数据是否逃逸。如果变量不逃逸，则可以将其分配到栈上，而不是堆上。如果数据不逃逸，则可以在函数返回时释放它，而不是等待垃圾回收器回收。通过减少堆上分配的对象数量，可以减少垃圾回收的开销，从而提高性能。

需要注意的是，escape()函数只是一个辅助函数，它不是Go语言的标准库中的公共函数。它只在编译器实现中使用，用户不应该直接调用这个函数。



### GCZombie

GCZombie函数是Go语言运行时系统中的垃圾回收器函数之一，其主要作用是在标记阶段扫描那些已经处于“无法访问但指针仍然存在”的对象，即僵尸对象，以将其从内存中清除。

在Go语言中，垃圾回收器通过标记-清除算法来回收内存。标记阶段是垃圾回收的第一步，通过扫描指针来标记所有可达对象。在进行标记的过程中，需要处理许多已经成为垃圾的对象，如已经死亡的goroutine、已关闭的channel等，这些被称为“无法访问的对象”。这些对象虽然已成为垃圾，但指向它们的指针仍然存在，因此垃圾回收器无法直接回收它们。

GCZombie函数就是用来处理这些无法访问但指针仍然存在的对象的。它会将这些对象设置为“zombie”状态，即记录在特殊的zombie标记位图上。标记阶段结束后，所有处于zombie状态的对象将被传递给清除阶段来进行清理。

总之，GCZombie函数在Go语言运行时系统中扮演着关键的角色，它的作用是确保所有无法访问但指针仍然存在的垃圾对象都被垃圾回收器标记并清除，从而释放内存资源，保证程序的高效运行。



### GCMemoryLimit

GCMemoryLimit这个函数用来设置和获取当前的垃圾回收内存限制。垃圾回收内存限制指定了垃圾回收器在进行垃圾回收时可以使用的最大内存。当内存使用量达到这个限制时，垃圾回收将开始并尝试回收尽可能多的内存，以使内存使用保持在限制以下。

具体来说，GCMemoryLimit的作用如下：

1. 获取当前的垃圾回收内存限制，以供检查和使用。

2. 设置垃圾回收内存限制。可以通过调用GCMemoryLimit并传递一个新值来设置垃圾回收内存限制。

3. 检查当前系统是否支持动态垃圾回收内存限制。某些系统（如Linux）允许垃圾回收器在进行垃圾回收时自动动态调整内存限制，而另一些系统则不允许这种行为。在这种情况下，GCMemoryLimit将返回false。

在Go语言的垃圾回收机制中，内存限制对于控制应用程序的稳定性和性能非常重要。使用GCMemoryLimit函数可以方便地进行垃圾回收内存限制的管理，以充分利用系统资源并避免应用程序挂起或崩溃。



### GCMemoryLimitNoGCPercent

GCMemoryLimitNoGCPercent是一个用于设置GC堆的最大内存限制的函数。在垃圾回收过程中，当堆的大小超过这个限制时，垃圾收集器将不再执行新的GC操作，而且在此之后，分配内存的操作将被延迟，以帮助减少GC的负担，并提高程序的性能。

该函数的作用是调整GC堆的大小限制，避免造成系统负荷过大的情况，并确保内存使用的合理性和稳定性。其实现原理是通过设置一个阈值，当GC堆的大小超过该阈值时，判断是否需要执行新的GC操作，从而实现自动的GC内存管理。

需要注意的是，虽然该函数可以帮助我们避免过多的内存使用和GC运行，但是设置的值应该合理，以确保系统性能的平衡和最优化。因此，开发人员应该根据实际的应用场景和内存使用情况来合理调整该函数的参数值。



### gcMemoryLimit

gcMemoryLimit函数是用于计算和设置全局垃圾回收器(GC)内存使用限制的函数。

在Go语言中，垃圾回收器对内存进行管理和回收的同时，也会对内存使用进行限制，即通过使用GC内存使用限制来控制应用程序使用内存的最大量。如果内存使用超过限制，垃圾回收器会尝试回收内存，并可能使应用程序暂停，直到内存使用降下来。

gcMemoryLimit函数会根据当前操作系统的内存限制以及用户自定义的参数来计算和设置GC内存使用限制。GC内存使用限制包括三个参数：GOGC、MaxHeap和MemStats。其中，GOGC表示垃圾回收的触发比率，MaxHeap表示堆的最大大小，MemStats表示内存统计数据。

首先，gcMemoryLimit函数会根据MaxHeap参数计算应该使用的最大堆大小，并设置相应的内存限制。其次，它会计算并设置相应的GC触发比率，即GOGC参数。最后，它会更新MemStats参数中的总内存和系统内存使用情况。

总之，gcMemoryLimit函数是Go语言中用于计算和设置GC内存使用限制的重要函数，它可以帮助应用程序在使用内存时，达到合适的性能和效率。



