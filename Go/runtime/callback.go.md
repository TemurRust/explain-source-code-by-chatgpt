# File: callback.go

callback.go文件是Go语言运行时的回调函数实现，其中定义了多个回调函数用于处理不同的事件，包括内存申请、垃圾回收、栈增长、信号处理等。这些函数的具体实现会调用不同层次的函数，完成一些必要的操作。

在Go语言程序运行时，操作系统将分配给程序的内存空间映射到进程地址空间中，Go运行时会管理这些内存空间的分配和释放，并通过cb函方式来处理一些特定的场景。例如，当程序需要为一个新的对象分配内存时，Go运行时会调用`cbmmap`函数申请一块内存，当程序需要释放一个对象的内存时，Go运行时会调用`cbbeforefree`函数来释放其占用的内存空间。

回调函数的实现通过使用go:linkname方式来实现，该方式使得Go代码能够链接到一个外部的c函数中。除此之外，callback.go文件中还定义了一些与操作系统相关的函数和数据结构，例如`sigctxt`结构体，用于存储信号处理函数的上下文信息；`memstats`结构体，用于存储内存使用统计信息等。

总的来说，callback.go文件是Go语言运行时中非常重要的一个文件，其中定义的回调函数可以让Go程序与底层的操作系统进行交互，完成一些必要的操作。




---

### Var:

### cnt

在Go语言中，callback.go文件是实现C函数调用Go函数的功能。当Go语言程序需要和C语言进行交互时，我们需要使用CGO(C语言调用Go语言)技术。callback.go文件就提供了一种从C代码回调Go函数的方式。

在callback.go中，cnt变量是用来记录已经分配给C函数的callbackID的数量。每当我们创建新的callback函数时，我们会为其生成一个callbackID。而callbackID是一个唯一的值，它是通过累加cnt的值实现的。

具体来说，当我们创建一个新的callback函数时，callback.go文件会调用runtime_setFinalizer函数将该函数的地址作为finalizer，然后把该函数的callbackID赋值为cnt并将cnt加1。callbackID方便我们从C代码中回调相应的Go函数。

值得注意的是，cnt变量只有在callback_test.go文件中才会被测试代码引用，它不会在其他文件中使用。



## Functions:

### init

在Go语言中，init函数是一个特殊的函数，它会在程序执行的时候自动调用，而不需要显式地调用它。在callback.go文件中的init函数也不例外，它的作用是在Go运行时初始化回调机制。

回调机制是一种常见的编程模式，它允许代码在程序执行过程中调用另一个函数，以便实现某种功能。在Go语言中，回调机制常用于协程和事件处理等场景中。

在callback.go文件中的init函数主要有以下作用：

1. 注册运行时回调函数

Go运行时提供了一些回调函数，这些函数会在程序运行时自动被调用。init函数通过调用runtime包中的相关函数，将这些回调函数注册到Go运行时中，以便在需要时自动调用。

2. 初始化全局变量

在回调机制中，很多状态信息都需要保存到全局变量中。在init函数中，可以初始化这些全局变量，以便在回调函数中使用。

3. 预处理一些数据

在实际应用中，很多数据需要在程序运行过程中多次使用。在init函数中，可以预处理这些数据，以便在使用时提高程序性能。

最后，需要注意的是，init函数并不是程序的入口函数，也不会被外部直接调用。它的作用是在程序启动时为程序做一些初始化工作，以便程序能够正常运行。



### go_callback

callback.go文件中的go_callback函数是一个关键函数，用于将Go语言的函数转换为C语言的函数指针，以便在C语言代码中使用。

具体来说，go_callback函数的作用是：

1. 获取该函数在Go语言运行时的函数对象（对应runtime.Func对象）。

2. 生成该函数的C语言 wrapper函数，该wrapper函数的参数和返回值与Go语言函数相同。

3. 将生成的C语言 wrapper函数转换为函数指针，以便在C语言中调用。

这样一来，就可以在C语言代码中使用Go语言的函数了，方便Go语言开发者与C语言开发者交互和合作。

对于需要在Go语言和C语言之间交互的项目，使用go_callback函数可以大大简化开发难度和提高效率。



### grow

在Go语言中，程序可以调用外部的C函数进行一些特定的操作。为了与C函数交互，Go语言中提供了回调机制，可以将Go语言中的函数传递给C函数，并再适当的时候被C函数调用。

在 Go语言的 runtime 包中，callback.go 文件定义了一些用于支持回调的函数。其中的 grow 函数可以用于动态增加任意类型的切片的容量。在形式上，grow 函数的签名如下：

```
func grow(slice unsafe.Pointer, newcap int) (unsafe.Pointer, int)
```

它的第一个参数是待增加容量的切片；第二个参数是增加后的切片容量。函数的返回值是指针和容量的元组，并且可以作为其它函数的参数使用。

grow 函数内部会先获取切片的元素类型和指针值，然后调用对应的 growSlice 函数进行扩容。growSlice 内部会检查要求扩容的容量是否合法和是否需要重新分配内存。如果不需要重新分配，growSlice 函数会直接返回原有切片的指针和容量。

如果需要重新分配内存，则 growSlice 函数会调用 eageralloc 函数来分配新的内存。然后，将原有切片的元素复制到新内存中，并返回新内存中的切片指针和容量。

除了在回调机制中使用外，grow 函数也可以在 Go 语言的标准库中找到它的身影。在 reflect 包的 slice.go 文件中，reflect.grow 函数正是通过调用 grow 动态扩容切片。

总的来说，grow 函数是 Go 语言 callback 机制中必不可少的一环，它能帮助我们动态地扩容任意类型的切片，而不会造成内存泄漏或其它异常。



### grow1

grow1函数是用于在内存分配堆栈上增加一个新的堆栈。当goroutine需要更多的可用堆栈空间时，该函数被调用。

具体来说，grow1函数将申请一个新的堆栈，并将旧的堆栈转移到新的堆栈中，以便在向上扩展堆栈时，可以使用空闲的底层内存。同时，它也会更新goroutine的指针，以引用新的堆栈，以便goroutine可以继续运行。当新堆栈用完时，它会递归调用自身以增加堆栈空间。

该函数还会检查当前goroutine的堆栈是否达到最大限制，并在达到最大限制时引发异常，因为如果堆栈超过最大限制，则可能导致程序崩溃。



### CgoCallbackGC

CgoCallbackGC这个func的作用是在CGO回调函数中触发垃圾回收器，释放不再使用的内存。在Go程序中，垃圾回收器会自动回收不再使用的内存。但是在CGO调用中，由于调用的是外部C语言函数，Go语言的垃圾回收器无法感知这部分内存的使用情况，因此需要手动触发垃圾回收。

该函数的实现主要是通过向runtime的gcWork队列中添加一个gcWork对象，该对象的work字段存储的是一个函数类型，作为回调函数中需要执行的垃圾回收代码。在调用完外部C函数之后将该对象放入队列中即可。这样在下一次垃圾回收时会自动执行该函数，释放相关的内存，从而避免内存泄漏问题。

需要注意的是，在CGO回调中手动触发垃圾回收代价较大，尽量避免过于频繁的调用该函数。



