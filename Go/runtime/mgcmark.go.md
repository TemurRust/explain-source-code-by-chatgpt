# File: mgcmark.go

mgcmark.go文件是Go语言运行时系统中的一部分，它主要负责标记清除垃圾回收（GC）的标记阶段（Mark Phase）。

在GC的标记阶段中，Go运行时系统需要遍历所有的堆内存对象，并对可达对象进行标记，标记完后清除未被标记的对象。而在mgcmark.go文件中，有一系列的函数和数据结构，用于实现在标记阶段中对堆对象的遍历和标记。

具体而言，mgcmark.go文件中实现了以下几个关键函数：

- markrootroots: 标记根对象（如全局变量、调用栈上的堆地址等）。
- markroot: 标记堆上的可达对象。
- scanblock: 遍历block中的对象，并标记可达对象。
- flushedWork: 并发标记时，用于收集完成的标记任务。
- gcDrain: 等待所有的标记任务完成。

在这些函数的协同作用下，Go运行时系统可以完成一个快速、高效、并发的标记阶段。

总之，mgcmark.go是Go语言运行时系统中实现标记阶段的关键代码，它提供了一系列的函数和数据结构，帮助Go运行时系统能够高效而准确地进行堆内存对象的遍历和标记，在垃圾回收过程中发挥着重要的作用。




---

### Var:

### oneptrmask

变量oneptrmask定义在runtime/mgcmark.go文件中，用于GC标记阶段的对象追踪。在Go语言的垃圾回收算法中，为了区分对象的类型，每个对象在其头部都有一个标记信息，包含有关对象的元数据信息、GC相关信息等。

其中，oneptrmask的作用是做一个快速的指针检查，在GC的标记过程中使用。通过检查对象头部标记信息中是否存在oneptrmask的值，就可以确定对象是否包含指针类型的成员变量。如果对象中存在指针类型的成员变量，则该对象将被标记为可达对象，否则将被作为垃圾对象回收。

oneptrmask的定义如下：

var oneptrmask = [...]uint8{
    /*   0 */ 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
    /*   8 */ 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    /*  16 */ 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    /*  24 */ 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    /*  32 */ 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    /*  40 */ 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    /*  48 */ 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    /*  56 */ 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    /*  64 */ 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    /*  72 */ 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
    /*  80 */ 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    /*  88 */ 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    /*  96 */ 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
    /* 104 */ 0x06, 0x07, 0x07, 0x08, 0x07, 0x08, 0x08, 0x09,
    /* 112 */ 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    /* 120 */ 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
    /* 128 */ 0x06, 0x07, 0x07, 0x08, 0x07, 0x08, 0x08, 0x09,
    /* 136 */ 0x07, 0x08, 0x08, 0x09, 0x08, 0x09, 0x09, 0x0a,
    /* 144 */ 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    /* 152 */ 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
    /* 160 */ 0x06, 0x07, 0x07, 0x08, 0x07, 0x08, 0x08, 0x09,
    /* 168 */ 0x07, 0x08, 0x08, 0x09, 0x08, 0x09, 0x09, 0x0a,
    /* 176 */ 0x08, 0x09, 0x09, 0x0a, 0x09, 0x0a, 0x0a, 0x0b,
    /* 184 */ 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
    /* 192 */ 0x06, 0x07, 0x07, 0x08, 0x07, 0x08, 0x08, 0x09,
    /* 200 */ 0x07, 0x08, 0x08, 0x09, 0x08, 0x09, 0x09, 0x0a,
    /* 208 */ 0x08, 0x09, 0x09, 0x0a, 0x09, 0x0a, 0x0a, 0x0b,
    /* 216 */ 0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x0b, 0x0b, 0x0c,
    /* 224 */ 0x06, 0x07, 0x07, 0x08, 0x07, 0x08, 0x08, 0x09,
    /* 232 */ 0x07, 0x08, 0x08, 0x09, 0x08, 0x09, 0x09, 0x0a,
    /* 240 */ 0x08, 0x09, 0x09, 0x0a, 0x09, 0x0a, 0x0a, 0x0b,
    /* 248 */ 0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x0b, 0x0b, 0x0c,
}

变量的定义是一个长度为256的字节数组，其中每个元素表示其下标对应的值拥有的指针数量，在标记时需要检查每个对象里的指针类型字段的个数，oneptrmask用来存储数量应该为1的标记字节数，如下：

1byte: 0x01 (0000 0001) // 对象中仅含有 1 个指针类型变量
2byte: 0x02 (0000 0010) // 对象中仅含有 2 个指针类型变量
3byte: 0x02 (0000 0010) // 对象中包含 2 个指针类型变量中的 1 个
4byte: 0x03 (0000 0011) // 对象中仅含有 3 个指针类型变量
5byte: 0x02 (0000 0010) // 对象中包含 3 个指针类型变量中的 1 个
6byte: 0x03 (0000 0011) // 对象中包含 3 个指针类型变量中的 2 个
7byte: 0x03 (0000 0011) // 对象中包含 3 个指针类型变量中的 2 个
8byte: 0x04 (0000 0100) // 对象中仅含有 4 个指针类型变量

在GC标记阶段，当扫描到标记对象的头部时，就可以根据对象头部中的信息（如下所示）使用变量oneptrmask进行快速指针检查。

type _type struct {
    size       uintptr
    ptrdata    uintptr
    ...
}

其中，size字段为对象（实例）的大小，ptrdata字段为对象中指针类型（指向其他对象的指针）的数量。

因此，oneptrmask变量在GC标记过程中起到了优化指针检查的作用，可以快速判断对象中是否包含指针类型的成员变量。






---

### Structs:

### gcDrainFlags

gcDrainFlags是内存回收机制中的标志位，它的作用是标记需要进行垃圾回收的Go对象。这个结构体定义了以下标记：

- gcDrainFlagNone：标志位为0，表示该对象不需要进行垃圾回收。
- gcDrainFlagVisited：标志位为1，表示该对象已经被遍历过。
- gcDrainFlagFinalized：标志位为2，表示该对象已经完成了垃圾回收。

在gcDrainFlags结构体中，以上三种标志位是通过二进制操作进行组合的，因此可以同时标记多个标志位。比如，当一个对象已经被遍历过并且已完成了垃圾回收，它的标志位就可以设置为3（二进制表示为11）。

gcDrainFlags结构体的具体使用方法在gcDrain函数中会有体现。该函数会遍历所有已经分配的堆对象，并标记需要进行垃圾回收的对象，具体操作包括：

- 对于每个Span（堆内存块），将其元数据中的gcMarkBits标志位重置为0，防止之前的标记影响垃圾回收结果。
- 遍历每个对象，将gcDrainFlags结构体中的标志位进行组合，然后与当前的gcMarkBits进行或操作，实际上就是将标志位打上gcMarkBits上相应的标记位，表示该对象需要进行垃圾回收。
- 如果对象是指针类型，那么需要进一步遍历该对象指向的内存空间，并重复上述步骤。

总之，gcDrainFlags结构体是在Go内存回收机制中发挥非常重要作用的标志位，通过标记需要进行垃圾回收的Go对象，可以保证内存分配的效率和程序的运行效率。



## Functions:

### gcMarkRootPrepare

gcMarkRootPrepare函数的作用是准备gc根扫描的任务，并将它们添加到gcw工作池中等待处理。

具体来说，gcMarkRootPrepare函数执行以下操作：

1. 初始化gc状态
在函数开始时，它会初始化gc的一些状态，如全局gcw（gc work 或 gc工作）指针、全局gclinkedlist指针等。

2. 移除快照
因为gc实际扫描的是活跃的对象，所以需要将快照对象从根中移除。快照是指在前一次gc中被扫描但在本次gc中却未被扫描的对象。

3. 准备gc任务
gcMarkRootPrepare函数将gc根扫描的任务准备好，包括全局对象、gc根任务、任务g以及当前线程私有的gc根任务。

4. 将任务添加到工作池中
一旦准备好gc扫描的任务，gcMarkRootPrepare函数就会将它们添加到gcw工作池中。如果gcw工作池已满，则会等待直到有空闲工人可用。

总之，gcMarkRootPrepare函数的作用是准备并添加gc根扫描任务到gc工作池中，以便在后续的垃圾回收中对它们进行扫描处理。



### gcMarkRootCheck

gcMarkRootCheck函数是垃圾回收器中的一个关键函数，主要用于标记可达对象。具体来说，该函数用于检查堆栈中的所有根，确定哪些对象当前是可以访问的，并将其标记为可达对象，不可访问的则被标记为可回收对象。

在Go语言中，根是指全局变量、静态变量以及当前进程的堆栈中的数据。堆栈中的根可能指向堆上的对象，也可能指向根本不存在于堆上的对象，如数字和字符串。

gcMarkRootCheck函数通过遍历堆栈中的所有根，根据GC标记规则判断哪些已分配的对象是可以访问的，并将其标记为可达对象，防止它们被垃圾回收期误删。同时，该函数还会检查roots.finalizers链表中的对象，标记它们为不可回收对象，这些对象在后续垃圾回收过程中被排除在垃圾收集范围之外，在程序结束时会被GC清理。

除了检查根对象和roots.finalizers之外，gcMarkRootCheck函数还会递归检查已标记为可达对象的对象，以确定它们的引用对象是否也是可达对象，从而构建可达对象图。

最终，gcMarkRootCheck函数会返回标记为可达对象的数量，这些对象在后续的垃圾回收过程中将被保留。它是垃圾回收器中非常重要的一部分，保证垃圾回收的正确性和效率。



### markroot

markroot函数是Go语言运行时中用来标记root对象的函数。在垃圾回收（garbage collection）的过程中，它被用来遍历整个对象图（object graph），以找到被引用的对象，并将它们标记为“活动的”（live）。

在Go语言中，可以有多个root对象，即不属于任何对象的全局变量、栈或堆上的对象。markroot函数被用来标记这些root对象，并将它们作为垃圾回收的起点。

markroot函数通过遍历可达的对象，找到它们的子对象，并将它们加入到垃圾回收的工作队列中。在后续的步骤中，垃圾回收器会遍历这个工作队列，递归地遍历对象图，并标记那些可以被清理的对象。

总之，markroot函数是Go语言垃圾回收过程中重要的一环，用来找到root对象并标记它们，以便接下来的垃圾回收工作可以正常进行。



### markrootBlock

markrootBlock是Go语言的垃圾回收器（Garbage Collector）实现中的一个函数，它的作用是标记所有的根对象并将它们添加到待扫描队列中。

具体来说，Go语言的垃圾回收器是基于三色标记法（Tri-Color Marking）实现的，而markrootBlock函数就是其中一部分的实现。在这个函数中，会遍历系统中所有的Goroutine，并通过对堆栈的扫描，找到所有的根对象，然后逐个进行标记。

在进行标记时，会使用一个待扫描队列（work queue）来存储所有未被标记的对象，markrootBlock函数就是将标记过的根对象放入这个队列中，以待后续进一步扫描。

值得注意的是，markrootBlock函数并不会直接执行标记操作，而是会调用其他函数进行具体的标记，比如markrootBlockScan、markrootBlockConservative等。

总之，markrootBlock函数是垃圾回收器的核心部分之一，它的作用是找到所有的根对象并将它们添加到待扫描队列中，以进行后续的标记和回收工作。



### markrootFreeGStacks

func markrootFreeGStacks() uintptr 是Goroutine栈的标记阶段函数。这个函数的作用是遍历所有闲置（空闲）的goroutine栈，将其中的对象标记为存活对象，以确保在垃圾回收时不会被释放。 

在Go语言的运行时系统中，当一个goroutine退出时，它的栈会被隐藏到一个空闲栈列表中以供之后的使用。这些栈可能包含指向堆上的对象，这些对象应该在垃圾回收时保留，否则就会被不必要地释放。

markrootFreeGStacks将首先遍历所有空闲栈，从中提取goroutine栈的G对象。然后，它将遍历G对象的栈，按照标记流程标记其中的所有对象。这样，即使在垃圾回收期间，这些闲置的栈上的对象也不会被释放。

由于在这个阶段已经完成了根对象的标记，markrootFreeGStacks只需要标记那些在众多goroutine栈中隐藏的对象即可，这可以节省时间和内存。标记完这些隐藏对象之后，接下来的工作就是清理操作。所以，这个函数是保证在GC期间，闲置的goroutine栈不会影响垃圾回收器对内存的清理和回收。



### markrootSpans

markrootSpans函数是Go语言运行时系统中gcmark阶段的一部分，用于标记与堆内存中分配对象相关的根对象，并将这些根对象放到一个标记队列中。具体作用如下：

1. 遍历当前heap中的所有mspan，找出其中的所有P，并遍历每个P中的所有根对象。根对象包括G、goroutine的stack、dbg和当前P的m等。

2. 对于每个根对象，调用markroot函数进行标记，如果标记成功，将其添加到标记队列中。

3. 标记队列中的对象会在后续的标记工作中被进一步处理，标记其引用的对象。

4. 上述过程会被多次执行，直到标记队列中没有任何对象。

markrootSpans函数的作用是扫描所有span的对象，并且标记所有与堆内存中分配对象相关的根对象，这些根对象被标记后就可以在后续的工作中被进一步处理，以确保系统中不会遗漏任何对象。



### gcAssistAlloc

gcAssistAlloc是runtime中的一个函数，用于在并发垃圾回收（Concurrent Garbage Collection）过程中协助（Assist）内存分配（Allocation）的工作，它的作用是帮助垃圾回收器完成的工作，减少内存碎片，保证程序运行的正常。

具体来说，gcAssistAlloc会在堆（Heap）中分配一定大小的内存块，并返回分配的地址；如果此时正在进行垃圾回收，那么gcAssistAlloc就会为其协助完成部分工作，比如进行扫描和标记（Scanning and Marking）操作，以便更快、更准确地确定哪些内存是可以被回收的。当然，在此过程中，gcAssistAlloc还会根据具体的情况调整内存占用情况，尽可能减少内存碎片的产生，最终提高程序的整体性能和稳定性。

总之，gcAssistAlloc是实现Concurrent Garbage Collection功能的重要组成部分之一，它的作用在于协助垃圾回收器完成内存分配和内存管理等工作，从而提高程序的性能和稳定性，减少内存碎片，保护系统运行的安全和可靠性。



### gcAssistAlloc1

gcAssistAlloc1是Go语言中的垃圾回收（GC，Garbage Collection）机制中的一个函数，其作用是在内存分配时辅助垃圾回收，防止内存过度占用。

当使用Go语言进行内存分配时，如果当前的内存不够用，系统就会发起垃圾回收，释放未被使用的内存。这个过程中，gcAssistAlloc1就会被调用，它会帮助垃圾回收器标记被使用的内存，以便垃圾回收器可以释放未被使用的内存。

gcAssistAlloc1的实现中，首先会通过CAS（Compare-And-Swap）操作来尝试获取GC的标记位。如果该标记位为1，则说明当前正在进行垃圾回收，gcAssistAlloc1会等待垃圾回收完成后再继续执行；如果标记位为0，它会将标记位设置为1，表示开始进行垃圾回收，并利用标记位通知其他的Goroutine暂时停止内存分配。然后，gcAssistAlloc1就会开始进行内存分配，并在分配完成后清除所有被标记的内存，以便垃圾回收器来清理这些内存。最后，gcAssistAlloc1会重置标记位，以便下次使用。

总之，gcAssistAlloc1可以有效地防止内存过度占用，提高Go程序的性能和稳定性。



### gcWakeAllAssists

gcWakeAllAssists是在Go语言的垃圾回收（GC）过程中唤醒所有可以辅助GC的Goroutine的函数。它的作用是确保在进行GC期间能够最大限度地利用CPU资源，从而加速垃圾回收的速度。

在垃圾回收期间，GC主线程负责扫描堆并标记可以被回收的对象，这是一个非常耗费CPU资源的操作。为了减轻主线程的负担，Go语言的runtime系统会让其他Goroutine来协助执行这个任务。这些Goroutine会在gcBgMarkWorker函数中被创建并加入到一个专门的Goroutine池中，等待主线程唤醒。

gcWakeAllAssists的作用就是唤醒这个池中的所有Goroutine，让它们立即开始协助GC主线程进行垃圾回收操作。通过这种方式，可以使系统在GC期间充分利用所有可用的CPU资源，从而提高GC的速度和效率。

总之，gcWakeAllAssists是Go语言运行时系统中的一个重要函数，它能够加速垃圾回收的过程并更好地利用系统资源。



### gcParkAssist

gcParkAssist函数是Go语言运行时系统中的垃圾回收器组件，用于在执行gcParkStart和gcDrain时处理goroutine的暂停和重启操作。这些操作是为了确保在GC运行时不会干扰程序的正常执行，并尽可能地利用多个CPU来加速垃圾回收操作。

具体来说，gcParkAssist函数的作用包括：

1. 协助执行gcParkStart和gcDrain操作的协程进行“休眠”和“唤醒”操作。当需要暂停协程时，gcParkAssist会阻止该协程继续执行，将其挂起等待垃圾回收完成后再恢复运行；当处理完成后，gcParkAssist会将该协程从挂起状态恢复，继续执行。

2. 在进行休眠和唤醒操作时，gcParkAssist会使用一些机制来确保程序的正确性。例如，当某个协程被挂起时，gcParkAssist会记录它的状态，包括协程是否在执行系统调用、是否在等待信号等，以确保它在后续恢复时能够正确继续执行。

3. 和其他垃圾收集器组件（如gcSweep、gcMark）一样，gcParkAssist也需要和其他操作共同协调，以确保整个垃圾回收过程能够高效地进行。例如，在执行gcParkAssist操作时，gcMark工作线程也需要暂停并等待所有协程完成休眠和唤醒操作后才能继续执行。

总的来说，gcParkAssist函数是Go语言运行时的重要组成部分，它通过处理协程的暂停和恢复，确保垃圾回收过程中程序的正常执行。



### gcFlushBgCredit

gcFlushBgCredit这个函数是在Go语言的垃圾回收机制中起到调节机制的作用。

在Go语言中，垃圾回收器会在程序运行时自动地回收不再使用的内存，以避免内存泄漏和内存耗尽的情况。GC机制分为两个阶段，即标记阶段和清除阶段。在标记阶段，GC会遍历对象图并标记可达的对象，以便在清除阶段中回收不再使用的内存。

gcFlushBgCredit函数中的gcCreditFlushed变量是用来记录GC运行期间的credit消耗，如果credit消耗过多，就会影响程序的性能。因此，gcFlushBgCredit函数就是在标记阶段之后，清除credit计数器中的credit，并在后台执行credit任务，以避免credit消耗过多的风险。

具体来说，gcFlushBgCredit函数会检查credit计数器的值，如果credit计数器的值超过了sysIdleTime，就会调用gcBgMarkWorker这个函数执行后台的credit任务。这样可以有效地平衡GC计数器的credit消耗，避免在程序运行期间出现性能问题。

总之，gcFlushBgCredit函数的作用是保证GC计数器的credit消耗不会影响程序的性能，从而确保程序的稳定性和可靠性。



### scanstack

在 Go 中，垃圾回收器（Garbage Collector）是一个核心的组成部分，它可以识别和回收不再使用的内存，以避免内存泄漏和占用过多的系统资源。在 mgcmark.go 这个文件中，scanstack 函数是垃圾回收器的一个重要组成部分，它的作用是扫描一个 Goroutine 的栈（stack）以查找指向堆（heap）内存的指针。

具体地说，scanstack 函数会遍历一个 Goroutine 的栈内存空间，找到其中指向堆内存的指针，并将这些指针标记为可达对象。这个操作是为了确保只有在某个指针仍然被根对象（root）引用时，堆内存才不会被回收。scanstack 这个函数是垃圾回收算法中非常重要的一步，因为它可以协助垃圾回收器有效地识别不再需要的内存，从而提高程序的性能和稳定性。

scanstack 函数的主要工作流程如下：

1. 遍历 Goroutine 的栈空间，找到所有指向堆内存的指针。

2. 将这些指针标记为可达对象，以确保它们不会被回收。

3. 对于未被标记的对象，将其标记为垃圾对象并在一定时间内进行回收。

总之，scanstack 函数是 Go 中垃圾回收器中非常重要的一部分，它可以帮助程序有效地识别和回收不再需要的内存，从而提高系统的性能和稳定性。



### scanframeworker

scanFrameworker函数是在标记阶段进行扫描框架的函数。扫描框架是指为某个函数准备的数据结构，用于存储所有调用该函数时的堆栈信息。在gc标记阶段，需要保证框架中所有指针指向的对象都被标记为活动对象。

该函数的作用是扫描所有的框架，并将其中的指针标记为活动对象。具体来说，它会遍历当前 goroutine 的堆栈信息，并且将其中作为指针的值（或在指针到达时保存的栈帧指针）进行标记。这确保了只要任何一个 goroutine 在执行时使用了该指针，它就会被保证在垃圾收集时不会被回收。

该函数还实现了一个框架的缓存机制，以提高性能，避免在每个框架分配和释放内存。它通过检查框架用于存储堆栈指针的字段是否为零来判断该框架是否可用于缓存，如果可用，则将其添加到框架缓存中。

在gc标记阶段，scanFrameworker函数是非常重要的一步，它确保了所有指针都被正确标记，并且尽可能提高了性能。



### gcDrain

"gcDrain"函数是在垃圾回收过程中进行深度遍历标记的函数。

在Go语言的垃圾回收中，标记阶段是非常重要的一步。在标记阶段中，需要遍历所有已分配对象，标记出所有存活的对象，从而准确地进行垃圾回收。需要注意的是，Go语言的垃圾回收采用的是三色标记法。

"gcDrain"函数的作用就是在标记阶段中进行深度遍历标记。该函数首先检查待处理的对象，如果该对象已标记，则跳过；否则，将该对象标记为已标记，然后处理其子对象。在处理子对象时，如果子对象尚未标记，则将其从待处理队列中取出，标记为已标记，并将其加入待处理队列。该函数一直重复这个过程，直到所有对象都被标记或待处理队列为空。

在"gcDrain"函数中，有一个非常重要的数据结构——workbuf。workbuf是一个goroutine私有的缓冲区，用于存储垃圾回收器待处理的对象。当一个goroutine需要进行垃圾回收时，它将自己的workbuf加入待处理队列。"gcDrain"函数从待处理队列中取出workbuf，然后对其中的对象进行标记。

总之，"gcDrain"函数在Go语言的垃圾回收过程中起着至关重要的作用，它负责处理待处理队列中的对象，对这些对象进行深度遍历标记，从而准确地识别出所有存活的对象。



### gcDrainN

gcDrainN是一个函数，它的作用是在GC标记阶段，将活跃对象的指针从某个P的gcWork中取出，放入gcDrain字段中，并标记已经处理过。

在Go的GC中，程序的内存是由多个P（Processor）共享，而gcDrainN函数的作用是在多个P之间协调分配P的任务，以获取更好的性能。

具体来说，当某个P的gcWork列表中包含活跃的对象时，该P会将这些对象的指针复制到gcDrain列表中，并将它们标记为已处理，以便其他P能够继续处理它们。当所有的P都从gcWork列表中取出对象后，gcDrain列表中剩下的对象就是垃圾了。

这种分配任务的方式可以产生两个效果：

1. 降低了每个P需要遍历的对象数，从而减少了每个P的实际工作量，提高了GC的整体效率。

2. 在分配任务时，优先考虑有更多空闲空间的P，这可以使程序更好地利用空间，从而减少GC的次数。



### scanblock

在Go语言中，当垃圾回收器需要扫描堆中的对象时，会调用scanblock函数。其作用是扫描一块内存中的所有指针，并将指针指向的对象标记为可达的对象。具体来说，scanblock函数会遍历内存块中的每个指针，将每个指针指向的对象标记为可达的，并将该对象添加到"gray list"中。

在实现上，scanblock函数首先会检查内存块的大小，如果小于256字节，则直接顺序扫描内存块中的每个指针。如果内存块大小大于256字节，则使用一种分步扫描的算法。具体来说，scanblock函数会将内存块按一定的大小分为多个块，并逐个扫描每个块内的指针。

需要注意的是，scanblock函数并不会递归地扫描指针指向的对象。该工作将由标记遍历器(mark worker)在扫描的过程中完成。scanblock函数仅完成扫描指针和将对象标记为可达的工作。这种设计使得垃圾回收器更加高效和灵活。



### scanobject

func scanobject(p unsafe.Pointer, gcw *gcWork, morebuf *workbuf) {
    if writeBarrier.needed {
        wbuf := (*mspan)(gcw.spans[pageIndexOf(p)]).wbuf
        if !wbuf.tryMerge(morebuf) {
            wbuf.push(p)
            gcw.bytesMarked += uint64(_PageSize)
        }
        return
    }
    // Stop if we've already scanned this object.
    if obj := heapBitsForObject(p); !setMarkedNonAtomic(obj) {
        return
    }

    // ok, we have not scanned this object yet.  Let's mark it and scan its references.
    // Mark the object.
    greyobject(p, gcw, morebuf)
}

scanobject函数的作用是将一个对象标记为已被扫描，避免重复扫描，然后递归扫描该对象的引用对象。这是gc的核心之一，它扫描堆上的对象并确定哪些对象是活动的，以及哪些对象可以释放。

它首先检查是否需要写屏障，如果需要，将对象添加到微缓冲区中以进行写入栅栏。如果不需要写屏障，则通过heapBitsForObject函数检查对象是否已被扫描。如果对象已扫描过，则立即返回，否则将其标记为已扫描。接着利用greyobject函数进一步扫描该对象的引用，将它们添加到扫描队列，以便在下一次扫描时进一步处理。

整个GC过程是以深度优先的方式遍历的，即从一个对象引用的第一个对象开始，依次遍历其引用到的下一个对象，直到所有对象都被遍历过。然后再根据标记的状态来决定哪些对象需要回收。

总之，scanobject函数是gc工作的核心之一，它标记并扫描堆上的对象，以识别可回收的对象，是Go运行时支持垃圾回收的重要组成部分。



### scanConservative

在Go语言的垃圾回收机制中，当进行GC（Garbage Collection）标记阶段时，需要扫描堆上的对象，标记那些被活跃引用的对象。而scanConservative函数正是扫描堆上的对象并标记活跃对象的过程。

scanConservative使用了一种保守扫描技术，通过检查指针可能被存储在栈或全局变量中的地址范围，来判断该地址范围中是否存在指向堆上对象的指针。如果存在指向堆上对象的指针，则扫描该指针所指向的对象，并标记其为活跃对象。

为了使该过程更加准确，scanConservative还会检查一些特定类型的指针，如函数指针、指向结构体字段的指针等，以确保不会漏掉任何指向堆上对象的指针。

总之，scanConservative函数是Go语言垃圾回收标记阶段中非常重要的一环，确保能够准确地标记那些活跃的对象。



### shade

shade函数是Go语言标准库runtime包中用于垃圾收集的函数之一。它的作用是将对象标记为黑色，并在必要时继续递归标记其引用的对象。具体来说，shade函数实现了灰度扫描算法的第二个阶段——黑色标记。

shade函数的主要参数是hbits、queue和pq。其中，hbits是一个位图，用于记录对象是否已经标记过；queue是对象指针的队列，用于在递归过程中存储需要进一步标记的对象；pq是一个优先队列，用于按照地址顺序处理队列中的对象。

shade函数会从队列中取出一个对象指针，并检查其是否已经标记过。如果没有标记过，则将其标记为黑色，并递归遍历对象引用的其他对象。在遍历过程中，对于每个引用的对象，也要将其压入队列中等待后续处理。

由于shade函数使用了队列和优先队列来管理需要处理的对象，因此它可以保证垃圾收集器的标记过程是完整的、无遗漏的。在标记过程结束之后，所有未标记的对象都可以被视为垃圾对象并被回收。

总之，shade函数是Go语言中垃圾收集器的重要组成部分，它的作用是在垃圾收集过程中标记对象，并确保整个过程的准确性和完整性。



### greyobject

greyobject函数的作用是将一个对象标记为灰色，表示该对象被访问过但还未完成遍历。

在Go语言中，垃圾回收器采用的是三色标记算法（Tri-color Marking），将对象分为三种颜色：白色、黑色和灰色。黑色表示该对象已经被遍历过，对象的所有引用都已被遍历；白色表示该对象未被访问过，或者已经被访问但是未完成遍历；灰色表示该对象已经被访问过，但是还有些引用未被遍历。

greyobject函数的作用就是把一个对象标记为灰色，在垃圾回收器的标记阶段，遍历所有的对象，以确保所有指向黑色对象的引用都被正确的处理，避免出现内存泄露的情况。

具体实现上，greyobject函数会将一个对象（Object）添加到“待处理灰色对象队列（greyobject）”中，标记为灰色，并且会递归遍历该对象，将其所有引用对象标记为灰色。等到所有的灰色对象都被遍历完之后，垃圾回收器就可以将未被标记为黑色的对象视为不再使用的垃圾对象，进行回收了。



### gcDumpObject

gcDumpObject函数是一个用于调试的调试辅助函数，主要作用是打印内存中的对象信息，包括对象类型、对象的大小、标记位信息等。它可以用来检查程序中的内存泄漏、内存使用情况等问题。

在Go语言的垃圾回收器中，gcDumpObject函数主要用于在垃圾回收过程中输出对象的信息，以便于开发者调试问题。该函数在垃圾回收器遍历整个堆空间时调用，当一个对象的标记位被标记为黑色时，该函数将打印该对象的信息。该函数的输出信息包括对象的地址、类型、大小以及标记位等。

在开发过程中，当需要调试程序中的内存使用问题时，可以使用gcDumpObject函数来输出堆空间中的对象信息，并通过分析输出结果来判断内存是否存在泄漏、内存使用是否合理等问题。



### gcmarknewobject

在 Go 语言的 GC 过程中，会使用一个叫做 Tri-Color Marking 算法（三色标记算法）来标记对象的状态。在这个算法中，对象会被标记为三种颜色，分别是白色、黑色和灰色。

当对象被创建时，它的颜色是白色，表示该对象未被扫描过。当对象被扫描到后，它的颜色变为灰色，表示该对象所引用的其他对象还未被扫描。当该对象所引用的所有对象都被扫描后，该对象的颜色变为黑色，表示该对象已被扫描过。

而 gcmarknewobject 函数就是在这个标记过程中，将新创建的对象标记为白色，表示该对象还未被扫描过。这个函数的实现比较简单，就是将对象的指针地址加入到未扫描对象队列中，等待后续的扫描过程。

在 GC 过程中，gcmarknewobject 函数的调用频率很高，因为每当创建一个新对象时都需要调用该函数。因此，该函数的性能对 GC 整体性能有很大影响。



### gcMarkTinyAllocs

gcMarkTinyAllocs这个func的作用是将可以被回收的小对象标记为可回收状态，以便在垃圾回收时能够被正确地处理。

在Go语言中，内存分配器可分配的最小内存块大小为16个字节，而一些较小的对象也可能被分配16个字节的内存块。为避免浪费大量内存，可被回收的小对象会使用tinyalloc算法进行管理。这个算法将一些小对象放到一个缓存中，将其与一个16字节大小的掩码进行按位与运算，得到一个掩码子集，表示可以被回收的小对象的位置。这个算法会在新分配小对象时，先检查是否有可回收的小对象，有的话就不再分配新的内存块，而是用空闲的内存块来存储这个小对象，减少内存占用。

gcMarkTinyAllocs函数的作用是在垃圾回收器进行标记阶段时，遍历这个掩码子集，将其中表示可回收对象的位置标记为可回收状态，以确保这些小对象能够被正常回收。这个遍历过程是基于32位或64位机器架构的，因为掩码子集的长度是32位或64位。遍历过程中，gcMarkTinyAllocs函数使用位移和&运算等位操作来遍历掩码子集，并使用nextPtr函数来获取可回收对象的指针位置，从而将其标记为可回收状态。

总之，gcMarkTinyAllocs函数是Go语言中垃圾回收器的一个重要函数，用于处理可被回收的小对象，减少内存占用。



