# File: mpagealloc_64bit.go

mpagealloc_64bit.go这个文件是Go语言中runtime包实现内存管理的一个子模块，主要用于为64位操作系统上的Go程序分配和管理内存页。其作用如下：

1. 为64位操作系统上的Go程序分配内存页。

2. 管理内存页的分配和释放，包括内存池的维护、内存页的标记和回收等工作。

3. 对内存页的使用进行优化，例如采用mmap系统调用来分配内存，采用分级内存池的方式进行内存管理等。

具体来说，mpagealloc_64bit.go这个文件中定义了一些结构体和函数，用于实现内存页的管理。其中，最主要的是mheap64结构体，它代表了一个内存池，用于管理一段连续的内存空间。该结构体包含了多个字段，包括页面大小、翻倍阈值、arena大小等。它的主要作用是维护内存页的使用状态，并在需要时分配或回收内存页。

此外，mpagealloc_64bit.go这个文件中还定义了一些其他的函数，用于实现内存页的分配、释放和管理。例如，pageAlloc和pageFree函数分别用于分配和释放内存页；mmap和munmap函数分别用于调用系统函数mmap和munmap来分配和释放内存；init函数则用于初始化内存池等。

总之，mpagealloc_64bit.go这个文件为64位操作系统上的Go程序提供了一个高效、可靠的内存管理机制，为Go语言的运行和发展提供了有力的支持。




---

### Var:

### levelBits

变量levelBits用于计算内存页大小的级别。在Go语言中，内存页的大小是动态调整的，根据需要分配的内存大小进行调整。为了实现这个动态调整，Go运行时定义了不同级别的内存页大小。每个级别的内存页大小在不同的情况下都有其优缺点，可以针对不同的场景选择不同的页大小。

levelBits变量定义了每个级别的内存页大小所用的位数。例如，如果levelBits[0]为6，则表示第一级别的内存页大小为2的6次方（64）。每个级别的内存页大小是前一个级别大小的两倍，所以levelBits的值是指数级的。这种指数级增长使得在不同的内存分配场景下动态选择合适的内存页大小成为可能。

levelBits的具体值是在运行时根据当前系统的内存分配情况进行计算的，这样能够保证选择的页大小最优。通过调整levelBits的值可以实现更细粒度的内存分配控制，以适应更复杂的内存分配场景。



### levelShift

在go/src/runtime中的mpagealloc_64bit.go文件中，levelShift是用于计算扇区大小的变量。具体来说，当做内存分配时，一个大的连续的内存块被分成多个较小的连续的内存块，每个块的大小是2的幂次方，例如：2^8，2^9等等。 

levelShift的值是一个整数类型，表示当将一个大的内存块分成若干个小块时，每个小块的大小的指数。例如，如果levelShift的值是8，那么每个小块的大小将是2 ^ 8 = 256字节。

此外，levelShift变量还在分配内存时用于计算每个小块的位图大小。在这种情况下，位图大小的计算方式为2^(levelShift - _PageShift)，其中_PageShift是平台相关的变量，表示页面大小在位数移位，通常为12。 因此，对于levelShift = 8和_PageShift = 12的情况，位图大小为2 ^ (8 - 12) = 1/64页。 

总的来说，levelShift变量在内存分配和位图大小计算中起着重要的作用。它确保内存块被正确划分，保证位图的正确性，并避免内存分配操作的竞争。



### levelLogPages

levelLogPages是一个数组，它存储了每个level的page大小的对数。在这个文件中，分配器使用一种类似于“伸缩”的算法来管理内存块。每个level都定义一个“span”大小，其中包含多个page。每个page的大小是2的幂次方，每个级别的page大小相差两倍。例如，levelLogPages[0]对应的是page大小为2^0字节（即1字节），而levelLogPages[10]对应的是page大小为2^10字节（即1024字节）。

这个数组的作用是确定每个级别的page大小。它用于计算内存块所需的最小级别，并以最小级别为单位分配内存。例如，如果我们需要分配一个256字节的内存块，那么我们需要一个levelLogPages[8]大小的span，因为2^8 = 256。同样地，如果我们需要分配一个4096字节的内存块，我们需要一个levelLogPages[12]大小的span，因为2^12 = 4096。

levelLogPages还对应着每个级别的span大小的最大值。例如，levelLogPages[0]的span最大值是16KB（2^14字节），而levelLogPages[10]的span最大值是1GB（2^30字节）。在运行时，分配器会根据当前内存使用情况动态地调整每个级别的span大小。这样可以更好地匹配内存的使用情况，避免浪费和内存碎片化。

总之，levelLogPages是一个重要的变量，它确定了每个级别的page大小和span大小的最大值，以及在运行时分配器如何动态调整span大小。它是内存分配器的关键组成部分，直接影响着内存的使用效率和性能。



## Functions:

### sysInit

在 Go 1.14 及以后版本中，runtime 包中提供了一种新的分配器 mpagealloc_64bit，该分配器专门针对 64 位架构的系统。sysInit 函数是 mpagealloc_64bit 分配器在程序启动时执行的初始化函数之一。

sysInit 函数首先会检查当前操作系统是否支持 Memory Protection Keys (MPK) 功能，如果支持，则为所有内存页设置 MPK，以增强对内存访问的保护；否则，函数会为所有内存页设置保护模式，以防止非法内存访问。

接着，sysInit 函数会创建一个 SystemStack，并初始化栈空间，设置栈空间中用于存储 goroutine（即协程）信息的位置，初始化当前 goroutine 的栈信息，以及设置当前 goroutine 使用的 sched 栈空间。

最后，sysInit 函数会将 allocm 和 freem 的指针设置为对应的函数指针，以支持内存分配和释放操作。

总之，sysInit 函数的作用是初始化 mpagealloc_64bit 分配器，并设置对内存空间的保护和分配/释放操作的支持。



### sysGrow

在go/src/runtime/mpagealloc_64bit.go文件中，sysGrow是一个函数，它的作用是将操作系统的虚拟内存区域扩展到指定的大小并返回该区域的起始地址。

该函数在操作系统的底层系统调用中使用，用于分配一块指定大小的内存区域。通过这个函数，Go语言可以直接调用操作系统的接口来获取内存，而不必使用C语言的malloc函数。

sysGrow函数通过调用mmap系统调用来实现内存分配，它会请求一个指定大小的新内存区域，并将其映射到进程的虚拟地址空间中。在调用sysGrow函数时，它会指定一个内存映射标志，以控制分配的内存类型。

当Go运行时需要扩展堆时，它会调用sysGrow函数并传递所需的大小。该函数会检查传递的大小是否超出操作系统的限制，然后调用mmap函数以映射内存。最后，它会返回新分配内存的地址和大小。

总之，sysGrow函数是用于操作系统的虚拟内存分配的底层接口，用于提供Go程序所需要的内存。



### sysGrow

sysGrow是在运行时中实现内存分配器的函数之一。其作用是将当前的堆 expandSize 大小进行扩展。

具体来说，sysGrow首先计算出新的堆终止地址newend，并使用mmap系统调用将新的一页（通常为4KB）映射到堆终止地址处。如果映射成功，该页的地址将存储在&moremem中，可供后续使用。然后，它将更改堆终止地址以反映新添加的页的大小。

sysGrow在内存分配器操作期间多次被调用，以确保堆的容量足够容纳正在分配的对象。如果增加堆的大小失败，则会引发panic。

需要注意的是，MP0堆增量必须大于零，否则sysGrow将返回错误。此外，增量必须是操作系统页面大小的倍数（常见为4KB），否则sysGrow仍将增加页面的数量以达到所需的增量。



### sysInit

sysInit函数是在程序启动时执行的，并且是在堆空间初始化之前进行的。其目的是设置内存页分配器，并初始化用于内存分配的数据结构。

在sysInit中，首先会设置PAGESIZE和mheap_.arena_start等变量。PAGESIZE指定了系统中使用的内存页的大小，mheap_.arena_start则指定了堆空间的起始地址。接下来，会初始化arena_index和heap_live变量。arena_index用于跟踪当前堆空间中已使用的内存页数，heap_live则表示当前堆空间已分配但未释放的内存大小。

sysInit函数还会创建mheap_中的内存池，并初始化多个链表，这些链表用于跟踪内存分配大小不同的内存块。在这个过程中，还会设置mheap_.min和mheap_.max两个变量，这些变量分别表示了可以分配的最小和最大内存块的大小。

总的来说，sysInit函数是在程序启动时初始化内存分配器的关键函数。通过设置内存页大小，创建内存池，初始化堆空间和内存块链表等操作，确保了程序具有高效的内存分配和回收能力。



