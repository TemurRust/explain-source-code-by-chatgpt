# File: mkpreempt.go

mkpreempt.go文件是Go语言运行时系统中负责实现用户级线程抢占机制的核心文件。Go语言中支持协程，也就是用户级线程。用户级线程是一种轻量级的线程，由用户程序创建和管理，可以在一个操作系统线程上实现多个用户级线程。不同的用户级线程之间可以并发运行，可以实现协作式任务调度。

在默认情况下，Go语言的协程任务调度是非抢占式的，也就是说，一个协程只有在主动让出CPU之后，其他的协程才有机会被调度执行。如果一个协程进入了死循环、长时间的IO等待或者CPU密集型计算，那么其他协程就无法执行。这样会导致Go程序的整体性能下降和资源利用率低下。

为了解决这种问题，Go语言提供了一种用户级线程抢占机制，可以在特定条件下抢占一个运行时间过长或者长时间阻塞的协程，并为其他协程留出运行时间。mkpreempt.go文件就是实现这种机制的文件。

mkpreempt.go文件主要实现了以下几个功能：

1. 定时器机制：该机制用于定时产生抢占信号，并优先执行被抢占的协程。实现该机制的关键是使用了基于时间轮的定时器框架，可以准确、高效地检测定时任务并执行。

2. 抢占机制：该机制用于实现协程抢占，包括释放被抢占协程的运行时间片，并将调度器切换到另一个协程。抢占机制需要针对不同的协程进行锁定和解锁操作，保证抢占的正确性和有效性。

3. 线程状态监控：该机制用于监控协程的状态，包括阻塞状态、运行状态、睡眠状态等，以便及时抢占运行时间过长或者长时间阻塞的协程。监控机制需要高效、准确地判断协程状态，并实现相应的状态转换和通知机制。

通过实现以上机制，mkpreempt.go文件可以让Go语言的协程在并发访问共享资源、长时间阻塞、死循环等情况下，可以被及时抢占，保证其他协程的运行。这种机制不仅可以提高Go程序的性能和稳定性，也可以保证系统的安全性。




---

### Var:

### regNames386

regNames386是一个字符串数组，包含了386架构下所有16个通用寄存器的名称，以及一些特殊寄存器和标志寄存器的名称。它的作用是为了让savel和loadl函数能够正确地保存和恢复寄存器的值。

在go程序运行过程中，当一个goroutine正在运行时，它的寄存器中可能存储了一些重要的值，比如函数参数、局部变量、指针等等。当某个goroutine被抢占或者调用goexit函数结束时，它的上下文状态需要被保存下来，以便在下一次继续运行时恢复到原先的状态。

savel和loadl函数就是用来实现这种保存和恢复操作的。它们的实现方式是通过汇编语言直接读取和写入寄存器的值，但是这些寄存器的名称是不同的，所以我们需要一个字符串数组来对应每个寄存器的名称。

具体来说，在savel函数中，我们会把所有通用寄存器以及一些特殊寄存器和标志寄存器的值依次写入缓存区，然后将这个缓存区的地址返回给调用者；在loadl函数中，我们则会依次将缓存区中的值读取到各个寄存器中。

因此，regNames386这个变量可以让我们方便地获取到对应寄存器的名称，从而正确地读取和写入寄存器的值，保证goroutine的上下文状态能够得到正确的保存和恢复。



### regNamesAMD64

在Go语言的runtime系统中，mkpreempt.go文件中的regNamesAMD64变量是一个用于记录寄存器名称的字符串数组。这个数组中保存了x86-64架构下一些寄存器的名称，比如AX、BX、CX、DX等等。

这个变量的作用是将寄存器和变量名相互映射，从而方便调试和打印。在Go语言的runtime系统中，当程序运行到一个断点时，需要把当前的寄存器值打印出来，以便进行调试。而使用regNamesAMD64数组就可以将寄存器值与寄存器名称对应起来，从而方便调试人员查看寄存器的值和状态。

另外，regNamesAMD64数组还可以用于生成汇编代码。在编写汇编代码时，需要使用寄存器来存储数据或执行指令。由于寄存器名称很难记忆，并且不同的架构下寄存器名称有所不同，因此使用regNamesAMD64数组来表示寄存器名称，可以使代码更加简洁和易于维护。

总之，regNamesAMD64变量是Go语言runtime系统中一个非常重要的变量，它在调试和汇编代码生成中都有着重要的作用。



### out

在Go语言中，Goroutine是Go程序的核心概念，它是一种轻量级线程。Goroutine的实现是基于协作式的抢占式调度模型，这意味着运行中的Goroutine只有在主动让出CPU时间片或者发生IO等阻塞操作时，才会被调度器挂起，让其他待运行的Goroutine上CPU执行。

但是，在某些情况下，当某个Goroutine陷入无限循环或者长时间的阻塞操作时，会导致整个程序的运行效率受到严重影响。为了避免这种情况的发生，Go语言提供了一种称为“Preemption”（抢占）的机制，即在运行的Goroutine执行一定时间后，强制其让出 CPU 时间片，以确保其他Goroutine得到执行的机会。

在Go语言的运行时环境（runtime）中，mkpreempt.go这个文件定义了Preemption抢占机制的实现。其中，out这个变量的作用是表示抢占的条件，即当当前的 Goroutine 执行时间超过 out 赋值的时间时，就会被强制让出 CPU 时间片，以确保其他 Goroutine 有一定的运行机会。需要注意的是，out这个变量的值是一个全局变量，在调试的时候可以通过修改这个值来控制 Preemption 的行为，但是在生产环境中，应该避免这种做法，因为它可能会影响系统的稳定性和性能。



### arches

mkpreempt.go这个文件是Go语言运行时系统的一部分，在中断可能发生的位置设置了抢占点。arches这个变量是一个包含了所有支持的架构名称的字符串切片。

具体来说，arches变量的作用是用于在不同架构的计算机上编写适当的汇编代码，从而实现在适当时机发生抢占，保证线程运行的公平性和正常性。在坚持公平性和保证线程各自运行的同时，抢占也可以确保线程不会占用过多资源，不会造成工作量不平衡。

在Go语言中，支持的架构包括x86、amd64、arm、arm64和ppc64le等。arches变量包含了所有支持的架构名称，这使得在不同的架构上编写代码和实现抢占点变得更加容易和方便。



### beLe

在Go语言的runtime包中，mkpreempt.go文件中的beLe变量是用来控制CPU的中断处理的。该变量是一个bool类型的全局变量，表示是否启用了低效的边缘触发中断（edge-triggered interrupt，也叫ETI）。

在计算机硬件中，中断是一种高效的机制，可以让CPU在等待I/O操作的时候去处理其他的任务。常见的中断类型包括时钟中断、外部中断、异常中断等。在操作系统中，中断的处理机制是通过向CPU发送一个中断信号来触发中断处理程序的执行。

对于ETI，它会在信号触发后立即被处理，而不是等待信号被清除。这种机制的好处是可以更快地响应中断，但产生的中断请求可能会大量增加，导致软件开销较高。如果使用了ETI但没有很好地管理它，可能会有严重的性能问题。

因此，在Go语言的runtime包中，beLe变量的作用就是启用或禁用ETI。当beLe为true时，运行时系统会采用低效的边缘触发中断；当beLe为false时，运行时系统会采用更为高效的电平触发中断（level-triggered interrupt，也叫LTI）。具体采用哪种中断方式，取决于操作系统和CPU的实现。






---

### Structs:

### layout

在go/src/runtime/mkpreempt.go中，layout结构体是用于定义堆栈中某些元素的布局的。这些元素包括调用goexit全局函数时保存在堆栈上的一些元素，以及抢占式调度所需的堆栈元素。

具体来说，layout结构体定义了以下内容：

1.一个指向程序计数器（PC）的指针，通常指向下一条将要执行的指令。

2.一个指向该函数的返回地址的指针。

3.一些必要的寄存器，如帧指针（FP）和堆栈指针（SP）。

4.其他需要存储在堆栈上的元素，如参数和局部变量。

这些元素的布局对于实现抢占式调度非常重要。在抢占式调度中，操作系统会在任何时候中断正在运行的程序，并切换到另一个程序，这需要保存当前程序的状态以便稍后恢复它。在Go中，这个状态是通过保存堆栈上的元素来实现的，而layout结构体就是指导如何保存这些元素的。

使用layout结构体的另一个重要原因是在Go中使用的堆栈可能是动态分配的，这意味着在不同的时刻可能会有不同的大小。由于layout结构体提供了元素的布局，它可以确保在堆栈大小改变时依然可以正确地保存和恢复状态。

总之，layout结构体是在Go中实现抢占式调度所必需的重要结构，它指导在堆栈上保存和恢复状态的方式，同时适应动态分配的堆栈大小。



### regPos

mkpreempt.go文件中的regPos结构体是用于记录寄存器的位置信息的数据结构。

在Go语言中，协程是通过调度器进行调度的。调度器会在任意时刻中断当前协程的执行，将其保存到上下文中，然后切换到另一个协程执行。这个过程被称为抢占式调度。

为了实现抢占式调度，调度器需要知道每个协程在执行期间使用哪些寄存器，以便在切换协程时正确地保存和恢复寄存器的值。这就是regPos结构体的作用。

regPos结构体中定义了一个数组regs，用于记录每个寄存器的位置信息。其中，每个元素包括寄存器名称和相应的位置信息（寄存器在函数调用栈中的偏移量）。

当调度器在切换协程之前，会检查当前协程使用了哪些寄存器，并使用regPos结构体中记录的位置信息将这些寄存器的值保存到当前协程的上下文中。然后调度器会切换到另一个协程执行，并从它的上下文中恢复之前保存的寄存器的值。

总之，regPos结构体是用于实现Go语言的抢占式调度机制的关键数据结构之一，它记录了每个协程使用的寄存器及其位置信息，保证了在多个协程之间正确地保存和恢复寄存器的值，从而实现了协程的快速切换和调度。



## Functions:

### main

在Go语言中，当一个goroutine正在运行时，其他goroutines不能够优先于它运行。为了保证goroutine相对公平的运行，Go语言引入了抢占式调度机制。这意味着Go运行时会在一定的时间间隔内检查当前正在执行的goroutine是否需要被抢占，以便其他goroutine获得运行的机会。

mkpreempt.go这个文件中的main函数的作用是创建一个被称为preempt的goroutine，并在其中运行一个死循环。这个死循环会在一定的时间间隔内调用checkPreempt函数，以检查当前运行的goroutine是否被其他goroutine抢占。如果需要抢占，checkPreempt会调用preemptOther函数进行抢占。

主要可以分为以下几个步骤：

1. 初始化程序的运行环境和调度器
2. 创建preempt函数的goroutine，并在其中运行一个死循环
3. 在循环中调用checkPreempt函数，以检查当前运行的goroutine是否需要被抢占
4. 如果需要抢占，调用preemptOther函数进行抢占
5. 继续循环，直到程序退出



### header

header函数主要用于跟踪预处理器对Go程序源文件所做的修改，并更新源文件的元数据信息。

预处理器（Preprocessor）是编译器的一部分，它可以对源代码进行一些语法上的转换和替换操作，例如将#define定义的宏替换为具体的值，或者将注释或空白行删除。虽然这些转换不会直接影响程序的执行结果，但它们可以使源代码更易于阅读和修改，并且可以减少编译器的工作量。

在编译Go程序时，预处理器会对源文件进行一些转换和处理，然后将处理后的结果传递给编译器进行编译。而header函数则是在这个过程中被调用的，它的主要作用是：

1. 跟踪预处理器对Go程序源文件所做的修改。header函数会记录每次预处理器对源文件做出的修改，包括修改的位置、类型（例如注释、宏定义等）、修改前后的内容等信息。

2. 更新源文件的元数据信息。每次修改都会更新源文件的元数据信息，包括修改时间、修改人员、修改版本等信息。这些信息对于程序的版本控制和维护非常重要。

在实现上，header函数会被借助于Go语言中的一个特殊注释来调用，即"//go:generate"注释。该注释可以让Go程序在编译时执行指定的命令，这里就可以指定header函数进行调用。具体实现方法可以参考mkpreempt.go这个文件中的源代码。



### p

mkpreempt.go文件中的p()函数的作用是将当前 goroutine 强制切换到另一个 goroutine 上执行，以防止长时间的 goroutine 阻塞主线程。

具体来说，当 goroutine 执行时间过长时，可能会导致主线程无法及时处理其他 goroutine 的调度请求，从而出现系统无响应的情况。为了避免这种情况，mkpreempt.go文件中的p()函数会周期性地检查当前 goroutine 的执行时间，并在超过一定阈值时强制切换到其他 goroutine 上执行，从而保证系统的响应性和可靠性。

具体实现过程如下：

1. p()函数会获取当前 p（处理器）的运行时间，即从上一次调度开始到当前时刻的时间。

2. 如果当前 p 的运行时间超过了预设阈值，则会调用手动调度函数，将当前 goroutine 强制切换到其他 goroutine 上执行。

3. 手动调度函数会找到一个合适的 goroutine 进行调度。

4. 如果没有找到合适的 goroutine 进行调度，则将当前 goroutine 加入全局运行队列中等待被调度。

总之，p()函数的作用就是保证系统的响应性和可靠性，防止长时间的 goroutine 阻塞主线程，从而提高系统的运行效率和性能。



### label

在Go语言中，一个Goroutine可以自愿的将自己从运行队列中移除（yield），这个行为称为Preemption。当某个Goroutine的执行时间占用了过多的CPU时间，或者在一个临界区内长时间运行（比如不停循环等待锁），就会影响到其他的Goroutine的执行，容易导致整体性能下降。

为了解决这个问题，Go引入了Preemption机制，可以主动中断正在运行的Goroutine，让其他的Goroutine获得运行机会。mkpreempt.go这个文件中的label函数就是实现这个机制的关键。

该函数的作用是引入一个无限循环，不停地检测当前Goroutine是否需要被Preemption。如果需要，则将当前Goroutine的状态设置为preempted，然后调用goready函数将其放入可运行队列中，并跳出循环，让其他的Goroutine获得运行机会。否则，就继续进行循环，直到Preemption发生。

在Go的调度器中，每个Goroutine都有一个G struct，其中包含了当前Goroutine的状态（running、ready、waiting），以及与运行状态相关的一些信息。在检测Preemption时，label函数会检查当前Goroutine的schedtick（调度计数器）是否达到了全局的sched.npreempt（限制的预计数），如果达到了，则触发Preemption。schedtick的主要作用是用来定义Goroutine可以运行的时间片大小，每次执行时会消耗一个tick，当ticks消耗完了，则轮到其他的Goroutine运行了。

总之，label函数就是Go语言调度器的核心所在，是实现Preemption机制的关键代码，保证了多个Goroutine能共享系统资源，避免了单个Goroutine对整个应用程序造成的影响，保证了应用程序整体性能的稳定。



### add

在 Go 语言中，一个 goroutine 在任意时刻都可以被强制抢占，让出 CPU，继续执行其他 goroutine。这个操作就叫做 preemption。在源码目录下的 runtime 包中的 mkpreempt.go 文件中，add 函数负责为一个 goroutine 添加 preemption preemption 规则并且触发 preemption。

具体来说，add 函数会将当前 goroutine（也就是当前执行的 goroutine）加入到调度器的 待运行队列 中。在循环中，调度器会不断从待运行队列中取出 goroutine，运行它，直到它被强制抢占或者被阻塞。当调用 add 函数时，会启动一个异步 goroutine，该 goroutine 在一段时间后会自动地将当前 goroutine 加入到待运行队列中。

在 add 函数中，会使用一个代码块获得当前 goroutine 的状态锁。在这个锁的保护下，函数会将当前 goroutine 的状态设置为 GoroutineWaitPreempt，并将其放入待运行队列中。在这个代码块中，函数还会记录当前执行的 goroutine 的 g 开始时间、阻塞时间以及阻塞的 P。

add 函数的目的是为了避免某个 goroutine 长时间占用 CPU 资源，保证其他 goroutine 也有机会被执行。因此，它会在一定时间后强制抢占当前 goroutine，并且将其放回待运行队列中，让其他 goroutine 有机会运行。这个时间间隔是通过调用 Go 中的 time.AfterFunc 函数实现的。由于该函数是异步的，因此 add 函数可以很快地返回，不会阻塞当前 goroutine。



### add2

add2这个func的作用是将一个指定数量的时间（以纳秒为单位）加到当前的计时器中。

在Go语言中，当一个goroutine正在执行时，它可以被其他goroutine的执行所中断，这叫做抢占式调度。这种抢占式调度是通过周期性地把计数器增加一个小的值来实现的。在每个goroutine的开始和结束时，都会检查计数器的值，如果它已经增加到一个指定的阈值，则会触发调度器，让其他等待的goroutine有机会执行。

而add2这个func就是用来增加这个计数器的值的。它被调用时，会将一个指定的时间值加到计数器中。这个时间值通常是一个固定的小值，例如1毫秒或10毫秒，这取决于操作系统的精度和Go语言运行时的实现。

在mkpreempt.go文件中，add2函数是由汇编语言实现的，它调用了一个叫做add64的汇编函数，用来将64位整数加到计时器中。这个函数使用了操作系统提供的特殊机制，可以在CPU上运行时禁用中断，防止其他进程或线程的干扰，保证计时器的准确性。



### addSpecial

addSpecial是一个用于向goroutine调度器的特殊队列中添加goroutine的函数。特殊队列中的goroutine会被优先调度，例如在发生抢占时，优先调度特殊队列中的goroutine。特殊队列中的goroutine可以是系统任务，例如垃圾回收程序，或者是用户创建的需要优先执行的goroutine。

这个函数主要接受两个参数：一个是待添加的goroutine，另一个是需要优先调度的类型。函数接收goroutine后会将其添加到对应类型的队列中，当需要优先调度时，会首先从特殊队列中获取goroutine进行调度。

需要注意的是，特殊队列中的goroutine并不是立即执行，而是在其他goroutine阻塞或者等待时会尝试获取特殊队列中的goroutine执行，因此它不能被用于请求立即执行goroutine。



### save

在 Go 语言中，一个 goroutine 运行时会分配一个 goroutine 的栈空间。在实际运行过程中，我们常常会遇到程序崩溃或者运行出现错误，导致 Go 程序无法继续执行的情况，这些情况被称为 panic。为了保证程序的正常运行，Go runtime 采用了三层的保护机制，也就是分别对应了 defer、panic 和 recover，其中 runtime 会在程序出错时保存一些必要的现场信息，这些信息主要包括栈指针（SP）、程序计数器（PC）、栈顶指针（BP）等信息，以便后续恢复运行。

在 mkpreempt.go 中，save 函数的作用就是保存当前 goroutine 的现场信息。这个函数的具体作用流程如下：

1.首先，在 save 函数中调用了 getg() 函数，获取当前 goroutine 的信息、信息存储在 m.g0 结构体中。

2.接着，save 函数调用了 getCpuid() 函数，获取当前运行时的 CPU ID。

3.然后，save 函数去获取当前 goroutine 的栈信息，也就是将执行栈的当前状态保存到 g 栈机器的栈中。

4.最后，将当前 goroutine 的现场信息保存在 g 运行时的栈机器的栈顶，并将指向栈顶的 SP 寄存器向下移动。这样，在后续需要恢复程序执行时，只需要从栈顶开始取出之前保存的现场信息，就可以恢复程序执行了。

总体来说，save 函数的目的是保存当前 goroutine 的现场信息，并将其存储到 Go runtime 的栈机器中，以便在程序出现 panic 等异常情况时，可以及时恢复程序的运行状态。



### restore

在Go语言的运行时中，Go程序的协程会在运行中被抢占。这意味着，当某个协程运行繁忙时，其它协程可以抢占该协程的执行权，并开始执行一些其它操作。

在runtime/mkpreempt.go文件中，restore函数的作用是执行协程上下文的恢复操作。当一个协程被抢占后，系统会保存该协程的上下文信息。当该协程再次获得执行权时，restore函数会恢复该协程的上下文信息，以便协程可以从被抢占的地方继续执行。

具体而言，restore函数会首先获取当前协程的g（goroutine）指针，并将当前协程的栈指针更新为该协程的栈指针。然后，restore函数会从当前协程的栈中弹出协程的上下文信息，并使用这些信息来恢复协程的状态。最后，restore函数会将当前协程的状态更改为恢复状态，从而使该协程可以继续执行。

需要注意的是，restore函数只有在协程被抢占后才会执行。在未发生抢占的情况下，该函数不会被调用。此外，由于该函数涉及协程状态的更改，因此需要进行同步措施以确保其正确性。



### gen386

gen386函数是一个汇编代码生成器，它用于生成针对x86架构的汇编代码。该函数的主要作用是根据操作系统的需求生成针对系统调用和抢占式调度的汇编代码。

具体来说，gen386函数生成的汇编代码用于以下三个操作：

1. 抢占式调度

抢占式调度是指操作系统中临时挂起正在执行的进程并将处理器分配给其他任务的机制。gen386函数生成的汇编代码用于实现抢占式调度功能，当系统需要临时挂起进程时，会调用该函数生成的汇编代码来实现任务切换。

2. 中断处理

中断是计算机硬件向操作系统发出请求的一种机制，操作系统需要能够及时响应并处理这些中断请求。gen386函数生成的汇编代码用于实现中断处理功能，当操作系统接收到中断请求时，会调用该函数生成的汇编代码来处理请求并响应中断。

3. 系统调用

系统调用是计算机系统提供给用户程序访问操作系统内核功能的接口。gen386函数生成的汇编代码用于实现系统调用功能，当用户程序发起系统调用请求时，会调用该函数生成的汇编代码来执行所需内核功能。

总的来说，gen386函数的作用是生成针对x86架构的汇编代码，用于实现操作系统的抢占式调度、中断处理和系统调用等功能。



### genAMD64

genAMD64是一个用于生成汇编代码的函数，主要用于实现Go语言的抢占式调度机制。抢占式调度是指当一个goroutine执行时间过长，导致其占用CPU时间过多时，系统会中断当前goroutine的执行，将CPU资源分配给其他goroutine去执行的调度方式。

具体来说，genAMD64函数会生成一段汇编代码，该代码用于实现抢占式调度的功能。其实现原理为：

1. 在Go语言运行时的每个m（machine）中，都有一个抢占标记。当抢占标记被设置为true时，表示当前goroutine可以被抢占。

2. genAMD64函数会生成一段汇编代码，用于在每个goroutine的执行过程中不定时地检查抢占标记是否为true。

3. 如果抢占标记为true，则汇编代码会跳转到preempt函数中，实现goroutine的抢占。

4. 在preempt函数中，系统会将当前goroutine的状态保存下来，并从goroutine队列中选择一个新的goroutine来执行。

5. 执行完新的goroutine之后，系统会将保存的状态恢复，并继续执行之前被抢占的goroutine。

通过这样的实现方式，Go语言的抢占式调度机制可以有效地避免goroutine长时间占用CPU资源导致系统不可响应的问题，提高了Go语言并发编程的稳定性和可靠性。



### genARM

在Go语言中，当一个goroutine正在执行时，如果有另外一个goroutine想要运行，那么它需要等待当前goroutine暂停或者执行完成。这种情况下，Go语言的调度器需要进行一个切换操作，即从当前的goroutine切换到需要运行的goroutine。

在mkpreempt.go文件中，genARM函数的作用就是生成一段汇编代码，在需要切换到另一个goroutine时，程序可以执行该汇编代码来实现调度器的切换操作。genARM依据不同的CPU架构生成不同的汇编代码，本文只介绍ARM结构下的实现。

在ARM架构下，每个goroutine有一个栈，而栈指针存在CPU的寄存器中。genARM函数生成的汇编代码将当前goroutine的栈指针保存到寄存器中，同时调用go·park函数进入等待状态。当有其他goroutine需要执行时，调度器会从等待队列中取出等待的goroutine，将其栈指针从寄存器中取出，恢复它的执行，从而实现了goroutine之间的切换。

具体来说，genARM函数会生成以下汇编代码：

```asm
MOVW [R13], R4 //将当前的栈指针保存到goroutine的栈顶
MOVT [R13], R4
CALL runtime·park  
```

通过MOVW和MOVT指令，将R4寄存器中的值存储到R13所指向的内存地址中，并且由于R13寄存器存储了当前goroutine的栈指针，因此就是把当前的栈指针存储到了goroutine的栈顶。然后调用了go·park函数，进入等待状态，等待调度器将它唤醒。

总的来说，genARM函数的主要作用是生成一段汇编代码，用于在需要切换到另一个goroutine时，实现调度器的切换操作。



### genARM64

genARM64函数是在处理抢占过程中用于生成ARM64汇编代码的函数。在嵌入式操作系统中，抢占是指在执行高优先级任务之前，中断低优先级任务的执行。genARM64函数确定了在抢占过程中尝试保存寄存器值的顺序。更具体地说，它确定了要保存的寄存器的顺序，以及要将值保存到堆栈中的顺序。

在genARM64函数中，程序员首先指定了要保存的寄存器名称和将值保存到堆栈时所使用的堆栈指针偏移量。接下来，程序员定义了保存每个寄存器所需的汇编指令。在这里，由于ARM64处理器的体系结构，R30到R62寄存器被保留用于操作系统和硬件使用。因此，在处理抢占时，程序员必须考虑这些寄存器的保留用途。最后，genARM64函数将所需的汇编指令拼接成一个完整的片段，然后返回该片段以由系统调用。

总之，genARM64函数是一个关键的部分，它为实现ARM64体系结构上的抢占提供了必要的汇编指令。通过指定需要保存的寄存器以及它们的保存顺序，genARM64函数确保了在抢占过程中避免丢失重要数据。



### genMIPS

在Go语言中，MIPS（Microprocessor without Interlocked Pipeline Stages）是指一种处理器架构，其基于RISC（Reduced Instruction Set Computing）风格，被广泛用于嵌入式系统和网络设备中。在Go语言中，可以通过生成MIPS代码来进行跨平台编译。

在go/src/runtime/mkpreempt.go中，genMIPS函数用于生成用于MIPS处理器的汇编代码。具体而言，该函数实现了以下功能：

1.生成汇编代码中的头文件：首先，函数会将MIPS处理器所需的头文件包括在生成的汇编代码中。这些头文件包含了MIPS指令集的定义和其他相关信息。

2.生成汇编代码中的基本操作：接下来，函数会生成一些基本的汇编操作，比如跳转、保存寄存器和加载寄存器等。

3.生成汇编代码中的G操作：在Go语言中，G（Goroutine）是指一个运行在独立线程中的执行单元。在生成MIPS汇编代码时，函数会根据G的状态来生成相应的汇编指令。比如，如果G处于等待状态，则函数会生成相应的休眠指令。

4.生成汇编代码中的系统调用：在MIPS处理器中，系统调用是指从用户模式（user mode）切换到内核模式（kernel mode）并请求内核执行某个操作的指令。在生成汇编代码时，函数会添加相应的系统调用指令，以便程序可以在MIPS处理器上正确运行。

总的来说，genMIPS函数在Go语言编译过程中起到了关键的作用，它能够将Go语言代码编译成可以在MIPS处理器上运行的汇编代码。



### genLoong64

genLoong64函数的作用是生成用于在龙芯64处理器上实现抢占调度的汇编代码。

在龙芯64处理器中，抢占调度需要通过汇编代码来实现。genLoong64函数利用汇编模板，以及一些预定义的符号和常量，生成具体的汇编代码，并返回这段代码的字节码。

具体来说，genLoong64函数生成了两部分内容：

1. startPreempt检查当前是否允许进行抢占调度，如果可以就跳转到preempt标签，否则跳转到return标签。
2. preempt标签保存当前寄存器状态，调用runtime.preemptM函数进行抢占调度，再恢复寄存器状态并跳转到return标签。

这样，当龙芯64处理器在运行Go程序时需要进行抢占调度时，就会跳转到startPreempt这段代码中进行判断并执行相应的操作，从而实现抢占调度的功能。



### genPPC64

在Go语言中，mkpreempt.go文件的功能主要是为了实现Go协程的抢占式调度。genPPC64这个函数是为ppc64架构生成特定的代码，以实现协程的抢占式调度。

具体来说，该函数生成了一个汇编代码块，用于将处理器的执行权转移到调度程序。这个代码块被嵌入到Go编译后的可执行程序中，在发生抢占时被调用。

在Go协程的抢占式调度中，调度程序会周期性地中断正在执行的协程，并将处理器的执行权转移到其他需要执行的协程。这种调度方式可以避免某个协程长时间占据处理器，导致其他协程无法得到执行，从而提高并发性能。

genPPC64这个函数的实现过程中，主要涉及ppc64架构的汇编代码和指令，需要对这些指令进行深入理解。因此，genPPC64这个函数的主要作用是为ppc64架构提供可靠的协程抢占式调度支持。



### genRISCV64

在Go语言中，preemption是指当一个goroutine占用CPU时间过长时，调度器为了保证其他goroutine的运行，强制停止当前goroutine并切换到其他goroutine上运行的机制。mkpreempt.go是Go语言运行时系统中的一个文件，其中包含了一些与preemption相关的代码。其中，genRISCV64是用于生成RISC-V64架构代码的函数。

RISC-V（Reduced Instruction Set Computing，缩小指令集计算机）是一种新兴的指令集架构，它具有开放、简单、灵活等特点，被认为是未来CPU市场的重要竞争者。在genRISCV64函数中，会生成一些RISC-V64架构的汇编代码，目的是实现preemption机制。这些汇编代码主要实现了如下几个步骤：

1. 计算当前CPU时间：通过调用rtime函数获取当前CPU时间，并将其保存在$t0寄存器中。

2. 计算下一次preemption的时间点：将$t0寄存器中保存的CPU时间加上preemptMS值得到下一次preemption的时间点，并将其保存在$t1寄存器中。

3. 将下一次preemption时间点写入全局变量：将$t1寄存器中保存的下一次preemption时间点写入全局变量nextPreempt，以便其他代码可以访问该时间点。

4. 禁用中断：禁用中断以保证当前操作的原子性。

5. 将mscratch寄存器中的值保存到栈中：将mscratch寄存器中保存的值压入栈中，以保存该值。

6. 将下一次preemption时间点保存到mscratch寄存器中：将$t1寄存器中保存的下一次preemption时间点保存到mscratch寄存器中，以便在下一次preemption时使用。

7. 恢复中断：恢复中断以允许其他代码执行。

通过以上步骤，genRISCV64函数生成的汇编代码实现了preemption机制中的时间点计算和保存、中断禁用和恢复等操作，为其他代码提供了支持。



### genS390X

genS390X函数是runtime在S390X架构上的实现代码之一。它是一个汇编的函数，用于生成S390X CPU的中断处理代码。中断是一个程序被打断，执行一些特殊的操作，然后返回执行的过程。在S390X上，中断处理需要特殊的指令和处理程序才能正确地进行。

genS390X函数使用了S390X架构的一些特殊指令和寄存器来执行中断处理过程。首先，它保存了现在的程序状态到堆栈中。然后，它使用特殊的指令和寄存器来获取和处理中断。最后，它从堆栈中恢复现在的程序状态，以便程序可以继续执行。

这个函数的作用就是生成S390X架构的中断处理代码。在Go程序中，当这个函数被调用时，它会生成一段特殊的代码，用于处理中断。这样，在S390X架构上，Go程序就可以正确地处理中断并继续执行。



### genWasm

genWasm函数是一个内部函数，它用于在WebAssembly上生成“preemption-check”的汇编代码。 preemption-check是“抢占式调度”机制，它允许Go在运行时强制中断Goroutine，以确保在长时间运行的Goroutine的情况下，调度器可以重新获得控制权并使其他Goroutine具有机会运行。

具体来说，genWasm函数生成的汇编代码包括以下内容：

1. 启用中断：通过使用setTimer函数设置定期中断，使调度器能够在运行长时间的Goroutine时强制中断。

2. 死循环检查：当发生中断时，汇编代码将快速进入一个死循环，以检查中断是否已被触发，并在中断发生时跳转到相应的处理程序。

3. 中断处理：当中断触发时，调度器将调用gocheckPreempt的函数，并将控制权归还给调度器，让其重新分配Goroutine。

总之，genWasm函数的作用是生成能够实现抢占式调度的汇编代码，以确保调度器能够在必要时强制中断长时间运行的Goroutine，并重新分配处理器时间给其他就绪的Goroutine。



### notImplemented

在Go语言的运行时系统中，mkpreempt.go文件中的notImplemented函数用于抛出一个未实现的错误。当某些预期的功能还没有被实现，或者在某些平台上还不可用时，该函数将被调用。

该函数的主要作用是在运行时期间提供有用的错误消息，以帮助开发者调试代码并更好地了解当前环境的限制。

具体来说，notImplemented函数使用panic操作抛出一个runtime.notImplementedError类型的错误。在处理这个错误时，运行时系统可以打印有用的调试信息，比如所需要的功能的名称，以及当前所处的平台或环境的限制。

这种做法与Go语言的设计理念相符合，在这种设计中，强调代码应该尽可能地简单和明显。因此，如果某些功能不受支持，而代码又试图使用这些功能，那么抛出一个错误可以及时地提醒开发者这一点。这样，代码中出现的错误可以更容易地被调试和修复。



