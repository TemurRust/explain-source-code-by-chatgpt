# File: mgcstack.go

mgcstack.go文件是Go语言运行时（runtime）的一部分，主要作用是实现垃圾回收的栈管理功能。垃圾回收是Go语言的一个核心功能，它可以自动回收不再被使用的内存，减少内存泄漏和程序崩溃的问题。

mgcstack.go实现了与垃圾回收有关的栈管理功能，其中包括以下几个主要的函数：

1. stealList：将其他goroutine的栈（包括堆栈和应用程序栈）从这些goroutine中“偷”出来，用于垃圾回收。这个函数会把其他goroutine的栈“标记”起来，表示这些栈已经被“偷了”。

2. resetState：重置和清空所有与垃圾回收相关的状态信息，包括标记状态（marked），黑色状态（black）、扫描状态（scanned）等等。

3. transfer：将其他goroutine的栈从一个线程（thread）转移到另一个线程，通常是从一个忙碌的线程（busy thread）转移到一个空闲的线程（idle thread）以完成垃圾回收。

4. drain：将从其他goroutine的栈中“偷”来的对象或指针存储在当前goroutine的栈中，并将标记状态（marked）设置为黑色状态（black）。

这些函数在垃圾回收期间被反复调用，以确保内存中的对象正确地被标记，扫描和回收。同时，这些函数也需要合理地管理线程和goroutine之间的资源调度和协作，以确保垃圾回收的可靠性和效率。

总之，mgcstack.go文件是Go语言运行时中实现垃圾回收栈管理的重要代码文件之一，它的作用是确保垃圾回收能够在多线程、多goroutine的环境中正确地完成。




---

### Structs:

### stackWorkBuf

stackWorkBuf结构体在Go语言的垃圾回收器中用于表示一个用于处理栈的缓冲区。具体来说，它是用于存储标记、清除、栈扫描等操作所需的各种信息的缓冲区。

stackWorkBuf结构体中包含了多个字段，其中最重要的是shadow和obj，它们都是切片类型。shadow切片用于存储用于标记和清除操作的位图信息，用于标记哪些对象是可达的。obj切片则用于存储待处理的栈和对象信息，其中包括待处理的指针、堆栈指针、对象指针等信息。

在垃圾回收的过程中，系统会根据需要分配一定数量的stackWorkBuf结构体，它们被用于存储和传递各种信息，以便完成垃圾回收的操作。

总之，stackWorkBuf结构体作为一个重要的数据结构在Go语言的垃圾回收器中发挥着重要作用，它是完成各种垃圾回收操作所需的数据和信息的缓冲区，以提高垃圾回收的效率和性能。



### stackWorkBufHdr

stackWorkBufHdr这个结构体主要用于表示正在进行 GC 的协程的工作缓冲区的头部信息。

该结构体中包含以下字段：

-	start uintptr：缓冲区的起始地址；
-	size uintptr：缓冲区的大小；
-	unused list：表示缓冲区中未使用的 slot 列表；
-	g0 bitset：表示缓冲区中与当前 GC 关联的 g0 的位置信息，其中包括 g0 所在的堆、栈起始地址等信息；
-	span bitset：表示缓冲区中涉及的 span 的位置信息，其中包括 span 所在的堆、页表起始地址等信息。

在进行 GC 时，系统会首先确定需要扫描哪些协程的栈，然后逐个扫描这些协程中栈上的对象。这时，就需要使用 stackWorkBufHdr 结构体来确定当前协程的工作缓冲区的位置和大小等信息，以便对其进行扫描。

同时，由于该结构体中保存了与当前 GC 有关的关键信息，因此在进行 GC 过程中还可以使用该结构体来更新相关信息，如标记可达对象等。



### stackObjectBuf

在Go语言的垃圾回收机制中，当进行栈扫描时，需要遍历每个goroutine的栈。为了防止访问不属于自己的栈空间，需要在扫描时保证访问的数据在当前goroutine的栈内。这时就需要使用stackObjectBuf结构体。

stackObjectBuf是垃圾回收机制中的一个栈缓存，用于存储当前goroutine中所有可能需要扫描的对象的地址。当需要扫描当前的栈时，通过stackObjectBuf可以获取当前栈中的所有对象地址，同时也可以用于标记哪些对象已经被遍历过。

stackObjectBuf结构体中主要包含两个字段：

1. buf：存储当前goroutine中的对象地址的缓存，可以存储多个地址；
2. next：指向下一个需要扫描的对象的地址的位置。

通过这两个字段，可以遍历当前goroutine中所有的对象，并进行必要的标记。

总的来说，stackObjectBuf结构体的作用是在垃圾回收过程中，用于存储当前goroutine中的需要扫描的对象地址，以及标记哪些对象已经被遍历过。



### stackObjectBufHdr

stackObjectBufHdr是用于管理堆栈对象缓冲区的结构体，它的作用是为了提高GC的效率和减少堆栈扫描的消耗。在Go语言中，GC需要遍历整个对象图来标记哪些对象是活动的，而这个过程是非常耗时的。为了减少这个过程对性能的影响，Go使用了一些优化技术来减少堆栈扫描的次数和消耗。

stackObjectBufHdr是用于实现这些优化技术的其中一种方式。它是一个包含在堆栈对象缓冲区中的头部结构体，用于管理这个缓冲区中的对象信息和分配的内存空间。当堆栈中创建了一个新的对象时，它会被放入堆栈缓冲区中，并由stackObjectBufHdr记录下来。当GC扫描堆栈时，它只需要扫描这个缓冲区中的对象，而不需要遍历整个堆栈，从而提高了GC的效率和减少了堆栈扫描的消耗。

总之，stackObjectBufHdr结构体的作用是为了提高GC的效率和减少堆栈扫描的消耗，它是实现这些优化技术的其中一种方式。



### stackObject

stackObject是Go语言中用于存储堆栈信息的数据结构，它的定义如下：

```
type stackObject struct {
	argp uintptr // pointer to first function argument
	fd   uintptr // fixed frame data
	varp uintptr // pointer to first local variable
}
```

这个结构体用于描述函数调用栈中一个函数调用的信息。具体来说，stackObject中的argp、varp和fd字段分别表示函数调用的参数、局部变量和固定帧的位置信息。

在Go语言的垃圾回收机制中，需要扫描堆栈以确定哪些对象可以被回收。stackObject结构体的作用就是在这个过程中提供堆栈信息，帮助GC算法判断所有对象的生命周期。具体来说，GC算法会遍历所有的栈帧，并且在每个栈帧中找到stackObject结构体，从而获取该栈帧中的变量信息，以便判断对应的对象是否需要被回收。

综上所述，stackObject结构体在Go语言中的垃圾回收机制中扮演着关键的角色，它提供了堆栈信息以便GC算法判断对象生命周期，是Go语言的一项重要的内存管理机制。



### stackScanState

在Go语言的垃圾回收机制中，堆栈扫描是其中的一个重要过程。垃圾回收器需要遍历所有活跃的堆栈来找出其中存储的指针，从而标记出活跃的对象。为了实现这一过程，Go语言运行时在mgcstack.go文件中定义了stackScanState结构体。

stackScanState结构体用于表示堆栈扫描状态。它存储了垃圾回收器需要遍历的所有堆栈信息，包括：

1. gs：表示Goroutine的状态，表示该堆栈属于哪个Goroutine。
2. sp：表示堆栈指针，指向堆栈的当前位置。
3. pc：表示程序计数器，指向当前执行的代码位置。
4. scanDepth：表示扫描深度，用于控制递归嵌套时的深度。
5. scanType：表示扫描类型，记录当前是“黑色扫描”、“灰色扫描”、“白色扫描”中的哪一种状态。

通过这些信息，垃圾回收器可以遍历所有活跃的堆栈，扫描其中存储的指针，并标记出活跃对象，进而释放不再使用的内存。这些过程都是由stackScanState结构体来处理的。



## Functions:

### init

在 Go 语言中，init 函数被用于初始化程序，它会在程序执行之前自动调用。在 mgcstack.go 文件中的 init 函数主要用于初始化全局变量。

在 init 函数中，它会初始化一些与垃圾回收相关的全局变量，例如：

- gcprocs：垃圾回收器的处理器数量，它取决于机器的硬件配置。
- gcpercent：当堆大小超过 Go 程序运行期间分配的内存的百分之 gcpercent 时，会触发垃圾回收操作。
- gcController：它是垃圾回收器的控制器，在运行时会根据程序的运行情况自动调整垃圾回收的策略。

除了初始化这些全局变量之外，init 函数还会设置一些与调试相关的标志，并调用其他初始化函数，例如 traceinit 和 stackinit。

总的来说，mgcstack.go 文件中的 init 函数的主要作用是初始化全局变量，设置一些与调试相关的标志，并调用其他初始化函数，为垃圾回收器的正确执行做好准备。



### setRecord

setRecord函数是执行垃圾回收时用于跟踪各个栈信息的辅助函数。它的作用主要是设置一个gcWork标记（gcWork指向gcWorkBuf缓冲区，记录当前gc工作的上下文信息，包括待处理对象、扫描状态等），并将当前的goroutine的栈信息写入到gcMark的workbuf.stackAfter中，以便在之后的垃圾回收过程中，能够正确恢复上下文信息。

具体来说，setRecord函数的执行流程如下：

1. 设置gcWork标记为true，表示当前goroutine处于垃圾回收状态。

2. 获取当前goroutine的栈信息，并赋值给workbuf.stackAfter。

3. 将workbuf加入到待处理队列中，以便之后进行marking操作。

在进行垃圾回收时，runtime系统会依次遍历每个待处理的workbuf，执行marking操作，并将扫描状态以及待处理的对象等信息写入到gcWork中。这样，就可以利用gcWork中的信息来正确恢复各个goroutine的状态，从而保证垃圾回收的正确性。

总之，setRecord函数的作用是为了帮助runtime系统在执行垃圾回收时，能够正确跟踪和恢复各个goroutine的状态，从而保证整个垃圾回收过程的正确性和高效性。



### putPtr

在Go语言中，堆栈是一种很重要的数据结构。在堆栈上操作指针时，必须确保指针的正确性以避免内存泄漏。

putPtr函数是一个用于将指针添加到追踪列表的函数。它接收一个指针参数，然后将其添加到全局存储区内的列表中。该函数主要用于实现Go语言中的垃圾回收机制，以确保已经使用的指针都能被回收。

该函数在以下场景中被使用：

1. 当一个指针不再需要时，GC机制需要知道这个指针已经被引用了，以便不会将其作为不必要的垃圾回收。

2. 当堆栈不再需要保存一个指针时，堆栈需要知道该指针已经被释放，并将其从列表中删除，以避免重复释放和内存泄漏。

在实际使用中，putPtr函数是由Go语言框架调用的，程序员不需要直接调用该函数。



### getPtr

在mgcstack.go文件中，getPtr函数用于从一个指针地址中获取指向对象的指针。它的主要作用是在进行垃圾回收时，辅助标记root对象。

首先，我们需要了解一些关于垃圾回收的基本概念。在进行垃圾回收时，需要确定哪些对象是root对象。root对象是指那些可以被程序直接访问到的对象，如全局变量、堆栈中的对象等。通过标记root对象，垃圾回收器就能确定哪些对象是存活的，哪些对象需要回收。

在getPtr函数中，首先将指向一个指针的指针（ptr）强制转换为uintptr类型，然后通过与_PageMask按位与运算得到该指针所在的页的起始地址。通过 castType函数将指向uintptr的指针转换成一个指向任意类型的指针，从而得到实际的对象指针。最后，通过分别减去指针所在页的起始地址和实际对象的起始地址，得到指向对象的指针。

总之，getPtr函数的作用是将一个指向指针的指针转换为一个指向对象的指针，以供垃圾回收器标记root对象。



### addObject

在Go语言中，使用垃圾回收机制来管理内存。而mgcstack.go文件中的addObject()函数则是用来将新创建的对象添加到垃圾回收器中进行管理的。

addObject()函数主要有以下几个作用：

1. 分配一个空闲的slot来存储该对象的地址。

2. 将对象的地址存储到该slot中，以便垃圾回收器可以访问它并进行管理。

3. 将该slot添加到其类型的相关链表中，以便垃圾回收器可以定期遍历这些链表来扫描和回收不再使用的对象。

4. 如果分配的slot数量已经用完，则触发一次标记-清除的垃圾回收过程。

总之，addObject()函数是Go语言垃圾回收机制中一个非常重要的函数，它将创建的对象添加到垃圾回收器中进行管理，以确保程序使用内存的有效性和正确性。



### buildIndex

在Go语言的运行时系统中，mgcstack.go文件负责管理垃圾回收堆栈。其中，buildIndex函数是其中一个功能函数，作用是将一个堆栈的调用链转换为内存索引。

具体来说，buildIndex函数的输入是一段堆栈信息，其中记录了每次函数调用的信息，从而构成了整个调用链。该函数会将这段堆栈信息转换为内存索引，使其能够在运行时时进行快速查找和修改。

具体实现中，buildIndex函数会遍历堆栈信息中的每个调用帧，将其转换为一个对应的索引值，并计算出每个索引值在内存中的地址。最终，该函数将所有索引值和地址组成的映射关系保存下来，作为索引表。

这个索引表在mgcstack.go的其他函数中会被广泛使用，比如在扫描垃圾时判断是否为根对象，或者在查找指针时快速跳过一些不需要的对象等等。因此，buildIndex函数的作用在于构建这个索引表，为后续的垃圾回收操作提供基础。



### binarySearchTree

在编写并发程序时，经常需要使用锁或其他同步机制来保证正确性。这些同步机制的使用往往会导致内存泄漏、死锁等问题。因此，Go运行时实现了一个垃圾回收器（简称GC），以自动处理这些问题。

binarySearchTree（二叉查找树）是Go运行时中的一个数据结构，用于垃圾回收器的实现。在GC过程中，需要遍历所有活跃对象，并将非活跃对象标记为垃圾。为了实现高效的垃圾回收，Go运行时使用了二叉查找树来存储和管理这些对象。

在GC的第一阶段（标记阶段），GC会遍历所有根对象（如全局变量、堆栈等）并标记所有活跃对象。在第二阶段（标记终止阶段），GC会遍历所有对象，并将没有被标记的对象标记为垃圾。

为了高效地在二叉查找树中查找对象，Go运行时还实现了一些优化技巧，例如使用了指针压缩等技术，以减少二叉查找树的空间占用和访问时间。

总的来说，binarySearchTree这个函数实现了二叉查找树的各种操作，包括插入、删除、查找等，是Go运行时中非常重要的一个组件。



### findObject

findObject函数是Go语言中垃圾回收器的一部分，主要用于在给定的堆栈中查找一个对象的指针。它在垃圾回收器的Mark阶段中被调用。

具体来说，findObject函数接收三个参数：stk，stkTop和obj。其中，stk是当前堆栈的起始地址，stkTop是当前堆栈的栈顶地址，obj是要查找的对象的地址。

函数的主要作用是遍历堆栈中的每一个指针，直到找到指向obj的指针。如果遍历完整个堆栈仍然没有找到指向obj的指针，则说明obj不在堆栈中，它可能已经被垃圾回收器标记为可回收状态。

findObject函数在查找指针时会忽略一些不需要被垃圾回收器扫描的指针，例如指向栈内的本地变量或者函数参数的指针，以及指向全局变量或者常量的指针。

总之，findObject函数的作用是帮助垃圾回收器在堆栈中查找一个对象的指针，以便在Mark阶段中确定哪些对象是仍然被使用的，哪些对象可以被回收。



