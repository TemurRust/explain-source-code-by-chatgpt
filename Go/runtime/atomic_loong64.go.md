# File: atomic_loong64.go

atomic_loong64.go是Golang运行时中的一个文件，用于提供针对LoongArch64架构的原子操作函数。

LoongArch64是一种基于MIPS架构的64位处理器，主要使用在中国产的龙芯处理器中。Golang为了支持这种特殊的处理器，提供了一套针对LoongArch64的原子操作函数。

原子操作是多线程编程中很常见的操作类型，主要是为了避免多线程之间的竞态条件。在多个线程同时对一个共享变量进行读写操作的时候，如果不使用原子操作，则会出现数据不一致的情况。

Golang通过提供一系列的原子操作函数，来保证多线程之间对共享变量的访问是原子性的。atomic_loong64.go中包含了针对LoongArch64架构的一些原子操作函数，如：

- AddInt64(addr *int64, delta int64) int64：原子性地将64位整数加上delta，并返回结果
- SwapInt32(addr *int32, new int32) int32：原子性地将32位整数设置为new值，并返回原先的值
- CompareAndSwapInt64(addr *int64, old, new int64) bool：如果addr指向的变量值等于old，则将其设置为new值，并返回true；否则不进行修改，返回false

这些原子操作函数是Golang中并发编程必不可少的工具，能够避免多线程访问同一个共享变量时出现的问题，提高了并发程序的稳定性和性能。

## Functions:

### Xadd

在Go语言中，Xadd是一个原子操作，用于在原子级别对int64类型的变量执行“加”操作，相当于x += delta，其中x是变量，delta是增量。

atomic包提供了一些原子操作，这些操作是在多线程并发访问共享数据时使用的。atomic包中的操作是在硬件级别上实现的，这使得并发访问变得更加安全和高效。

在atomic_long64.go文件中的Xadd函数使用了硬件级别的CAS（Compare And Swap）指令，这个指令确保多个goroutine之间对同一变量的并发访问是安全的。Xadd函数适用于高度并发的程序，可以确保在并发访问变量时不会出现竞争条件。

Xadd函数的作用是原子性地对int64类型的变量进行加操作，相当于 x += delta。如果多个goroutine同时调用Xadd函数，则最终结果是所有goroutine对变量的操作都得到了正确的执行。这个函数非常重要，因为在并发访问共享资源时，必须对访问进行同步，以防止多个goroutine同时修改同一个变量的值，从而导致数据的不一致性或错误的结果。

在Go语言中，使用atomic包中的Xadd函数可以确保数据同步，避免竞争条件，从而实现高效的并发编程。



### Xadd64

在 Go 语言中，Xadd64 函数用于执行 64 位整型变量的原子加操作。原子操作是指不可被中断的操作，它的执行要么完全执行，要么完全不执行，不会出现执行了一部分被中断的情况。

Xadd64 函数的签名为：
```go
func Xadd64(ptr *int64, delta int64) (new int64)
```
其中，ptr 是指向 int64 类型变量的指针，delta 是要执行的加操作的值。函数返回执行加操作后的新值。

Xadd64 函数会先将指针 ptr 指向的变量的旧值取出来，然后将 delta 值加上去得到新值，最后将新值赋给变量并返回。由于整个过程是原子的，所以无论有多个 goroutine 同时调用 Xadd64 函数，都不会出现一个 goroutine 取到的旧值被其他 goroutine 修改后造成计算错误的情况。



### Xadduintptr

在 Go 语言中，atomic 包提供了一些原子操作的函数，用于多个 goroutine 并发访问共享变量时保证操作的原子性。atomic_load64.go 中的 Xadduintptr 函数是其中一个函数，其作用是原子地将指针或整数类型的值增加 delta，返回更新后的值。

该函数的声明如下：

```
func Xadduintptr(ptr *uintptr, delta uintptr) uintptr
```

其中，ptr 表示指向要增加的值的指针，delta 是要增加的值。返回值为增加后的结果。

该函数使用了处理器中提供的原子指令，可以确保对同一个变量的多个 goroutine 操作不冲突。这对并发访问共享变量的场景非常重要，否则可能会导致数据不一致或者出现竞争条件。该函数常用于实现无锁数据结构，例如链表、哈希表等，并发环境下需要保证操作的原子性。

需要注意的是，该函数可能会出现数据竞争，应该只在并发访问共享变量的场景下使用。另外，atomic 包中还提供了其他原子操作的函数，例如 CompareAndSwap、Load、Store 等，可以满足不同的需求。



### Xchg

atomic_long64.go文件中的Xchg函数是用于原子交换操作的。当需要在多个goroutine之间读写共享变量时，为了避免竞争条件，需要使用原子操作进行同步。Xchg函数允许原子地交换一个64位的整数值。

函数签名为：

```
func Xchg(val *int64, new int64) (old int64)
```

参数val是指向要进行原子交换的64位整数变量的指针，参数new是用来替换val的值的新值。函数返回之前val的旧值。

Xchg函数的实现使用了机器指令CAS，也就是比较并交换指令。CAS指令接受三个参数：内存地址、期望值和新值。如果内存地址中存储的值与期望值相等，则用新值替换它，并返回旧值。如果不相等，则什么也不做，返回当前值。

因此，Xchg函数的过程如下：

- 调用CAS指令，将val的地址作为内存地址参数，0作为期望值参数，new作为新值参数。
- 如果val的旧值为0，则说明交换成功，返回val的旧值。
- 如果val的旧值不为0，则说明有其他goroutine已经修改了val的值，继续执行CAS指令。

Xchg函数常用于实现锁机制和同步变量等操作，在并发编程中具有重要作用。



### Xchg64

Xchg64是一个用于交换64位整数值的原子操作函数。在多线程并发时，为了保证数据的正确性，需要使用原子操作来修改共享的数据。

Xchg64函数的作用是将一个64位整数值和另一个64位整数值进行交换，并返回旧的值。它的函数定义如下：

func Xchg64(ptr *int64, new int64) (old int64)

参数ptr是一个指向64位整数的指针，new是一个新的64位整数值，old是交换前ptr指向的旧值。所以，这个函数会将ptr指向的值和new进行交换，并返回交换前的值。

在实际应用中，Xchg64函数可以用于一个线程需要修改全局变量的值，而其他线程需要读取该值，此时就需要使用原子操作来保证线程安全。可以使用Xchg64函数将新值赋给全局变量，并返回旧值，其他线程就可以读取旧值，从而保证数据的一致性。



### Xchguintptr

在Go语言的运行时中，atomic_long64.go文件中的Xchguintptr函数用于原子性地交换一个指针类型的值。

具体来说，Xchguintptr函数将第一个参数的值与第二个参数的值进行交换，并将第一个参数的旧值返回。此操作是原子性的，也就是说在多线程环境下，多个线程可以同时调用Xchguintptr函数，但只有一个线程可以成功地完成交换操作。

这个函数的作用主要是在并发编程中，保证指针类型变量在多线程环境下的操作的原子性，防止出现数据竞争等问题。



### Load

在Go语言中，atomic.Long64类型提供了一种原子性的64位整数。atomic.Load方法用于原子性地获取atomic.Long64的值，用于避免并发读取时可能出现的问题。

具体来说，Load方法接收一个atomic.Long64类型的指针作为参数，返回一个int64类型的值。该方法会原子性地返回指针所指向的atomic.Long64中存储的值。

Load方法在实现时使用了内置的CPU指令实现原子性操作。在多线程环境中，由于该操作是原子性的，因此可以避免读取atomic.Long64时出现的竞争条件。

总之，atomic.Load方法用于原子性地读取atomic.Long64类型的值，确保多线程环境中可靠地获取该值。



### Load8

Load8函数在atomic_long64.go文件中实现，它的作用是原子化地加载一个int64类型的变量m的值，返回m的值作为函数的结果。

在Go程序中，多个goroutine同时访问共享变量时，可能会导致数据竞争问题。而原子操作是解决并发访问共享变量问题的一种经典方法。在原子操作中，对于每个共享变量，系统保证只有一个goroutine可以访问它，保证了并发交互的正确性。

Load8函数的具体实现是调用了内建函数runtime.atomicloadint64，而这个函数是在底层平台机器指令级别上实现的。这意味着获取int64类型变量的值不会被其他并发执行的goroutine所中断，并且它是无锁的。因此，Load8函数是安全且高效的。

总结一下，Load8函数的作用是获取int64类型变量的值，实现了原子读取的操作。这个函数可以确保不会发生数据冲突，因此，它是编写高度可并发程序的一部分。



### Load64

在Go语言中，有许多的并发编程的场景，因此需要使用原子操作实现对变量的读写，以保证并发安全。在runtime包中，提供了一系列原子操作函数，其中atomic.Load64用于原子地从64位整数指针指向的地址中获取值。

具体来说，函数签名为

```
func Load64(addr *int64) (val int64)
```

其中，参数addr是一个64位整数指针，val是返回值，表示从addr指向的内存地址中读取的64位整数的值。

使用atomic.Load64的好处在于，它能够保证原子读取，即在读取期间不会被其他goroutine修改，从而保证了并发安全。

在实际的使用中，通常使用atomic.Load64和其他的原子操作函数一起配合使用，例如在计数器的实现中，可以使用atomic.AddInt64实现对计数器的原子自增，而使用atomic.Load64则可以实现原子读取计数器的值。

总之，atomic.Load64的作用在于提供了对64位整数的原子读取操作，保证了并发安全。



### Loadp

在Go语言中，atomic.LoadPointer()用于读取原子指针，并返回原子指针的值。这个函数可以保证读取的原子指针的值是当前最新的值，并且在读取原子指针的过程中，其他goroutine无法修改原子指针的值。

在runtime/atomic_long64.go文件中，Loadp()函数是一个具有原子特性的原子指针加载器，用于加载原子指针的值，并返回原子指针的值。该函数通过调用atomic.LoadPointer函数来实现。

该函数主要用于原子指针的读取操作，可以保证读取的原子指针的值是当前最新的值，并且在读取原子指针的过程中，其他goroutine无法修改原子指针的值。这在多线程编程和并发编程中非常有用，可以在不使用锁的情况下保证数据的安全。

总之，Loadp()函数提供了一种高效且安全的方式来读取原子指针的值，可以在多线程编程和并发编程中使用，以保证数据的一致性和安全性。



### LoadAcq

LoadAcq函数是用于原子读取64位整数值的函数，并使用该函数保证在执行读取操作期间不存在其他线程发生了写入操作。这个函数是使用汇编语言编写的，目的是实现一种高效的方式来保证读取操作的原子性。

在并发编程中，可能会有多个线程同时访问相同的共享资源，例如共享变量或共享内存。这种情况下，如果多个线程同时对同一内存位置进行读取或写入操作，就会产生竞态条件（race condition）问题。为了解决这个问题，需要使用同步机制来保证并发访问的正确性和原子性。

在LoadAcq函数中，使用了“acquire”语义来保证读取操作的原子性和一致性。具体来说，acquire语义保证在执行读取操作之前，所有之前的内存读取和内存写入都已经完成了。这种方式确保了在执行读取操作期间不存在其他线程发生了写入操作，从而避免了竞态条件的出现。

由于LoadAcq函数是采用汇编语言编写的，因此它的执行速度非常快，可以在高并发场景下提供良好的性能表现。在实际应用中，LoadAcq函数可以被用来对共享变量进行安全的读取操作，适用于需要高并发支持的应用程序。



### LoadAcq64

atomic_long64.go中的LoadAcq64函数实现了原子读取64位整数的操作，使用了x86-64的Load Acquire指令，该指令保证在读取目标内存区域的值之后，CPU会强制从当前CPU缓存中刷新其他CPU缓存。

这个函数的作用是在多线程应用程序中，读取共享变量的值时确保线程安全。在并发访问共享变量时，读操作和写操作可能会发生交叉，如果采用普通的读取操作，那么就可能在读取数据的同时，发生写入的操作，导致读取到不正确的数据。

因此，为了避免这种问题，需要使用原子操作，也就是确保读取操作和写入操作的原子性，确保读取操作一定是在写入操作之后。LoadAcq64函数就是这样的一个原子函数，它能够确保在读取时，不会发生写入操作的交叉。



### LoadAcquintptr

LoadAcquintptr是一个函数原子加载一个uintptr值，并返回指针到该值。其中uintptr是一个无符号整数，大小足以容纳一个指针（即将指针地址转换为整数类型）。该函数有以下作用：

1. 原子加载uintptr值：LoadAcquintptr函数保证在并发环境中加载uintptr值是原子操作。这意味着当多个goroutine并发执行此函数时，它们不会同时访问该值，从而避免了竞态条件和数据竞争问题。

2. 返回指向uintptr值的指针：该函数返回一个指向uintptr值的指针，这意味着可以使用该指针在后续的代码中操作该值。这对于实现许多并发原语非常有用，例如锁和同步机制。

3. 用于实现其他原子操作：LoadAcquintptr函数是在runtime包中实现的，它是用于实现其他原子操作的基础。例如，在锁中使用CAS操作更新计数器时，必须使用LoadAcquintptr加载计数器的当前值（也就是操作系统级别的数字），CAS在此基础上进行比较。

总的来说，LoadAcquintptr是一个基础的原子操作API，它为不同简单且复杂的并发问题提供支持。在Go语言中，原子操作技术是高性能和高可用性并发编程的基石，而LoadAcquintptr作为原子加载操作的一部分，为Go提供了强大的并发原语支持。



### And8

在Go语言中，And8是一个原子操作（atomic operation），用于实现在并发环境下执行原子操作的功能。And8操作将一个int64类型的值与另一个int64类型的值按位与运算，并将结果存储回第一个值中。该操作会确保在并发环境中，对该变量的读写操作都是原子性的，从而避免竞争条件的出现，保证程序的正确性和稳定性。

具体来说，And8操作的作用是将变量（即第一个参数）的值和参与按位与运算的值（即第二个参数）进行按位与运算，并将结果存储回变量中。该函数执行的过程是原子化的，也就是说，在执行过程中不会被其他 goroutine 中断或干扰，从而避免出现数据竞争的情况。

在Go语言的标准库中，And8操作被广泛应用于多个包中，如sync/atomic、runtime等，用于实现并发控制、内存管理等功能。例如，在sync/atomic包中，And8操作可以被用来实现原子加减的功能。在runtime包中，And8操作通常被用来进行汇编锁的操作，从而实现锁的加锁和解锁操作的原子性。

总之，And8函数是Go语言中的一个原子操作，用于实现在并发环境下执行原子操作的功能。该函数可被广泛应用，用于实现并发控制、内存管理等功能，从而提高程序的性能和稳定性。



### And

在Go语言中，And是一种原子操作，用于将指定的位设置为0。atomic_long64.go文件中的And函数是用于64位原子操作的版本。

具体来说，And函数接受两个指针参数，分别为要操作的64位整数和要设置为0的位所在的位置。例如，如果想将第3位设置为0，则需要将第二个参数设置为2（因为Go语言中的计数从0开始）。

And函数使用了底层的CPU指令来实现原子操作，以确保在多线程环境下不会出现竞争条件。这使得And函数非常适合在高并发场景下对共享数据进行原子更新。

总之，And函数的作用是让程序员能够以原子方式将一个64位整数中指定的位设置为0，从而避免竞争条件和其他线程之间的数据冲突。



### Or8

在Go语言中，atomic包提供了原子操作，即可以在不需要锁定整个数值的情况下，对访问它的多个Goroutine并发读写的变量进行安全的并发访问，从而避免了数据竞争的问题。atomic包中包含了许多函数，其中的Or8函数则是一种原子位操作，用来对一个变量进行按位或操作。

具体来说，Or8函数的作用是将传入的值v和变量addr的值按位或运算，并将结果存储回变量addr中。这个函数首先会尝试使用Go语言内置的原子操作指令，如果CPU支持的话，可以快速地完成操作。否则，它会使用一些其他的方法模拟原子操作，以确保并发性和正确性。

使用Or8函数时，需要注意以下几点：

1. 传递给Or8函数的值v必须是8位的无符号整数类型（uint8）。

2. 变量addr必须是一个指向8位无符号整数类型的指针。

3. 如果需要在多个Goroutine之间共享访问相同的变量，需要先对这个变量使用原子操作进行初始化。

总的来说，Or8函数是一种原子位操作，它可以让你在对一个变量进行并发读写时，避免了数据竞争的问题，从而保证了程序的正确性和稳定性。



### Or

在 Go 语言中，atomic_or_uint64 函数原子地将给定的无符号 64 位整数与指定的位按位逻辑或。该函数可以在多个协程之间安全地更新共享变量，这意味着多个协程可以同时操作该变量，而不会产生竞态条件。这是通过使用原子操作技术实现的，该技术使用 CPU 的原子指令，确保所有操作都在单个 CPU 指令周期内完成。

更具体地说，Or 函数会将 x 和 y 两个参数进行按位逻辑或操作，并返回结果。在这个过程中，x 和 y 的值都不会被修改。实现时，Or 函数通过调用底层的 atomic.OrUint64 函数来实现原子性。atomic.OrUint64 函数会将存储在某个内存地址中的 64 位整数与指定的位进行按位逻辑或操作，并使用 processorID 和 order 这两个参数进行控制和同步。processorID 参数指示每个 CPU 的 ID，从而确保在多个 CPU 上执行操作时不会出现冲突。order 参数指示操作的顺序，并确保写入顺序的正确性。

总而言之，Or 函数是用于原子操作的的一个函数，它可以安全地在多个协程之间访问和更新共享的变量。在 Go 语言中，原子操作非常重要，因为它们可以避免访问共享变量时出现竞争条件，从而增加程序的并发性和可靠性。



### Cas64

Cas64是一个用于执行原子比较并交换的函数，用于保证操作的原子性和一致性。它的作用是在多线程或并发访问的情况下，保证操作的原子性和正确性。在并发环境中，多个线程可能同时读写同一个共享变量，如果不保证原子性，将会导致数据的不一致和错误的结果。

具体来说，Cas64函数通过比较32位整型，判断给定内存地址中的值是否与给定旧值参数相等。如果相等，则将新值参数存储到该内存地址中，返回真；否则，不做任何处理，返回假。这个操作是原子的，也就是说，在执行这个操作时，没有其它线程能够同时访问相同的内存地址。

此外，Cas64函数还会保证所有操作的顺序，防止并发访问出现相互扰乱的情况。因此，它被广泛应用于多线程并发编程、同步互斥、锁的实现等领域。



### CasRel

`CasRel`在go/src/runtime/atomic_long64.go文件中是一个基于汇编实现的函数，它的作用是在原子性地将一个指针的值与期望的值比较，如果相等，则将新值赋值给指针并返回真。

在具体实现中，`CasRel`函数使用了`CAS`（Compare-And-Swap）指令来保证原子性。`CAS`指令是一种计算机指令，它用于在多处理器环境下实现原子操作。

在使用时，首先需要将存储地址、期望值和新值作为参数传递给`CasRel`函数。`CasRel`函数将使用`CAS`指令来比较存储地址中的值是否等于期望值。如果相等，则将新值存储到该地址并返回真。如果不相等，则返回假。

`CasRel`的作用是实现原子性的存储地址与指定值之间的比较和交换。这个功能在多线程或多协程并发编程中非常重要，因为它可以防止数据竞争和并发问题。



### Store

在Go语言中，atomic_long64.go文件中的Store函数是用于将一个int64类型的值存储到指定的内存地址中，并保证该操作的原子性，即如果多个goroutine同时调用Store函数来存储一个值，每个goroutine都能看到存储的最新结果，而不会出现数据竞争问题。

具体来说，Store函数包含一个指向int64类型的指针ptr和一个要存储的int64类型的值val，其作用是将val的值存储到ptr指向的内存地址中，并返回旧的值。这个旧的值可以在之后的操作中使用，比如与新的值进行比较和计算等。

在实现上，Store函数调用了内部的atomic.StoreInt64函数来完成实际的存储操作，该函数使用了底层的硬件指令来保证操作的原子性。同时，由于Go语言支持多核并发，Store函数还使用了一些技巧来保证多处理器并发执行时的正确性。比如在进行存储操作时，会先对内存进行锁定，防止其他goroutine修改该内存区域。在存储操作完成后，锁定会被释放，其他goroutine才能再次进入该内存区域进行操作。

总之，Store函数是用于原子存储int64类型值的函数，在多线程程序中使用非常广泛，可以保证不会出现数据竞争问题。



### Store8

Store8是一个函数，用于将一个int64类型的值原子地存储到指定的内存地址中。这个函数被用于实现Go语言中的原子操作，因为Go语言在多线程操作中需要保证数据的一致性和可靠性，所以需要使用原子操作来避免多线程操作中出现的竞态条件。

在实现中，Store8函数首先会检查指定的内存地址是否对齐，如果未对齐则会调用weakstore函数进行存储，否则会使用lock指令(CAS指令)实现原子存储操作。如果当前线程的CPU支持内联汇编，则Store8函数会进一步使用内联汇编命令实现lock指令(CAS指令)。

在多线程操作中，如果多个线程同时尝试修改同一个变量值，就会产生竞态条件，因为多个线程修改同一个变量时会产生互相影响的问题。为了避免这种竞态条件，需要使用原子操作来保证多线程操作中的数据安全性。

Store8函数的作用是在多线程操作中，确保数据的一致性和可靠性，保证多线程操作中数据的修改是原子性的，避免了数据在多线程操作中出现竞态条件的问题。



### Store64

Store64函数是Go语言中用于给64位整数类型赋值的原子函数。在并发场景中，多个goroutine并发操作共享的原子变量很容易出现竞争问题。Go语言中提供了一系列的原子函数用于解决这个问题，其中就包括Store64函数。

Store64函数的作用是给指定的64位整数类型变量赋值，并且该赋值操作是原子的，即多个goroutine并发执行该函数时，只有一个goroutine能够成功执行，并且赋值的结果是可见的。

Store64函数定义如下：

func Store64(addr *int64, val int64)

其中，addr是待赋值的64位整数类型变量的地址，val是待赋的值。该函数会原子地将val赋值给指定的64位整数类型变量。

Store64函数是基于硬件的compare-and-swap (CAS)操作实现的。在执行该函数时，会将当前的64位整数类型变量值和待赋值的val进行比较，如果两者相等，则直接将val赋值给该变量；否则的话，说明该变量值已经发生了变化，就会重新执行比较和赋值的操作，直到成功执行为止。



### StorepNoWB

StorepNoWB函数的作用是将指针p的值存储到addr中，并且不会触发write barrier（写屏障）操作。

在Go语言中，通过write barrier操作来维护内存中的指针关系，这个操作会在指针值被修改时自动触发，并且保证了所有相关的指针都被正确处理，从而防止了Go语言程序出现内存泄漏或指针错误等问题。

但是，在一些特定的情况下，程序员需要手动地控制write barrier的触发时机，以提高程序的性能。这时，就可以使用像StorepNoWB这样的函数来实现这个目的。

具体的实现过程是，StorepNoWB函数会通过原子操作将指针p的值存储到addr中，并且不会触发write barrier。这样，在一些特殊的应用中，就可以避免频繁地触发write barrier操作，从而提高程序的性能。不过，需要注意的是，这个操作只适用于特定的场景，一般情况下，应该遵循Go语言的内存管理规则，使用write barrier来维护指针关系。



### StoreRel

StoreRel是一个原子操作函数，用于在指定位置（内存地址）存储一个新的int64类型的值。它使用了一个特定的内存栅栏来保证在存储之前，所有的内存读取操作都已经完成，而在存储之后，所有的内存写操作也已经完成。

在这个特定的context下，StoreRel的作用有以下几个方面：

1.插入内存栅栏：StoreRel会在存储之前插入一个内存栅栏，来确保在存储之前，所有的读操作都已经完成，而在存储之后，所有的写操作也已经完成。这样可以保证存储的结果是完整的，并且所有其他线程也能够读取到正确的结果。

2.原子操作：StoreRel是一个原子操作，因此可以安全地在并发环境下使用。它可以确保存储操作在多个线程中同步进行，并且不会出现竞态条件。

3.无锁操作：StoreRel是一个无锁的操作，因为它不需要使用任何锁来同步线程。相反，它使用了硬件级别的原子指令来实现同步的效果。这使得StoreRel操作速度非常快，因为没有锁竞争的开销。

总的来说，StoreRel函数在实现高效、并发、原子性的内存操作时非常有用。它能够确保存储的结果是正确的，且能够在多个线程中使用。



### StoreRel64

在Go语言中，`atomic.LoadInt64`、`atomic.StoreInt64`等操作都是原子操作，但对于某些场景，需要使用更高效的原子操作方式。因此，在Go语言中提供了对于64位整数的特殊原子操作方式，其中就包括`StoreRel64`。

`StoreRel64`的功能是将给定的64位整数值存储到目标位置，并且使得存储操作“发布”（publish），即保证之前的所有内存读写操作的结果对于其他CPU核心可见。

具体来说，在处理器内部，数据通常都是缓存在内部缓存中的，并不会直接写入到内存中。因此，当使用普通的写入操作时，写入值会先存储到缓存中，只有在某个点上，处理器才会将缓存中的值写入到内存中，这时其他CPU核心才能读到这个更新后的值。

而使用`StoreRel64`可以将写操作的“发布”时间提早，即在写入值时就使得之前的所有内存读写操作对于其他CPU核心可见，这样其他CPU核心就可以更快地观察到变化。`StoreRel64`通过处理器指令来实现这个功能，从而提升了写入操作的性能。



### StoreReluintptr

在Go语言中，atomic包主要提供了一些原子操作函数以实现并发安全。其中的StoreReluintptr函数定义如下：

```go
func StoreReluintptr(addr *uintptr, val uintptr)
```

这个函数的作用是将一个uintptr类型的值存储到指定地址的uintprt类型的变量中，并保证以一种“release memory order”内存顺序存储，即指定地址之前的所有存储都在存储该值之前完成。

在此处，“release memory order”是指内存顺序，通过该内存顺序，可以保证StoreReluintptr函数所写入的值能够被其他进程或线程立即并正确访问。在多个进程或线程同时更新同一个变量的时候，将多个操作序列化以保证原子性就是通过这个内存顺序实现的。

总的来说，StoreReluintptr函数的作用是实现原子性操作以避免并发竞争。通过使用该函数，可以将一个uintptr类型的值安全地存储到指定的内存地址中。



