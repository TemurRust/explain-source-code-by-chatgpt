# File: pagetrace_on.go

文件名为pagetrace_on.go的文件是Go语言运行时的一个辅助工具文件。其作用是开启Go程序的分页跟踪功能，用于跟踪Go程序中虚拟内存的使用情况。

分页跟踪是指统计程序中不同页（一般为4KB）的使用情况，包括每个页的读写情况、缺页情况等，从而帮助我们更好地了解程序的内存使用情况、性能等方面的问题。

该文件中定义了开启和关闭跟踪功能的相关方法，以及一些数据结构和记录分页信息的代码实现。同时，该文件还提供了一些用于分析跟踪结果的函数，包括输出代码行级别的跟踪信息、输出程序的镜像信息等。这些函数可以帮助开发者更精确地定位程序中的内存使用问题，以及对程序进行优化。

总之，pagetrace_on.go文件是Go语言运行时的一个重要辅助工具，对于内存使用分析和性能优化等方面都有着重要作用。




---

### Var:

### pageTrace

pagetrace_on.go文件中定义了一个名为pageTrace的全局变量，它的类型是bool。这个变量的作用是控制程序是否启用对内存分配情况的跟踪追踪。

当程序运行时，如果pageTrace被设置为true，则会在内存分配和释放的时候生成跟踪事件，可以通过调试工具查看内存使用情况，这对于分析诊断程序的内存使用情况非常有用。

如果pageTrace被设置为false，程序将不会生成任何跟踪事件。因此，这个变量的设置可以直接影响到程序的执行效率和内存使用情况。

总之，pageTrace变量是runtime包中用于控制内存跟踪功能开启或关闭的一个开关变量，它可以帮助程序开发者分析和诊断程序的内存分配情况。






---

### Structs:

### pageTraceEventType

在go/src/runtime/pagetrace_on.go文件中，pageTraceEventType是一个枚举类型，它定义了一个事件的类型，这些事件类型被用来跟踪和记录运行时中发生的页面内存事件。

具体来说，pageTraceEventType定义了以下5种页面事件类型：

1. pageAlloc: 表示一个page被分配出去；
2. pageFree: 表示一个page被释放掉了；
3. pageMark: 表示一个page被标记为堆内存；
4. pageUnmark: 表示一个page被标记为非堆内存；
5. pageScan: 表示一个page被扫描过，这个事件类型通常用于GC过程中。

这些事件类型的作用就是帮助开发人员跟踪和记录运行时内存分配的情况，从而更好地了解程序的性能问题和调试程序。当需要进行内存优化和性能优化时，可以通过这些事件类型来分析程序的内存分配情况和使用情况，从而找出性能问题，进而进行优化。



### pageTraceEvents

在Go语言的运行时系统中，pagetrace_on.go文件中的pageTraceEvents结构体用于记录在Go程序运行时的内存分配情况。该结构体中包含了一些字段，用于表示内存的分配方式、分配的大小、分配的时间等信息，从而可以帮助开发人员进行程序的调试和优化。

具体来说，pageTraceEvents结构体中包含以下几个字段：

- Type：表示内存分配的类型，可以是堆内分配（HeapAlloc）、堆外分配（StackAlloc）、栈分配（StackGuard）、GC标记等不同类型。

- Size：表示内存分配的大小，以字节为单位。

- Stack：表示内存分配所在的调用堆栈。

- Time：表示内存分配的时间戳，以纳秒为单位。

在Go程序运行时，每次进行内存分配时，都会生成一个pageTraceEvents结构体来记录这次分配的相关信息，然后将其添加到一个全局的链表中。这样，在程序运行结束后，开发人员就可以获取到完整的内存分配记录，从而进行程序的分析和优化。

需要注意的是，为了减少内存使用和性能开销，在默认情况下，Go程序并不会记录所有内存分配的信息。而是通过设置GODEBUG环境变量中的"allocfreetrace=1"来启用分配追踪功能，从而生成pageTraceEvents结构体，并进行记录。因此，在进行调试和优化时，需要注意启用分配追踪功能，并确保生成的pageTraceEvents结构体中包含了所需的信息。



### pageTraceBuf

在Go语言的运行时中，pagetrace_on.go文件定义了一个用于跟踪内存分配和释放的功能，这个功能被称为Page Trace。Page Trace可用于分析程序的内存使用情况，找出内存泄漏等问题。

在这个文件中，定义了一个名为pageTraceBuf的结构体，它表示内存分配事件或释放事件的信息。pageTraceBuf结构体的定义如下：

```go
type pageTraceBuf struct {
    stkID   uint64 // 校验值
    typ     uint8  // 事件类型：分配/释放
    spanIdx uint16 // 所属span在mheap_.allspans[]中的索引
    npages  uint16 // 分配/释放的页数
}
```

这个结构体有四个字段：

1. stkID：一个随机生成的值，用于在跟踪内存使用的过程中区分不同的栈帧。
2. typ：事件类型，它指示这个结构体表示的是一个内存分配事件还是一个内存释放事件。其中，0表示分配事件，1表示释放事件。
3. spanIdx：这个事件所对应的span在mheap_.allspans[]中的索引。
4. npages：这个事件分配/释放的页数。

pageTraceBuf结构体主要用于在Page Trace过程中收集内存分配和释放事件的信息。每当发生一个内存分配或释放事件时，会创建一个pageTraceBuf结构体对象，并将其保存到pageTrace的缓冲区中。在程序需要分析内存使用情况时，可以从缓冲区中获取保存的pageTraceBuf结构体，并根据其中的信息进行分析。



## Functions:

### pageTraceAlloc

在 Go 中，每个 goroutine 都有一个私有的栈空间，当一个 goroutine 申请内存时，Go 运行时会向操作系统请求一些虚拟内存。这些虚拟内存页（Page）可能留在物理内存中，也可能在需要时由操作系统临时分配给程序。当程序运行时，其内存分配模式可能会带来大量的虚拟内存页分配和释放，这可能会成为性能瓶颈。为了减少内存分配的开销，Go 在运行时进行了一些优化，其中一项是 "Page Trace"。

具体来说，Go 在运行时会维护一份当前系统内存样式的 page trace，即一个关于当前程序哪些内存页被占用和哪些被空闲的记录。当程序需要申请或者释放内存时，Go 运行时会通过page trace来查找合适的虚拟内存页，而不是每次从操作系统中申请新的内存页或者进行内部碎片整理。

在 pagetrace_on.go 这个文件中，pageTraceAlloc 函数就是用来开启 Page Trace 功能的。当程序调用此函数时，会通过调用 runtime 包下的 startTrace 函数来开启 page trace。

总的来说，Page Trace 可以提升 Go 程序的内存分配性能，从而减少内存分配操作带来的性能影响。



### pageTraceFree

pagetrace_on.go文件中的pageTraceFree函数用于在程序运行时跟踪相关内存分配和释放的情况。具体来说，该函数会在释放一个页面时将该页面的信息记录到pageTraceFreeList中，包括页面的大小、地址等信息。当调用pageTraceOutput函数时，该函数会将pageTraceFreeList中的所有页面信息输出至标准输出流中，输出的信息包括页面的大小、地址等信息，通过这些信息可以帮助程序员进行内存分析和调试。

该函数可以帮助程序员跟踪内存的使用情况，发现内存泄漏和内存使用不当等问题。对于大型程序来说，内存管理是非常重要的一部分，使用该函数可以很好地帮助程序员进行内存管理工作，提高程序的性能和稳定性。

总之，pageTraceFree函数是一个非常有用的工具函数，可以帮助程序员进行内存分析和调试，提高程序的性能和稳定性。



### pageTraceScav

在Go语言中，pageTraceOn.go是runtime包中的一个文件，pageTraceScav是其中的一个函数。这个函数的作用是记录标记-清除垃圾回收器的操作。

在Go语言中，垃圾收集器负责自动回收不再使用的内存，以降低内存泄漏的风险和缓解内存不足的问题。标记-清除垃圾收集器是一种垃圾收集技术，它包含两个阶段：标记阶段和清除阶段。

在标记阶段，垃圾收集器会遍历堆中所有的对象，并将被引用的对象标记为活跃对象。在清除阶段，垃圾收集器会清除堆中没有被标记的垃圾对象。通过使用pageTraceScav函数，可以记录垃圾收集器的操作，以便进行调试和优化。

pageTraceScav函数会被调用两次，一次在标记阶段之前，一次在清除阶段之后。在标记阶段之前，pageTraceScav函数会清空所有的标记，从而准备开始下一轮垃圾收集。在清除阶段之后，pageTraceScav函数会记录所有被清除的页面，以便在下一轮垃圾收集时跳过这些页面，从而提高垃圾收集的效率。

总之，pageTraceScav函数的作用是记录标记-清除垃圾收集器的操作，以提高垃圾收集的效率并进行调试。



### pageTraceEmit

pagetrace_on.go文件是Go语言运行时的一个文件，其中的pageTraceEmit函数的作用是向内存跟踪缓冲区中发出一个跟踪事件。每个事件都记录了一个内存访问的详细信息，包括时间戳、内存地址、访问类型（读或写）以及线程ID等。

跟踪事件是用于调试分析Go程序的强大工具，它可以帮助开发人员快速定位内存访问的问题，如内存泄漏、内存竞争等。在生产环境中，跟踪事件主要用于诊断性能问题，例如高速缓存未命中的情况下，可以通过跟踪事件快速找到瓶颈所在，从而对应用程序进行优化。

pageTraceEmit函数的实现依赖于操作系统提供的访问控制功能，可以在跨越不同线程和进程的跟踪事件之间保持同步。跟踪事件是异步写入到文件中的，因此在高负载下，可能会丢失部分跟踪事件。为了尽可能减少这种风险，Go运行时将跟踪事件数据缓冲在内存中，并定期将其写入文件。

在Go语言程序中，可以使用runtime包的SetCPUProfileRate函数来启用跟踪事件，并设置采样频率。可以通过运行go tool trace来分析跟踪事件文件，从而更好地理解Go程序的行为。



### writePid

writePid函数是pagetrace_on.go文件中的一个函数，用于将当前进程的pid写入文件。

在runtime的pagetrace模式下，该模式用于跟踪内存页面的使用情况，以便进行性能优化和调试。当程序进入pagetrace模式后，会在当前进程的工作目录下创建一个名为"trace.pid"的文件，用于记录当前进程的pid。如果当前进程被终止，则该文件也会被删除。

这个函数的作用就是将当前进程的pid写入这个"trace.pid"文件中，以便在以后进行相关操作时可以快速地找到该文件，如果这个文件不能打开，函数会直接panic终止程序。

总之，writePid函数的作用就是在pagetrace模式下，记录当前进程的pid，以便进行性能优化和调试。



### writeSync

在`go/src/runtime/pagetrace_on.go`文件中，`writeSync()`函数是一个类似于日志文件的写入操作。它会在内存分配和释放时将诊断信息写入文件，在服务停止后，开发人员可以读取日志文件以了解程序的运行情况。

具体来说，该函数会在程序运行时，每当发生内存分配或释放操作时，将对应的信息与当前时间戳同时写入到磁盘上的日志文件中，以便于开发人员后续查看。在调试和优化程序时，这些信息能够帮助开发人员更快地找到程序性能瓶颈以及内存分配的问题。

此外，`writeSync()`函数还在每100ms重新加载计算机的运行进程，以确保即使发生了不可预料的故障或运行时错误也可以获取全部信息并且不会丢失记录。

总之，`writeSync()`函数的主要作用就是在程序运行时将内存分配和释放等信息写入日志文件，在调试和优化程序时提供分析标准和便利。



### writeEvent

pagetrace_on.go中的writeEvent函数是用于记录page trace事件的函数。在应用程序运行时，操作系统会将不同的虚拟内存区域映射到不同的物理内存页面上。当一个虚拟内存页面被访问时，在page trace中就会记录这个事件，包括虚拟内存地址、物理内存地址以及时间戳等信息。

writeEvent函数的具体作用是向page trace输出文件中写入事件信息。在该函数中，会使用PageTraceWriter对象向page trace文件中写入事件信息。PageTraceWriter对象是一个用于将事件信息写入文件的对象。每个事件信息都包括事件类型、事件时间戳以及其他相关信息。

writeEvent函数的实现比较简单，它只需要将事件信息写入到PageTraceWriter对象中即可。在写入事件信息之前，该函数还会对事件类型进行检查，以确保不会向page trace文件中写入无效的事件信息。

总的来说，writeEvent函数的作用是将page trace事件信息写入到page trace文件中，这样就可以通过分析page trace文件来了解应用程序的执行情况，帮助应用程序开发人员找到应用程序的性能瓶颈或者其它问题。



### flush

在Go语言中，pagetrace_on.go文件中的flush()函数用于将当前的跟踪记录写入到指定的文件中。该函数是在页面跟踪功能启用时调用的。

具体来说，当启用了页面跟踪功能后，程序会在内存中维护一个记录当前页面信息的数据结构，可以通过调用flush()函数将这些信息写入到指定的文件中，以便后续进行分析和调试。

在函数实现中，flush()函数会先获取当前的跟踪记录，然后将其写入到文件中。在写入文件时，会使用类似缓存的方式，将跟踪记录先写入到缓存中，当缓存达到一定的大小或者一定的时间间隔后再将其写入到磁盘中，以提高写入的效率和减少磁盘IO的频率。

总之，flush()函数的作用是将内存中的页面跟踪记录写入到文件中，以便后续进行分析和调试。



### initPageTrace

initPageTrace函数是在程序启动时被调用的初始化函数，主要用于设置golang运行时的page trace（页面跟踪）功能。页面跟踪是一种性能分析工具，可以记录程序中每个内存页的使用情况，进而改善程序的内存分配和使用，提高程序的性能。

具体来说，initPageTrace函数会做以下几件事情：

1. 向golang运行时系统注册一个名为"pagetrace"的flag，用于开启或关闭页面跟踪功能。

2. 注册一个名为mProf_Prefix的环境变量，用于设置程序运行时输出文件的前缀，默认为"mprof".

3. 注册一个名为spintime的flag，用于设置自旋锁等待时间的阈值，默认是50微秒。

4. 将page_track_enabled设置为false，表示页面跟踪功能默认关闭。

5. 在golang运行时结束时，将写入页面跟踪记录的函数记录存储到文件中以便后续分析。



### finishPageTrace

在Go语言中，runtime包是一个非常重要的包，它提供了与Go程序的底层操作相关的函数和类型，其中包括内存管理、调度、GC等等。pagetrace_on.go文件是runtime包中的一个文件，其中的finishPageTrace函数是一个用于结束页跟踪的函数。

页跟踪是一种在内存管理中使用的技术，它用于跟踪页面的使用情况。在操作系统中，内存是以页面的形式进行管理的，一个页面通常是4KB大小，它是内存中最小的可分配单元。页跟踪可以帮助我们了解内存的使用情况，识别内存泄漏等问题。

在Go语言中，我们可以通过启用页跟踪来跟踪程序的内存使用情况。这可以通过设置环境变量 GODEBUG=allocfreetrace=1 来实现。一旦启用了页跟踪，Go程序就会记录所有内存分配和释放事件，并将其记录到trace文件中。

finishPageTrace函数的作用是结束页跟踪，它会在程序退出时自动调用。它的主要作用是将页跟踪记录的信息写入trace文件中，与此同时，trace文件会被关闭并清空。当我们需要分析程序的内存使用情况时，可以使用tools/pprof工具来读取trace文件并进行分析。这些信息可以帮助我们找出内存使用不当的地方，加快程序的性能，减少内存泄漏等问题。



### writeFull

在pagetrace_on.go文件中，writeFull是一个用于向文件中写入字节序列的函数。其功能是将给定的字节序列完整地写入到指定的文件描述符中。如果writeFull函数返回的错误不为nil，则表示写入过程中出现了错误。

该函数的定义如下：

```
func writeFull(fd uintptr, p []byte) error {
    for len(p) > 0 {
        n, err := syscall.Write(fd, p)
        if err != nil {
            return err
        }
        p = p[n:]
    }
    return nil
}
```

writeFull函数的实现非常简单。它使用syscall.Write系统调用将字节序列p写入到指定的文件描述符fd中。如果写入过程中发生错误，则会立即返回错误；否则，它会持续写入字节直到所有的字节都被写入完成为止。如果成功写入所有字节，函数将返回nil。

在pagetrace_on.go文件中，writeFull函数通常被用于将调试信息输出到文件中。由于调试信息需要记录非常详细的信息，因此使用writeFull函数可以确保所有字节都被完整地写入文件中。



