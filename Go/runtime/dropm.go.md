# File: dropm.go

dropm.go文件的主要作用是为了在Goroutine中释放M(机器)。Goroutine是Go语言最重要的并发机制，但是在实现并发时需要考虑如何合理地分配和释放资源，其中之一就是M的管理。

Go中的每个Goroutine都运行在一个M上，而M则由系统的机器资源（如线程、堆栈、寄存器等）承载。在Goroutine完成其任务后，M也需要被释放以便其他任务继续执行。

dropm.go文件中的函数dropm()被用于从Goroutine中释放M。该函数内部包含了一系列逻辑来释放M，并将Goroutine重新放回到等待队列中以供下次使用。

具体来说，dropm()函数首先会将当前Goroutine的状态设置为等待状态，并通过park()函数将Goroutine放到等待队列中。然后，它会释放当前线程所绑定的M，以便其他任务可以运行在同一线程上。

在M被释放后，如果有其他Goroutine等待状态，系统会尝试唤醒其中一个Goroutine并让它重新使用之前被释放的M来运行。这种将M交替地分配给不同的Goroutine的方式可以有效地提高并发效率和性能。

在Goroutine结束时调用dropm()函数从而释放M对于Go语言来说是非常重要的，它可以避免系统资源的浪费和竞争冲突，并且提高了程序的并发性和可扩展性。




---

### Var:

### savedM

dropm.go这个文件是runtime包的一部分，它定义了用于管理goroutine的机制。savedM是该文件中的一个变量，它的作用是保存当前的M（machine），即操作系统对goroutine的执行上下文进行抽象的结构。

在goroutine的执行中，M是与操作系统直接交互的唯一实体，它负责调度和执行goroutine。在一些特殊情况下，例如goroutine死锁或者调度器被阻塞时，就需要在M之间进行转移。这个时候就需要使用savedM。

具体来讲，当一个M被标记为可回收的时候，通过函数dropm()释放它，将它与当前正在运行的M（当前M）分离。在这个过程中，会将当前M的状态保存到savedM中，并将当前M设置为空，这样可以让其他M执行。

当dropm()函数执行完成后，savedM就会被保存在全局变量sched.savedM中，等待下一次需要使用的时候再使用。

总的来说，savedM的作用是保存当前M的状态，让其他M来代替它执行调度，以确保goroutine的无阻塞运行。



## Functions:

### init

在 Go 语言中，init 函数是用来初始化程序的。具体地说，init 函数是在 main 函数之前自动被调用的。这个函数可以用于一些初始化操作，比如创建一些数据结构、打开文件等等。

在 dropm.go 文件中的 init 函数是用于初始化调度器中的 goroutine



### GoCheckM

GoCheckM函数是在运行时管理Goroutine的函数，其主要作用是检查当前是否有m（machine）可以被分配给Goroutine运行。代码中通过不断尝试从G队列（可运行却未运行的Goroutine队列）中获取Goroutine并执行，如果G队列为空则会检查当前是否可以新建一个m，如果可以则新建并提交到m队列中。如果当前m数量已经达到了最大值，则会阻塞并等待。GoCheckM函数在运行时经常被调用，用于监控资源的分配并保持所有Goroutine的高效执行。



### EnsureDropM

EnsureDropM函数的作用是确保当前线程释放它自己所持有的M（machine）资源。

在Go语言中，每一个goroutine都必须运行在一个M上面。M是Go运行时对操作系统内核线程的一种抽象，它负责调度goroutine的执行，以及执行垃圾回收等任务。

在某些情况下，一个线程需要释放它所持有的M资源，例如当一个线程持有多个M资源时，需要释放一些M资源以防止资源的浪费；或者当一个线程因为某些错误无法继续执行时，需要释放它所持有的M资源，以免资源被浪费。

EnsureDropM函数的主要作用就是在确保当前线程持有至少一个M资源的情况下，立即释放该资源，并将当前线程的状态置为Waiting，并且阻塞当前线程等待其他线程唤醒。

具体而言，EnsureDropM函数分为两个部分。第一部分是检查当前线程持有的M资源数量是否大于1，如果是，则将其中一个M资源释放掉。第二部分是将当前线程置为Waiting状态，并等待其他线程唤醒。

总之，EnsureDropM函数是Go运行时的一种保护机制，用于确保线程持有的M资源得到正确的释放，同时防止资源的浪费。



