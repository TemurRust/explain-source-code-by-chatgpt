# File: mgcwork.go

mgcwork.go是Go语言的运行时系统中的一个文件，主要负责管理垃圾回收器（GC）的工作。具体来说，它包含了以下几个方面的功能：

1. GC Worker的管理：GC Worker是负责进行垃圾回收的工作线程。mgcwork.go中维护了一个全局的GC Worker队列，用于管理这些Worker的创建、销毁和调度。

2. 标记和清理：mgcwork.go中的函数通过用于标记和清除垃圾的算法，实现了Go语言中的并发垃圾回收机制。其中包括对每个对象的标记，以及对未标记的对象进行清理的操作。

3. 分配器管理：Go语言的运行时系统中包含了一个内存分配器，用于动态分配内存。mgcwork.go中的函数管理了这个分配器的工作，包括分配对象的大小、对其进行对象复制等操作。

4. 对象移动：在标记流程中，有时需要将存活的对象从一个内存区域移动到另一个内存区域，以便于GC的清理工作。mgcwork.go中提供了相关的函数，用于实现这一操作。

总之，mgcwork.go是Go语言垃圾回收调度器的核心实现，通过对Worker队列、标记和清理、分配器和对象移动等方面的管理，实现了高效的垃圾回收机制，保障了Go语言应用程序的稳定性和可靠性。




---

### Structs:

### gcWork

gcWork结构体是Go语言垃圾收集器的一个重要组成部分，它用来表示垃圾收集器的工作状态，主要包括以下几个字段：

- wbuf1：用于缓存待处理的对象。
- wbuf2：用于缓存待处理的对象，更换缓存区时可以减少锁的使用。
- bytesmarked：标记对象的总字节数。
- victim：标记队列中当前正在处理的对象。
- flushedIdx：清扫时，flushIdx代表从哪个位置开始清扫。
- minbatches：最小的清扫批次数，用于调整清扫的强度。

gcWork结构体的主要作用是为垃圾收集器提供一个工作环境，以便它可以更高效地进行垃圾回收。通过维护待处理对象的缓存，减少锁的争用，利用并发清扫等手段提高回收效率，gcWork结构体可以优化垃圾回收的性能，并提供更好的用户体验。



### workbufhdr

workbufhdr是一个结构体，它的作用是描述工作缓冲区的头部信息。

工作缓冲区是用于垃圾回收的缓冲区。为了提高垃圾回收的效率，Go语言使用了并发垃圾回收的机制，其中每个工作线程会有一个专用的工作缓冲区。当工作线程需要处理某个对象时，它会将这个对象放到自己的工作缓冲区中。当工作缓冲区满了以后，工作线程会把自己的工作缓冲区交给主线程，让主线程来完成垃圾回收。

workbufhdr结构体描述了工作缓冲区的头部信息，包括：

- objsize：每个对象的大小
- nobjcap：缓冲区最多可以容纳多少个对象
- nobj：当前缓冲区已经有多少个对象
- log2objsize：每个对象占据的字节数的对数
- next：当前缓冲区的下一个缓冲区

通过这些信息，Go语言的垃圾回收可以更有效地管理工作缓冲区，加快垃圾回收的速度，提高程序的性能。



### workbuf

在Go语言的垃圾回收机制中，每个线程会有自己的工作缓冲区（work buffer），用于存储待处理的对象以及堆栈信息。这个工作缓冲区是由workbuf结构体表示的。

workbuf结构体定义如下：

```go
type workbuf struct {
    // buf0所在的页
    // 当buf0已满时，buf1所在的页会被map到页堆上
    // 请注意，buf1可能会未映射到页堆上
    // 在这种情况下，pos不是固定的（一旦buf0已满，将切换到buf1），所以每个goroutine应该记住他所使用的pos。
    // 当GC启动时，我们将明确地把buf1映射到页堆上。
    buf0     []byte   // buf0 is always non-nil. 最大容量MaxGCWorkBufSize字节
    buf1     []byte   // buf1 is nil, or a buffer for when buf0 fills. 最大容量MaxGCWorkBufSize字节
    nbytes   uintptr  // buf0[0:nbytes]是有效内容
    needscan bool     // 是否需要扫描缓冲区，如果buf0满了，或者强制扫描，则为true
    // 此工作缓冲区所属的P。即使onlycertainP为true，也仍需要p，因为该P仍可能将其他P的G放入此工作缓冲区中。
    p       *p       // 此工作缓冲区的所有者，当onlycertainp为true时，不允许在一个Ps的C中的其他Ps访问该缓冲区
    // 与此workbuf相关联的G（可能为nil）
    g0      *g       // 附加到此工作缓冲区的G（如果有）。
    // onlycertainp表示只能从某个特定的P的运行队列中提取G执行
    // 对于每个有工作缓冲区的P，它只有一个workbuf（由p.gcworkbufs指针引用）。
    // 当onlycertainp为true时，存储在workbuf中的G只能从特定的P的运行队列中提取，而非从任意一个P的运行队列中提取。
    onlycertainp bool
}
```

workbuf结构体中的字段具体含义如下：

1. buf0和buf1是工作缓冲区的两个缓冲区，用于存储待处理的对象以及堆栈信息；
2. nbytes表示buf0中有效的字节数；
3. needscan标记表示是否需要扫描缓冲区，如果buf0满了或者强制扫描，则为true；
4. p表示此工作缓冲区所属的P；
5. g0表示与此workbuf相关联的G，可能为nil；
6. onlycertainp用于标记是否只能从特定的P的运行队列中提取G执行。

在Go语言的垃圾回收机制中，工作缓冲区是垃圾回收器和并发程序之间的重要桥梁，在Go语言的运行时系统中发挥着重要作用。了解其内部实现和工作方式可以帮助程序员更好地理解垃圾回收机制的工作原理，进而优化程序的性能和稳定性。



## Functions:

### init

在Go语言的内存垃圾回收机制中，mgcwork.go文件中的init函数起着重要的作用。init函数被称为初始化函数，它是在程序运行之前被调用的，主要用于进行一些全局变量的初始化操作。

在mgcwork.go文件中的init函数中，主要完成以下几个任务：

1. 初始化全局变量workbuf0和workbuf1，这两个变量用于存储垃圾回收器需要处理的工作对象队列。

2. 初始化全局变量gcWork和gcWbuf，gcWork数组用于存储待处理的工作对象，gcWbuf是一个切片类型，它用于存储垃圾回收时使用的临时对象数组。这些全局变量的初始化是为了垃圾回收器能够正确地工作。

3. 初始化gcMarkWorkerMode参数，该参数用于控制垃圾回收器的工作方式，主要有三种模式，分别是gcMarkWorkerModeFractional，gcMarkWorkerModeSingle和gcMarkWorkerModeBatched。

4. 初始化gcHelper参数，该参数用于标记和清理对象。

通过init函数的这些初始化操作，垃圾回收器才能够正确地运行，并将内存中的所有垃圾对象及时清理掉。在Go语言中，垃圾回收器的自动内存管理机制大大简化了程序员的工作，减少了内存泄露的风险，提高了程序的稳定性和安全性。



### init

在go/src/runtime/mgcwork.go中，init()是一个包级别的函数，它被用来初始化与内存管理相关的全局变量。具体来说，它执行以下三个任务：

1. 初始化内存管理相关的全局变量，例如gcWork.buf，它是一个用于为并发引用对象集分配内存的缓冲区。

2. 将内存分配器的hook函数指针mgcMarkDone.ptr设置为nil。这个hook函数是在内存分配期间调用的，用于向Mark worker线程发送信号，让它们开始收集对象的引用。

3. 向“池池”中放置Mark工作的缓冲区。一个“池池”是一组用于分配并管理工作缓冲区的池。当工人线程需要工作缓冲区时，它们将从池中获取一个缓冲区，并在完成工作后将其归还到池中。在这种情况下，init ()函数将向“池池”中放置MarkGobal.workBuf的第一个缓冲区。

总的来说，init() 函数用于初始化与内存管理相关的全局变量和结构，确保GC过程中满足性能和有效性的要求。



### put

在Go语言中，mgcwork.go文件中的put函数的作用是将M对象重新放回空闲链表中，以供下次使用。

MGC是Go语言的垃圾回收器，作为一种自动内存管理模型，它负责回收不再使用的对象。put函数是在执行垃圾回收时，由后台线程调用的函数之一，用于将M对象重新放回空闲链表中。M对象是Go语言中用于管理操作系统线程的结构，它通常与g(协程)对象一起使用，用于创建和管理协程，调度Goroutines和执行阻塞I/O操作。

put函数主要包括M对象的回收和调度，它执行以下操作：

1. 释放当前M对象的所有资源，包括goroutine、堆栈、内存等；
2. 从全局运行队列、本地运行队列和P的单独队列中移除任何正在运行的Goroutines；
3. 将M对象添加到空闲M列表中，以备下次使用。

put函数是Go语言运行时系统的核心组件之一，用于协调使用系统资源、调度goroutines 和执行阻塞I/O操作。它的作用是为Go语言的垃圾回收器提供支持，确保内存管理的健壮性和高效性。



### putFast

putFast函数是垃圾回收器（GC）的一部分，在处理对象的切片时被调用。它的主要功能是将要被扫描的对象添加到gcwork中去。gcwork是一种用于保存需要被扫描的对象的数据类型。它是由concurrent mark sweep GC（CMS GC）使用的一种并发扫描算法中的一部分，旨在减少GC期间的停顿时间。

putFast函数首先会检查要添加的对象是否为nil或被判定为不需要GC。如果对象为空或GC标记被设置为禁用，则无需添加到gcwork中去。否则，putFast函数会从gcworkpool中获取一个空闲的gcworkbuf。接下来，它会将要被扫描的对象添加到gcworkbuf中的数组中，并更新相应的指针以便于下次迭代。如果gcworkbuf已满，则会将其添加到全局gcwork队列中，以便于GC工作线程扫描。

putFast函数还会在完成工作后，检查是否需要唤醒GC工作线程以扫描gcwork队列。如果gcwork队列已经达到阈值，则会唤醒GC工作线程，以允许它们进行扫描操作。

总之，putFast函数的主要作用是将要被扫描的对象添加到gcwork中去，以便CMS GC可以在后台进程中进行并发扫描，从而减少GC停顿时间和提高系统的吞吐率。



### putBatch

putBatch函数是垃圾回收器的一部分，用于把一批对象放入一个缓冲区中以供后续处理。

具体来说，垃圾回收器在进行标记阶段时，需要将所有被标记为垃圾的对象放到一个待回收列表中。为了尽量减少垃圾回收器扫描内存的时间，putBatch函数将被标记的对象暂存入一个缓冲区中，在缓冲区填满或者垃圾回收器需要进行下一阶段的操作时，将整个缓冲区批量加入到待回收列表中。

putBatch函数的实现是通过调用putFast函数实现的。在putFast函数中，首先将对象加入到一个管道中，然后将管道中的所有对象按顺序复制到缓冲区中。如果缓冲区已满，则将它作为一批对象添加到待回收列表中，并更新缓冲区的指针。最后，putBatch函数还会通过参数adjust指定是否重新设置内存指针。

总之，putBatch函数的作用是优化垃圾回收器的效率，以达到更好的性能和吞吐量。



### tryGet

tryGet函数的作用是从workbuf里面取出一个可用的对象。

具体来说，tryGet函数是在垃圾回收工作中被调用的。在垃圾回收期间，所有的对象都会被标记，然后那些已经被标记的对象会被释放掉。为了能够有效地管理这些对象，系统会将这些对象放在workbuf里面。而tryGet函数就是用来从workbuf里面获取一个可用的对象的。

当tryGet函数开始执行时，它会首先检查M的gcworkbuf列表是否为空。如果为空，那么就无法获取可用对象。如果不为空，它会从列表的末尾开始向前遍历每个gcworkbuf。对于每个gcworkbuf，它会检查其中的buf是否为空。如果buf不为空，它会将buf中的最后一个可用对象弹出来，将该对象的地址返回给调用者，并且将buf的len减一。如果buf已经为空了，那么它会继续遍历下一个gcworkbuf，直到找到一个有可用对象的gcworkbuf或者全部遍历完毕。

总之，tryGet函数的作用就是从workbuf中获取一个可用的对象，以便进行垃圾回收工作。



### tryGetFast

在Go语言中，垃圾回收（Garbage collection，简称GC）是自动进行的。go/src/runtime/mgcwork.go文件中的tryGetFast函数是垃圾回收机制的一部分，这个函数的作用是尝试获取一个待回收的对象。在该函数内部，首先会从待回收队列中获取一个对象，如果队列已空，则会从P的本地缓存中获取对象。如果P的本地缓存中也没有对象，则会从其他P的缓存中获取对象，直到找到为止。如果所有P的本地缓存中都没有，那么会将当前P对应的M状态设置为waiting，等待其他P释放对象内存，直到找到为止。如果找到一个可回收的对象，则返回对象指针和标记类型（对应的是P、G、S、M四个类型的标记），否则返回nil和空标记。

tryGetFast函数的作用是避免频繁的锁竞争，提高GC的执行效率。因为如果每次获取对象都需要进行锁竞争，会大大影响GC的效率。而通过将获取对象的顺序进行优化，尝试从P的本地缓存中获取对象，避免了对全局队列进行锁竞争的情况。因此，tryGetFast函数可以加速GC的执行速度，提高程序的性能。



### dispose

dispose函数是Go语言中垃圾回收器的一部分，用于处理不再被使用的内存对象的释放和回收。

当Go程序运行时，内存管理器（memory manager）会分配内存空间给你的变量和数据结构。当这些变量或数据结构不再需要时，dispose函数会被调用来释放内存。dispose函数会将不再使用的内存对象标记为不可用，并将其返回给内存池，以供以后重复使用。

dispose函数的主要作用是清除不再使用的内存，帮助系统保持内存管理器的正确性。这个函数通常在垃圾回收器扫描过程中发现不再需要的内存对象时被调用。例如，在一个大型的Web服务器中，如果请求处理完毕后，服务器需要释放其内存，dispose函数就会清除这些请求处理过程中分配的内存。

dispose函数是Go语言的垃圾回收机制中非常重要的一部分，它确保了程序使用的内存始终保持在一定的范围之内，从而避免了内存泄漏和过度消耗系统资源的问题。



### balance

在Go语言的垃圾回收过程中，每个活跃的P（处理器）都会有一个本地的goroutine队列，称为P的work队列。实际上，这个队列不仅仅包含goroutine，还包含了其他的需要垃圾回收的对象。在垃圾回收时，所有的P都需要参与工作，例如需要将本地的work队列中的对象移到全局队列中或是执行垃圾回收任务等。如果某些P本地队列过长，而其他的P队列相对较少，那么就可能会导致垃圾回收效率不佳。

为了解决这个问题，Go语言的垃圾回收器在mgcwork.go这个文件中实现了一个名为“balance”的函数。这个函数的主要作用就是平衡所有的P的work队列，以使每个队列的长度大致相等。具体来说，在balance函数中，会先计算每个P的work队列的长度，并将它们放入一个数组中；然后，会用类似于快速排序的方式对这个数组进行排序，并将排序结果按照升序（即从小到大）放进一个新的数组中，最后根据新数组的顺序，依次将work队列中的对象移到其他的P的队列中。

通过这种平衡P的work队列的方式，可以使得垃圾回收的效率更高，并提高整个系统的性能。而balance函数的实现，正是Go语言垃圾回收的重要组成部分之一。



### empty

empty这个函数的作用是将传递进来的参数指针清空并返回。它主要用于在垃圾回收过程中，将某些对象的引用清空，以便可以被回收。

在Go语言中，垃圾回收器会定期检查程序中不再使用的对象，并将它们回收掉以释放内存空间。但是如果一个对象还被其他对象引用，那么垃圾回收器就无法回收它。因此，我们需要在程序中明确地将某些对象的引用清空，告诉垃圾回收器这些对象可以被回收了。

empty函数将参数指针清空后，就可以防止该对象被其他对象引用。同时，它还返回了一个指向原参数指针所指向的对象的指针，以便在清空指针后可以继续访问对象。

在mgcwork.go文件中，empty函数还与markrootIfNil函数配合使用，用于标记Root对象。Root对象是程序中不会被垃圾回收机制回收的对象，它的存在可以防止整个子树被扫描。markrootIfNil函数会将传递进来的参数指针标记为Root对象，如果该指针为空，则需要调用empty函数清空该指针。这样，即使在空指针引用Root对象时，也不会被垃圾回收器回收掉。



### checknonempty

checknonempty函数是用来检查内存块是否为空的函数。在垃圾回收器开始工作之前，需要先检查已经分配的内存块是否为空，如果为空则不需要扫描这个内存块，这样可以提高垃圾回收的效率。

具体来说，checknonempty函数的作用是检查一个memoryBlock结构体中的bitmap是否为空。如果bitmap不为空，则说明这个内存块中有数据，需要进一步的扫描和处理。如果bitmap为空，则说明这个内存块是空的，可以直接跳过，不需要处理。

这个函数是在垃圾回收器启动之前被调用的，作为初始化的一部分。它在扫描所有内存块之前被调用，以确保不会浪费时间和资源扫描空的内存块。



### checkempty

checkempty函数的作用是检查指定的地址范围内是否存在非零值。该函数通常用于垃圾回收器的标记阶段，其中需要确定哪些对象仍然在使用中，哪些可以被回收。

具体来说，checkempty函数会检查从start开始的从start到end-1字节的数据，如果存在任何一个非零字节，它将返回false。否则，它将返回true。

该函数在垃圾回收器的标记阶段非常重要，因为在标记对象前需要确定对象是否是活动的。如果对象已被删除或未分配，则可以跳过标记操作，从而提高垃圾回收器的效率。

总之，checkempty函数是检查指定地址范围是否包含非零值的简单工具函数，它在垃圾回收器的标记阶段起着关键作用。



### getempty

getempty函数是用于获取空闲的workbuf链表的函数。workbuf是一种用于垃圾回收的缓冲区，用于存放需要被回收的对象。

在go语言中，垃圾回收算法是基于标记-清除算法的。当一个对象不再被引用时，它就会被标记为可回收的，但是这个对象所占用的内存并不会立即释放。相反，它们会被放入一个workbuf缓冲区中，等待垃圾回收器来进行实际的回收。

getempty函数就是用于从缓存池中获取一个空闲的workbuf链表的。具体来说，它会首先从缓存池中获取一个空闲的workbuf链表，如果缓存池中没有空闲的链表，则会新建一个链表，并返回该链表。

这个函数的作用在于保证垃圾回收器有足够的缓冲区去存放待回收的对象。如果没有足够的缓冲区，则会导致垃圾回收的效率变得极低，并且可能会影响程序的性能。因此，getempty函数是一个非常重要的函数，能够保证go语言的垃圾回收算法能够正常工作。



### putempty

putempty这个函数在垃圾回收过程中起到了清空空闲 span 的作用。在程序运行过程中，当某个 span 的对象被全部使用且没有新的对象分配给它时，该 span 就成为空闲状态。这时候就需要清空该 span 中的所有对象，以便后续对象的重新利用，避免内存浪费。

具体而言，putempty函数会将空闲 span 的 bitmap 清空，从而使得该 span 可以被重新使用。在清空 bitmap 的同时，该函数还会对 span 进行一些简单的状态更新，例如设置 sweepgen 为当前的 gcPhase，表示该 span 正在被回收。同时，如果该 span 是双向链表中的最后一个 span，并且没有任何对象被分配到这个 span 中，putempty 还会尝试将这个 span 从双向链表中删除，以便优化垃圾回收过程。

总之，putempty 函数是垃圾回收过程中重要的一环，通过清空空闲的 span，释放空间来避免内存浪费，为程序提供更好的内存管理能力。



### putfull

putfull这个func的作用是将全局扫描列表中所有的对象标记为已经遍历，并将未标记的对象加入到待标记队列中，以准备下一轮的垃圾回收。

具体实现过程如下：

1. 遍历全局扫描列表，将其中的所有对象标记为已经遍历。

2. 将未标记的对象加入到待标记队列中。

3. 将标记为已经遍历的对象从全局扫描列表中移除。

4. 如果待标记队列非空，将其中的对象移动到全局扫描列表中，并将待标记队列清空。

该函数的调用是在垃圾回收的mark阶段完成之后，用于准备下一轮的扫描。putfull的作用是将当前扫描过的对象标记为已扫描，并将下一轮需要扫描的对象加入到扫描队列中。这样可以保证垃圾回收能够顺利执行，同时减少内存泄漏的风险。



### trygetfull

在Go语言中，内存回收是自动进行的，垃圾收集器（garbage collector）会定期扫描程序中不再使用的变量，并回收其所占据的内存。而trygetfull()函数则是在垃圾回收器运行时，尝试获取全部正在运行的goroutine的信息。

具体来说，trygetfull()函数会检查当前是否有goroutine处于正在运行的状态，如果有，那么它会先将这些goroutine暂停下来，然后获取这些goroutine的所有信息。这些信息包括goroutine的栈帧（stack frame）、堆栈指针（stack pointer）、堆栈大小（stack size）等等。获取完所有goroutine信息后，trygetfull()函数会将这些goroutine重新恢复运行，并返回所有的goroutine信息给调用方。

trygetfull()函数的作用是使垃圾回收器能够获取到所有正在运行的goroutine的信息，以便于回收程序中不再使用的变量。但是，由于trygetfull()函数会暂停所有正在运行的goroutine，因此它会对程序的执行效率产生影响。因此，在实际使用中，我们需要权衡程序的执行效率和垃圾收集器的效率，选择合适的策略来进行内存回收。



### handoff

在Go语言中，垃圾回收是自动进行的。当程序需要分配内存时，垃圾回收器可能会暂停程序并扫描堆上的对象，释放不再使用的内存。这个过程需要花费一定的时间，可能导致程序出现暂停或延迟。

为了尽可能减少这种暂停时间，Go语言采用了并发垃圾回收策略。垃圾回收器会启动一个或多个goroutine来扫描堆上的对象，释放不再使用的内存。这些goroutine需要互相协作以确保工作能够正确完成。

handoff函数就是用来实现这种协作的。在mgcwork.go文件中，handoff函数定义如下：

func handoff(gp *g, waitReasonWaitForWork bool)

可以看到，handoff函数的参数是一个goroutine（gp）和一个等待理由（waitReasonWaitForWork）。这个函数的作用就是将当前goroutine（也就是执行handoff函数的goroutine）交给另一个goroutine继续工作，并等待一段时间。

在垃圾回收过程中，当一个goroutine需要等待另一个goroutine完成某个工作时，调用handoff函数。这会使当前goroutine暂停，并将状态标记为等待。然后，垃圾回收器会寻找一个可用的goroutine来接管工作，并将其唤醒。当这个新的goroutine完成工作后，会将控制权交回给原始的goroutine，让其继续工作。

这种协作策略可以确保垃圾回收过程的并发执行，减少程序暂停和延迟，提高程序效率。



### prepareFreeWorkbufs

prepareFreeWorkbufs是Go语言运行时中的垃圾回收器（GC）代码，用于为垃圾回收器准备自由的工作缓冲区。其主要作用是管理空闲的工作缓冲区，以提高垃圾回收的效率。

在每次垃圾回收过程之前，prepareFreeWorkbufs会在GC工作环境（workbuf）中寻找空闲的工作缓冲区。若找到，则将其放入待使用的freeWorkbufs队列中；若找不到，则通过分配新的缓冲区来满足需求，并将其放入freeWorkbufs队列中。

在垃圾回收器运行时，freeWorkbufs队列中存储的空闲工作缓冲区将被用于缓存GC标记时需要处理的对象。通过预先分配和管理空闲缓冲区，可以避免在GC过程中频繁的内存分配和释放，提高系统的垃圾回收性能。

总之，prepareFreeWorkbufs函数的作用是预先分配和管理垃圾回收器中的工作缓冲区，以提高垃圾回收的效率。



### freeSomeWbufs

freeSomeWbufs函数的作用是回收部分work buf（也称为work buffer），它们是用于并发标记阶段的缓冲区，用于存储标记时找到的对象的指针。这些work buf是在每个P的local work buffer cache中分配的，当它们被填满时，它们被放回到全局缓存中以供其他P使用。当全局缓存中的work buf数量超过限制时，就需要调用freeSomeWbufs函数来回收一些work buf以保持数量在可控范围内。

具体来说，在并发标记阶段，每个P都会分配一个local work buffer cache。当它的work buf用完时，就将它们放回全局缓存中。在某些情况下，全局缓存中的work buf数量会超过一个阈值（由g.mheap.gcWorkBufWasteLimit确定），这时就需要回收一些work buf以保持数量在可控范围内。freeSomeWbufs函数就是用于执行这个任务的。

freeSomeWbufs函数会尝试从每个P的local work buffer cache中随机选择一个work buf并将其释放到全局缓存中。这样做的目的是尽可能均匀地回收work buf，以避免某些P的local work buffer cache过度膨胀。此外，freeSomeWbufs函数还会更新全局缓存的work buf数量，并检查是否需要调整P的local work buffer cache的大小以适应全局缓存中work buf的数量。



