# File: garbage.go

garbage.go文件是Go语言运行时包（runtime）中的一个重要组成部分，负责实现Go语言的垃圾回收机制（GC）。垃圾回收是一种自动管理内存的机制，其主要目的是在程序运行的过程中检测和清除不再使用的内存。该机制可以防止内存泄漏和程序崩溃，提高程序的稳定性和性能。

具体来说，garbage.go文件中实现了Go语言垃圾回收机制的四个主要部分：标记、清扫、根引用、内存管理。其中，标记阶段通过依赖关系（即对象到对象的引用）遍历内存中的所有对象，并对每个对象进行标记，以判断其是否为垃圾对象；清扫阶段则清除已经被标记的垃圾对象；根引用负责记录程序中所有可能引用对象的指针；内存管理则是针对内存分配和释放的管理。

除了实现垃圾回收机制，garbage.go文件还包含了其他与垃圾回收相关的功能，例如对象分配、内存布局的维护，并提供了一些函数用于诊断垃圾回收的状态和性能。




---

### Structs:

### GCStats

在 Go 语言中，垃圾回收（Garbage Collection）是一项非常重要的机制，它实现了自动内存管理，避免了手动管理内存的问题，但是它会对性能造成一定的影响。因此，在运行时需要了解垃圾回收的情况，以便于对其影响进行优化。

GCStats 结构体是提供这种信息的一种方式，它包含了垃圾回收器的一些统计信息，例如垃圾回收器所耗费的时间、扫描的对象数量、回收的对象数量等等，这些信息可以用来帮助开发者了解 Go 程序的内存使用情况，从而有针对性地优化程序。

具体来说，GCStats 结构体包含以下字段：

- NumGC：垃圾回收的次数；
- PauseTotal：所有垃圾回收所消耗的时间总和；
- Pause：单次垃圾回收所消耗的时间；
- PauseEnd：每次垃圾回收结束时的时间戳；
- PauseQuantiles：按升序排列的垃圾回收时间分位数，例如 99.9% 的垃圾回收时间都在多长时间以内；
- HeapAlloc：当前堆的分配字节数；
- HeapSys：已经向操作系统申请的内存总量；
- HeapIdle：未被使用的内存量；
- HeapInuse：正在使用的内存量；
- HeapReleased：返回操作系统的内存量；
- HeapObjects：堆中对象的数量。

由于垃圾回收是在运行时进行的，因此 GCStats 结构体的信息可以在程序运行过程中实时更新。当然，为了避免对程序性能造成影响，垃圾回收的统计信息并不是实时更新的，而是在每次垃圾回收完成后才会更新。因此，如果需要了解程序的实时内存使用情况，GCStats 可能并不是最好的选择，可以考虑使用其它工具来进行监控和分析。



## Functions:

### ReadGCStats

ReadGCStats函数是用于收集垃圾回收（GC）的统计信息并返回这些信息的函数。它会返回最近一次GC执行时的以下信息：

- NumGC: 执行GC的次数
- PauseTotal: 执行GC期间的累计暂停时间
- Pause: 表示最近一次GC执行期间的暂停时间
- PauseQuantiles: 用于估计暂停时间百分位数的分位数
- PauseEnd: 直到最近一次GC执行结束的时间

这些信息非常有用，因为它们可以提供有关程序性能和GC行为的关键信息。例如，用户可以使用NumGC计算相对于时间的平均GC次数，使用PauseTotal计算平均GC暂停时间，并使用PauseQuantiles了解GC暂停时间分布情况。根据这些信息，用户可以对程序的GC行为进行优化。

在Go语言中，GC是自动管理的，因此收集这些统计信息是非常有必要的，以便在程序运行时进行优化。通常，这些统计信息将在程序运行期间记录，以便可以根据需要进行监视和分析。



### SetGCPercent

SetGCPercent函数是用来设置垃圾回收的目标利用率（GC utilization）。垃圾回收器会在达到这个目标后停止运行。

GC percent指的是heap中被使用的部分的比例。如果GC percent为100%，则代表heap已满，需要进行垃圾回收。如果GC percent为50%，则代表heap中使用了一半的空间，需要垃圾回收清理出一半空闲的空间。

这个函数可以用来控制应用程序中使用的内存量。如果应用程序峰值使用内存量为100MB，但是我们不希望在任何时候都使用那么多内存，那么可以设置较小的GC percent，比如50%，这样就可以让垃圾回收器更加积极地回收垃圾，从而控制内存使用量。

该函数调用可避免不必要的内存浪费，如同时处于多个CPU绑定的场景下，即时又有很多线程需要大量内存，也会让垃圾回收器按照GC percent减少堆大小；而在务必需要释放和合理分配内存的场景下，该函数调用也能够加快回收速度和并发，提高效率。

该函数会对所有的P调用gcController.updateCredit()进行更新，而updateCredit()会根据heap中的现有大小计算出新的credit和totalthor攻击指南。具体实现见gcController.go文件中的updateCredit()函数和gcPercentHistory数组。



### FreeOSMemory

FreeOSMemory函数是Go语言运行时系统用来释放操作系统内存的函数。当Go程序运行时分配了大量的内存，但是这些内存在当前环境中不再需要时，可以调用FreeOSMemory函数将它们归还给操作系统。

具体来说，FreeOSMemory函数首先通过调用 runtime/debug.FreeOSMemory() 函数尝试释放所有的不必要的堆空间、栈空间和内部数据结构占用的空间，从而获得额外的可释放的内存。然后，它调用了 runtime_memclrNoHeapPointers() 函数，该函数用于清除所有不包含任何指针的内存。最后，如果要释放的内存数量超过了一定的阈值，FreeOSMemory函数会显式地调用操作系统的释放内存函数来释放内存。

需要注意的是，虽然FreeOSMemory函数可以显式地释放操作系统内存，但这并不意味着即使释放了内存也能保证程序的性能一定会提升。此方法只在极特殊的情况下使用，比如程序需要释放大量的内存并且已经确定这部分内存不会再被使用到了。另外，释放内存并不意味着操作系统和Go程序就能够完全脱离，操作系统仍需要关注Go程序运行的资源占用情况，以保证程序的正确性和稳定性。



### SetMaxStack

SetMaxStack是Go语言运行时中的一个函数，用于设置当前程序的最大堆栈大小。在Go语言中，每个goroutine（协程）在启动时都会被分配一定大小的堆栈空间，以存储调用栈、局部变量、临时变量等。当一个goroutine的堆栈空间不足时，会自动扩充堆栈大小。但是，堆栈大小的扩充是有限制的，如果堆栈扩充超过了一定的限制，程序将会崩溃。

SetMaxStack函数就是用来设置这个自动扩充的限制值，即最大堆栈大小。通过设置该值可以避免程序因为堆栈空间不足而崩溃。该函数接受一个参数maxStack，表示最大堆栈大小，单位为字节。如果不调用该函数，则默认最大堆栈大小为10MB。

需要注意的是，SetMaxStack函数的作用在于限制堆栈大小的自动扩充，对于已经分配了较大堆栈空间的goroutine而言，该函数并不能改变它们的堆栈大小。此外，设置过大的堆栈大小也会占用系统资源，因此要谨慎使用。



### SetMaxThreads

在 Go 语言的 runtime 包中，SetMaxThreads() 函数用于设置系统中最大的线程数。该函数接受一个整数参数 n，表示最大线程数，调用该函数后，系统将开启不超过 n 个线程并且在调用函数的线程中运行。如果 n 小于或等于零，那么函数将无效。如果 n 大于最大线程数，函数将会阻塞，直到线程数小于或等于 n。

该函数的作用在于，当程序需要进行大量的并发操作时，可以动态地控制系统中线程的数量，以达到最优的性能。如果线程数量太少，那么程序的并发处理能力将受到限制，导致效率低下；如果线程数量太多，那么系统将会消耗过多的资源，导致系统崩溃或者效率降低。因此，动态地调节线程数量是非常重要的。

在调用该函数之前，需要先使用 runtime.GOMAXPROCS() 函数将系统中的可用线程数设置为最大值，以确保系统中有足够的线程可供使用。同时，在调用该函数之后，也需要使用 runtime.GOMAXPROCS() 函数恢复系统中的线程数，以确保系统能够正常工作。



### SetPanicOnFault

SetPanicOnFault函数的作用是控制当Go程序遇到某些故障时是否抛出panic。该函数接受一个布尔值作为参数，如果为true，则Go程序在遇到故障时会抛出panic；如果为false，则Go程序在遇到故障时会直接崩溃。

SetPanicOnFault通常被用于调试程序，当程序遇到故障时可以抛出panic帮助程序员快速定位问题。但是在生产环境中，抛出panic可能会导致程序崩溃，因此通常应该将其设置为false。

在Garbage Collector中，当发生某些错误（如内存不足）时，程序会调用runtime.raise方法抛出panic。通过调用SetPanicOnFault函数，可以控制程序在遇到这些错误时是否抛出panic。



### WriteHeapDump

WriteHeapDump是在Go程序产生garbage collection时，将堆信息写入文件的函数。它的主要作用是帮助开发人员诊断应用程序的内存泄漏和其他内存问题。

当WriteHeapDump函数被调用时，它会将当前Go程序的堆信息写入一个文件中。这个文件包含了当前运行的所有goroutine的堆栈跟踪信息、对象分配和释放情况等。

开发人员可以使用这些信息来分析应用程序的内存使用情况，查找内存泄漏和其他内存问题。例如，开发人员可以使用堆栈跟踪信息来找出哪些代码路径会导致对象的过多分配或不正确的释放。

需要注意的是，这个函数只有在编译时使用了"go build -gcflags=-l"参数编译的程序中才可用，并且只有在程序发生garbage collection时才会执行。



### SetTraceback

SetTraceback函数是设置垃圾回收器Traceback相关参数的函数。Traceback是Go语言调用栈跟踪机制的一部分，会帮助开发者调试和处理程序崩溃的信息。垃圾回收器需要使用Traceback才能定位对象的引用情况，从而进行垃圾回收。

具体而言，SetTraceback函数的作用如下：

1. 设置gcPercent参数，该参数用于垃圾回收的阈值控制。当被回收对象的数量达到一定比例时，便会触发垃圾回收。参数值范围为0到100。

2. 设置调用栈的最大深度maxTraceback，该参数用于记录调用栈的深度上限。当垃圾回收器需要进行Traceback时，会从当前goroutine的栈底开始遍历调用栈，直到达到上限maxTraceback或者栈底。参数值范围为0到65535。

3. 设置调试级别debugLevel，该参数用于指定输出的Traceback信息的详细程度。参数值范围为0到3，从高到低分别代表完整、标准、简易和极简模式。

总之，SetTraceback函数的作用是为垃圾回收器提供Traceback相关的参数配置，以增强Go语言的垃圾回收机制。



### SetMemoryLimit

SetMemoryLimit函数是用来设置堆内存限制的函数。在Go语言中，堆内存是由运行时系统自动管理的，但有时我们需要限制堆内存的使用量，例如在一个有多个应用程序运行的服务器中，为了防止一个应用程序占用过多的堆内存从而影响其他应用程序的正常运行，我们可以使用SetMemoryLimit函数来限制每个应用程序的堆内存使用量。

函数签名如下：

```
func SetMemoryLimit(mb uintptr) bool
```

参数mb是堆内存限制的大小，单位是MB，函数返回一个布尔值，表示是否成功设置了堆内存限制。

在函数内部，先将mb转换为字节数并存储在memstats.heap_sys_limit变量中，然后调用sysReserve函数将堆内存的限制设置为memstats.heap_sys_limit，并返回是否设置成功。如果设置成功，就会生成一个SIGXFSZ信号，当堆内存使用量达到限制时就会收到这个信号并执行相应的操作，例如退出程序或做一些垃圾回收的操作等。

注意，这个函数只能在Linux和Darwin等支持mmap函数的操作系统上使用。在Windows等不支持mmap函数的系统上，这个函数会返回false，表示设置失败。



