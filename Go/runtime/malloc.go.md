# File: malloc.go

malloc.go文件是Go语言中管理内存分配和释放的核心文件之一。它包含了Go语言的内存管理器（Memory Allocator）实现。

Go语言使用了一种名为mcache的内存管理技术，它是一种基于线程本地（Thread-Local）缓存的内存分配器，它将一些特定大小的内存分配请求分配到缓存线程中来处理，以减少对全局内存池的访问。malloc.go文件中定义了mcache相关的结构体、变量和函数。同时，对于比较大的内存分配请求，Go语言采用了基于堆内存的分配方式。

该文件对于Go语言的运行时来说是非常重要的，因为它直接影响了程序执行的性能和稳定性。由于Go语言的内存管理有着极高的效率和灵活性，使得它在高性能并发编程中广受欢迎。




---

### Var:

### physPageSize

在Go语言的运行时系统中，malloc.go这个文件定义了内存分配函数。其中，physPageSize这个变量是用来记录当前系统的物理内存页大小的。具体作用如下：

1. 内存对齐：内存的分配和释放需要满足一定的内存对齐要求，这个对齐的单位就是物理内存页大小。例如，如果物理内存页大小是4KB，那么分配8字节的内存时，实际上会分配2个物理内存页的大小，也就是8KB的内存。

2. 内存池管理：Go语言的运行时系统使用了内存池来管理内存的分配和释放。内存池的实现需要考虑物理内存页大小。如果分配的内存大小小于物理内存页大小，那么会从内存池中找到一个已经分配过的内存块来使用，而不是直接向操作系统请求分配内存。这样可以提高内存的使用效率。

3. 内存映射：Go语言的运行时系统也使用了内存映射来管理内存。内存映射可以将物理内存页映射到虚拟内存地址上，从而实现对物理内存的管理。在内存映射中，需要考虑物理内存页的大小，因为内存映射是以物理内存页为单位进行的。如果物理内存页大小不正确，可能会导致内存映射出错。

总之，physPageSize变量是Go语言运行时系统中用来记录当前系统的物理内存页大小的变量，它对于内存分配、对齐、池管理和映射等方面都具有重要作用。



### physHugePageSize

在Go语言中，malloc.go文件主要用于管理内存分配和回收。其中，physHugePageSize这个变量用于表示操作系统支持的最大内存页面大小（单位为字节）。如果操作系统不支持大页面，则该变量默认为0。

在程序启动时，Go运行时会根据操作系统的支持情况来设置physHugePageSize变量的值。如果操作系统支持大页面，则该变量的值会被设置为相应的页面大小，从而可以更高效地进行内存分配和管理。否则，程序将使用操作系统默认的页面大小来进行内存管理。

physHugePageSize变量的值还会影响到内存分配器的一些具体实现细节，例如在进行大块内存分配时，内存分配器会优先选择使用大页面来分配内存，从而减少内存碎片和内存管理的开销。此外，如果系统支持大页面，则内存分配器还会尝试合并相邻的内存页面，从而提高内存分配的效率。

总之，physHugePageSize变量是Go运行时中一个重要的配置参数，它影响到内存分配和管理的效率和质量，需要根据具体操作系统和应用场景来进行设置和调整。



### physHugePageShift

在Go语言的运行时中，malloc.go文件负责Go程序的内存分配和管理。physHugePageShift是该文件中的一个变量，其作用是用于确定系统支持的大页的大小。

大页是计算机系统中用于提高内存访问性能的机制，它们的大小通常比标准页大很多。在支持大页的系统中，如果应用程序使用大页来管理内存，则可以从以下方面获得明显的性能提升：

1. 减少内存访问的TLB缺失次数。因为大页覆盖的内存范围比标准页大，所以在大页管理的内存范围内，每个TLB（Translation Lookaside Buffer，翻译高速缓存）缓存的虚拟地址对应的物理地址也就更多。在访问时，CPU可以使用更少的TLB缓存去覆盖更多的内存地址，从而显著减少TLB缺失次数，提高内存访问效率。

2. 减少页表项的数量。因为大页覆盖的内存范围比标准页大很多，所以使用大页管理内存时，需要的页表项数量也就比标准页少很多。这样就可以减少页表大小，从而提高内存管理效率。

在Go语言中，当程序需要向操作系统申请大页时，就需要使用physHugePageShift变量来确定操作系统支持的大页的大小。在Windows环境下，变量的默认值是0，表示不使用大页。而在Linux环境下，变量的默认值是30，表示使用2MB的大页，但也可以根据系统情况进行调整。通过调整变量的值，程序可以灵活地使用大页机制来提高内存访问效率和管理效率。



### zerobase

在Go语言中，`malloc.go`文件是一个实现内存分配器的重要文件，其中`zerobase`是一个指向零值的指针。它的作用是在调用`sysAlloc()`函数时，将申请的内存的初始值初始化为零值。与C/C++中的`calloc()`函数类似，它可以保证动态分配的内存块的初始值为零，从而避免了未初始化内存带来的安全隐患。

`zerobase`的定义如下：

```
var zerobase *byte

// ...

// Allocate size bytes of zeroed memory. 
func calloc(size uintptr) unsafe.Pointer {
    // ...

    p := sysAlloc(size, &memstats.other_sys)
    if p != nil {
        *(*uintptr)(unsafe.Pointer(p)) = size
        p += ptrSize
        if zerobase != nil {
            // If we're using a garbage collector, we need to make
            // sure that any memory allocated by the application is
            // initialized with zeros. We only do this if the memory
            // returned by the allocator is contiguous with the
            // zerobase region, forcing all Go allocations, no matter
            // the source (cgo, Go), to be forced to go through the
            // garbage collector. This is important for Go 1.5, where
            // the garbage collector checks if an object's pointer is
            // in a heap chunk that is still allocated.
            var sz uintptr
            n := numPhysPages
            for i := 0; i < n; i++ {
                if uintptr(unsafe.Pointer(&zerobase[i*physPageSize]))+size > uintptr(p) {
                    break
                }
                sz = size
            }
            if sz > 0 {
                memclrNoHeapPointers(p, size)
            }
        }
    }

    // ...
}
```

当我们调用`calloc()`函数时，它会首先调用`sysAlloc()`函数来申请指定大小的内存块。然后，`calloc()`函数判断`zerobase`是否为空，如果不为空，说明申请的内存块与`zerobase`指向的内存是相邻的，那么它就会将申请的内存块初始化为零值，确保其始终是正确的。因此，`zerobase`的作用是为了保证内存分配器能够使用非常快的方式去清空申请到的内存块，避免内存带来的问题。



### globalAlloc

globalAlloc是一个指向runtime.mheap类型的全局变量。它用于管理和分配堆空间。具体来说，它的作用包括以下几个方面：

1. 管理堆空间：globalAlloc是runtime.mheap的入口点，它包含了所有堆管理器的信息和状态。通过globalAlloc，可以对堆空间进行分配、释放等操作。

2. 内存分配：当Go程序需要分配内存时，会调用globalAlloc中的alloc函数。alloc函数会在堆空间中寻找一段合适的空闲内存块，并返回其地址，供程序使用。

3. 垃圾回收：Go语言使用了自动垃圾回收机制。globalAlloc会在引用计数器被清零时，调用堆空间的垃圾回收器。垃圾回收器会遍历堆空间中的所有对象，清理不再使用的垃圾内存，为程序释放内存空间。

4. 管理内存对象：globalAlloc还会管理堆空间中的所有内存对象。它会维护内存对象的元数据（如内存块大小、使用状态等），并进行相应的内存分配和回收操作。

总之，globalAlloc是一个非常重要的变量，它直接影响了Go程序的内存使用效率和性能。理解和掌握globalAlloc的作用，对于深入了解Go语言的内存管理机制和GC算法是非常有帮助的。



### persistentChunks

在go语言中，所有的内存分配都是由runtime库中的malloc函数来完成的。malloc.go文件是runtime库的一个重要组成部分，它定义了一些与内存分配相关的数据结构和函数。其中，persistentChunks变量是一个指向Chunk结构体的指针数组，用于存储在程序生命周期中一直存在的Chunk结构体。

Chunk结构体代表了一段内存块，并包含以下属性：

- intptr：指向内存块的指针
- next：指向下一个Chunk结构体的指针
- end：指向内存块的末尾

当程序需要分配内存时，malloc函数会首先在persistentChunks中查找是否有足够的Chunk结构体来满足当前请求。如果没有足够的Chunk结构体，malloc函数会调用chunkAlloc函数来分配额外的Chunk结构体，并将它们添加到persistentChunks中。

通过使用persistentChunks变量，runtime库可以有效地维护和管理内存块，减少了频繁地申请和释放内存的开销，提高了程序的性能和稳定性。






---

### Structs:

### persistentAlloc

persistentAlloc是用来管理内存永久化分配的结构体。在Go程序中，内存分配后会反复使用，但是当程序结束后，这块内存就会被释放回操作系统。为了保留程序退出后分配的内存，可以使用persistentAlloc来进行内存永久化的管理。

persistentAlloc使用mmap系统调用来分配内存，并将内存映射到文件中。在程序退出时，persistentAlloc会将内存持久化到磁盘中。当下次程序启动时，persistentAlloc会重新映射之前持久化的内存。

这种方式实现了内存永久化，可以用于需要长时间运行的服务。可以将一些常用的数据结构，比如哈希表、缓存等，持久化到磁盘中，避免程序重启时重新计算。

值得注意的是，persistentAlloc只适用于32位系统，因为在64位系统中，mmap的地址空间太大，持久化的开销太大。同时，在使用persistentAlloc时，也需要注意内存映射文件的大小不能超过系统限制。



### linearAlloc

在Go语言的运行时系统中，linearAlloc结构体是用于管理分配内存的结构体。它的作用是为即将分配的小型对象预分配内存，以提高分配内存的效率。

具体来说，linearAlloc结构体是由一个或多个内存块组成的，每个内存块都是一段连续的内存区域。在分配内存时，Go语言运行时系统首先检查上一个分配的内存块是否有剩余空间，如果有，则直接从其中分配空间。如果没有，则从当前的内存块中申请一个新的内存块，并将其添加到线性分配器的内存块列表中。

使用linearAlloc结构体的好处是可以避免频繁调用系统malloc函数，从而减少分配内存的开销。此外，由于分配的内存在同一个内存块中，因此内存访问的连续性得到了保证，可以提高程序的访问效率。

总之，linearAlloc结构体是Go语言运行时系统内存管理的重要组成部分，能够提高程序的性能和内存使用效率。



### notInHeap

notInHeap是一个包含指针的结构体，它的作用是标识一个对象不应该被分配到堆（heap）中。在Go语言中，GC（垃圾回收）是自动管理内存的，它会自动跟踪哪些对象是可达的，哪些对象是需要被回收的，以及哪些对象是不需要被回收的。不过，有些对象即使不用回收也不应该放在堆上，因为它们可能会被其它机制（例如Cgo）释放掉，这样就可能破坏了GC的一些假设，导致程序出现问题。

在malloc.go文件中，notInHeap结构体被用于一些特殊情况下的内存分配。例如，当使用Cgo调用外部函数时，它可能会返回一个指向不在堆中的内存区域的指针；在这种情况下，如果将这个指针传递给GC，GC可能会误认为这是一段内存地址并尝试对其进行回收，导致程序崩溃。

因此，notInHeap结构体的作用就是标识这些不应该被GC回收的内存区域，从而避免这样的问题发生。notInHeap的定义很简单，只是一个指针类型的成员变量，不过在Go语言的GC机制中却非常有用。



## Functions:

### mallocinit

在Go语言中，malloc.go文件中的mallocinit函数主要用于初始化堆和gc相关的函数和参数。具体来说，该函数会执行以下几个操作：

1. 调用mheap初始化堆。mheap是Go语言中用于管理堆的主要数据结构，包括对内存分配和回收的实现。

2. 初始化gc全局变量。包括gcpercent、gcphase和gcBgMarkWorkerMode等参数，用于控制垃圾回收的速度和方式。

3. 创建一个goroutine用于后台gc。该goroutine会定期检查gc相关的参数和状态，以确定何时执行垃圾回收操作。

4. 初始化malloc相关的数据结构和参数。这些参数包括minblocksize、maxblocksize和pagemask等，用于控制内存分配的大小和方式。

总之，mallocinit函数是Go语言中非常重要的一个函数，它负责初始化堆和内存分配等相关的参数和函数，保证程序能正常使用和管理内存。



### sysAlloc

sysAlloc函数是Go语言中的内存分配器的底层实现函数。它的作用是从操作系统申请一段内存空间，并返回相应的指针，供其上层函数使用。在Go语言的内存分配器中，sysAlloc函数主要负责内存的分配，以及对分配后的内存空间进行初始化等工作。

sysAlloc函数的具体实现依赖于操作系统的不同，但是通常它会调用一些系统级别的函数，如mmap或VirtualAlloc等，来实现内存分配。这些函数提供了高效的内存分配方式，并且可以提高应用程序的性能。

除了sysAlloc函数，Go语言中的内存分配器还包括其他一些函数，如mallocgc和calloc等。这些函数在实现上都是依赖于sysAlloc函数的。它们的主要作用就是根据不同的需求，调用sysAlloc函数进行内存的分配。

总之，sysAlloc函数是Go语言中内存分配器的重要组成部分，它的主要作用是实现内存分配和对分配后的内存空间进行初始化等工作，从而为上层函数提供高效的内存管理方式。



### sysReserveAligned

sysReserveAligned是一个在malloc.go中的函数，其作用是在进程的虚拟地址空间中分配一段连续的、对齐的、未映射的内存区域，并返回该区域的首地址。sysReserveAligned一般会分配更大的区域，用于备用和未来的需求。下面对该函数的详细介绍如下：

函数原型：

```go
func sysReserveAligned(bytes uintptr, align uintptr) unsafe.Pointer
```

参数：

- bytes：需要分配的内存区域的大小，以字节为单位。
- align：内存区域的对齐方式，以字节为单位。

返回值：

- 如果成功分配了未映射的内存区域，则返回该区域的首地址。如果分配失败，则返回nil。

该函数内部通过调用runtime_entersyscall和runtime_exitsyscall两个函数实现进程在系统调用期间的锁定和解锁。在分配内存前，该函数首先会将参数bytes和align进行向上舍入，以保证内存区域满足对齐要求。然后，该函数会调用sysReserve函数分配更大的连续内存区域，其中align参数用于保证分配的地址对齐。最后，该函数返回未映射区域的首地址。

总体来说，sysReserveAligned函数用于在进程的虚拟地址空间中分配对齐的、未映射的内存区域，这些区域一般用于备用和未来的需求。而sysReserveAligned函数是在malloc.go文件中实现的，在Go语言的运行时系统中扮演着重要的角色，确保了内存分配的高效性和可靠性。



### enableMetadataHugePages

enableMetadataHugePages函数的主要作用是启用或禁用元数据页的大页面分配。

在操作系统内核中，物理页框是由系统分配的连续物理内存块，每个物理页框的大小通常是4KB。对于大内存的应用程序，如果使用大量的小页面(4KB)来进行内存分配，会导致大量的内存碎片，浪费系统内存资源，并且降低系统的性能。针对这种情况，可以考虑使用大页面(如2MB或1GB)来进行内存分配，可以减少内存碎片，提高内存利用率和应用程序性能。

而对于Go语言的堆内存中的元数据页，也可以采用大页面来分配，需要使用一些特定的系统调用才能实现。其中，enableMetadataHugePages函数就是实现这种大页面分配的关键。

enableMetadataHugePages函数的实现过程如下：

1. 首先，通过syscall.NumHugePages函数获取系统支持的大页面的数量和大小(单位是page size)。

2. 然后，计算出元数据页需要的大页面数，和每个大页面的大小。

3. 如果元数据页需要的大页面数小于系统支持的大页面数，则通过syscall.Mmap函数映射相应数量的大页面，实现元数据页的大页面分配。

4. 如果元数据页需要的大页面数大于系统支持的大页面数，则调用runtime·printf函数打印一条错误信息，并返回失败。

5. 如果元数据页的大页面分配成功，则通过调用sysUnused函数标记大页面为已使用状态，避免被其他程序或进程使用。

总之，enableMetadataHugePages函数的主要作用是实现元数据页的大页面分配，以提高系统内存利用率和Go程序性能。



### nextFreeFast

nextFreeFast函数是Go语言运行时中的内存分配器malloc的一部分，它的作用是从位图中查找下一个空闲的页框，并返回其地址。

在Go语言中，内存分配器malloc的主要职责是为程序动态分配内存。为了优化内存分配的性能，malloc将大块的内存分割成小块，然后将每个小块与一个位图中的位（bit）对应。这个位图记录了当前哪些块是被占用的，哪些块是空闲的。当应用程序需要动态分配内存时，malloc会在位图中查找一个空闲的块，将其标记为已占用，并返回其地址。

nextFreeFast函数是malloc的一部分，其主要任务是实现快速的位图扫描，以查找下一个未被占用的块。在实现上，它将位图按照8个字节（64位）进行分块，快速地扫描每个块，以查找该块中第一个为0的位。最终，该函数会返回第一个未被占用的块的地址。

重要的是要注意，nextFreeFast只是内存分配器malloc的一部分。在Go语言中，内存在创建时并不会立刻被malloc分配。取而代之的是，malloc会在需要时为应用程序动态地分配内存。因此，nextFreeFast函数会被调用多次，并且在不同的时间点分别执行。每次调用都会搜索位图，查找下一个未被占用的块。



### nextFree

nextFree函数是Go语言中的堆内存分配器的一个函数，其作用是在当前的heapArena对象中寻找下一个可用的chunk区域。

在Go语言中，内存的分配是通过堆进行的。当程序需要分配内存时，Go语言会从heapArena中选择一个空闲的chunk区域来分配。nextFree函数会在heapArena中从当前的chunk区域开始寻找，如果当前的chunk区域已经被分配，就会继续寻找下一个可用的chunk区域，直到找到一个未分配的chunk区域为止。

该函数首先会检查当前的chunk区域是否已经被分配，如果已经被分配，则会跳转到下一个chunk区域。如果遍历完所有的chunk区域还未找到可用区域，则会重新分配一个新的chunk空间。

通过nextFree函数的调用，Go语言可以在堆内存中高效地分配内存空间，确保程序的运行效率和资源利用率。



### mallocgc

在go语言中，使用malloc函数来分配内存。malloc函数是在操作系统中分配内存的，它会在操作系统中申请一块内存空间，并返回一个指向这块内存的指针。但是，go语言提供了自己的内存管理机制，其中包括适用于固定大小的对象的堆空间，适用于大对象的分配器等。mallocgc是其中的一个函数，它的作用是用于从堆空间分配内存。

具体来说，mallocgc函数分配了一段大小为size的内存空间，并返回一个指向这段内存空间的指针。在这个过程中，如果堆空间不足以容纳大小为size的内存空间，那么mallocgc函数会使用垃圾回收器来释放不再使用的内存空间，以便为新的内存分配腾出空间。在分配内存的过程中，mallocgc函数会考虑对象大小和对齐等因素，以保证分配的内存空间可以有效地被利用和管理。

因此，mallocgc函数是go语言中内存管理机制的核心之一。它负责从堆空间分配内存，并确保这些内存可以被有效地管理和利用，同时也保证了垃圾回收功能的正常运行。



### deductAssistCredit

deductAssistCredit是Go语言中管理内存的函数之一，主要用于协助内存分配器（memory allocator）选择Goroutine（Go语言中的协程）队列中最适合的Goroutine来执行分配或释放内存的操作。

当我们在Go语言中使用new或make操作符来动态分配内存时，Go语言的运行时系统（runtime）会自动为我们管理内存分配和回收的操作。在分配内存时，Go语言的运行时系统会判断当前需要运行的Goroutine的活跃程度，为其分配相应的内存，从而尽可能减少内存的浪费。

其中，deductAssistCredit函数的作用是为分配器（memory allocator）提供“扣除协程信用”（deduct assist credit）的功能。所谓协程信用是指分配器为每个协程分配的一定数量的内存。当某个协程需要分配一定数量的内存时，分配器会检查其协程信用是否足够，如果足够，则直接分配，如果不足，则需要扣除协程信用以避免内存浪费。

具体而言，deductAssistCredit函数的主要实现是通过一定的算法计算当前协程的休眠时间，然后根据该时间向该协程的协程信用中扣除一定数量的信用分数，从而降低该协程在内存分配过程中的优先级，使得其他协程有更大的机会来分配或释放内存操作。

总之，deductAssistCredit函数的作用是协助内存分配器选择最适合的Goroutine来执行分配或释放内存的操作，以实现更加高效和智能的内存管理。



### memclrNoHeapPointersChunked

memclrNoHeapPointersChunked是runtime包中malloc.go文件中的函数之一，其主要作用是清空给定的内存块。

在实际的编程中，经常需要清空内存块，以便对其进行重新利用或重置。在Go语言中，可以使用内置函数`make`和`new`创建动态分配内存块。但是，使用动态分配的内存块时，需要清空其中的数据。而memclrNoHeapPointersChunked函数就是用来实现清空内存块的操作。

memclrNoHeapPointersChunked函数采用分块的方式进行内存清零操作，每块内存大小为chunkSize（默认值为256字节）。在清空内存的过程中，函数会跳过指向堆的指针，不会影响已经分配的堆内存。

通过memclrNoHeapPointersChunked函数清空内存块可以有效地提高程序的运行效率，因为该函数的底层实现是用汇编代码编写的，运行速度非常快，特别是在大规模内存清空操作时，效率尤为显著。



### newobject

newobject函数的作用是用于分配一个新的对象，并返回一个指向该对象的指针。

具体来说，newobject函数首先根据给定的类型size确定所需的内存大小，并将其对齐到对象的最小对齐方式。然后它会从内存池中查找可用的、足够大的内存块，如果找到了则将这个内存块标记为正在使用，并返回一个指向该内存块起始地址的指针；如果没有找到合适的内存块，则会向操作系统请求一块新的内存，并返回指向该内存起始地址的指针。

此外，newobject函数还会设置对象的类型信息和分配相关的元数据，并对内存块进行清零操作，以确保新分配的对象的所有字段和元素都被初始化为零值。这样可以保证程序不会访问到未初始化的内存，避免因此出现未知的错误。

总之，newobject函数是Go语言运行时中的内存分配函数之一，为创建新的对象提供了方便、高效、安全的支持。



### reflect_unsafe_New

reflect_unsafe_New这个func的作用是用于创建一个新的指向类型t的未初始化的指针。这个函数是在运行时中被调用的，通常是由反射库调用的。它允许代码在运行时动态地创建新的值并初始化它们，而不需要在编译时硬编码类型信息。

使用这个函数创建的值是未初始化的，因此必须根据它的类型来初始化它。这可以通过TypeOf、Elem和其他反射函数实现。

这个函数的实现使用了类似于C中的malloc函数的机制来分配内存。首先它计算出所请求的内存大小，然后它检查是否已经超出了堆分配器限制，最后它请求调用mheap.alloc函数来分配内存。然后它将指针转换为unsafe.Pointer类型并返回。

需要注意的是，这个函数是一个低级函数，应该谨慎使用。它可能会导致内存泄漏和其他问题，因此应该优先考虑使用更高级别的接口，例如make和new函数。



### reflectlite_unsafe_New

该函数reflectlite_unsafe_New是用于创建一个指定类型的空对象，该对象不包含任何字段或其它数据的结构体。该函数的功能类似于golang中的 new 函数，但是在性能上更加高效，因为它使用了unsafe包，可以直接操作内存，而不需要通过golang的对象初始化机制。

在runtime中，malloc.go是用于实现内存分配的代码。在该文件中，提供了一些基础的内存分配函数，如mallocgc、malloc和calloc等等。同时还提供了一些辅助函数，如设置内存对齐的函数memalign和计算内存页大小的函数pagesize。

reflectlite_unsafe_New函数是在malloc.go中创建的，通过使用 unsafe 包提供的指针操作，通过调用 runtime_rawmem 可以创建一个指定类型的空对象。这个空对象包含了它所代表的类型信息，但是不包含具体的字段数据。通常情况下，我们可以在这个空对象的基础上，使用golang中的各种函数和方法来初始化具体的字段数据，以达到定制化的需求。



### newarray

在 Go 语言中，newarray 函数是用来创建数组的。它是 runtime 包中的一个函数，通过用于分配新的数组的底层机制，将指定类型的数组以及元素数量传递给参数，并返回一个指向新分配的数组的指针。以下是它的函数签名：

```
func newarray(t *rtype, nel int) unsafe.Pointer {
    ...    
}
```

参数 t 是元素类型的反射信息，nel 是要分配的数组的元素数量。函数返回一个指向新分配的数组的指针。

newarray 函数内部会调用 mallocgc 函数来动态分配内存空间。这个函数将创建新的数组结构，然后在堆上分配足够的空间来保存该数组的元素。这个函数返回的指针指向了实际的数组数据。

newarray 函数还包含一些特殊的逻辑，用于处理不同类型的数组。例如，对于字符串数组，它将分配足够的内存来存储每个字符串的指针和每个字符串的长度，然后将这些指针和长度存储在新分配的数组中。

newarray 函数是非常重要的，因为它允许我们在 Go 语言中创建动态数组。这是创建许多高级数据结构的必要步骤，例如列表，栈和队列。此外，在 Go 语言中，所有的数组都是动态分配的，而不是静态的，因此 newarray 函数是实现动态数组的必要工具。



### reflect_unsafe_NewArray

reflect_unsafe_NewArray函数是Go语言标准库中runtime包中malloc.go文件中的一个函数，它的作用是用于为任意类型创建指定长度的数组，并返回数组的指针。该函数的实现非常关键，因为它是Go语言中动态创建数组的基础。

在Go语言中，reflect_unsafe_NewArray函数实现了一个内部的调用（allocateType方法），该方法使用传入的类型和长度来计算数组的总大小，并调用mallocgc函数为数组分配内存。当该函数被调用时，它会检查类型t（表示数组的元素类型）是否是reflect.SliceHeader类型，如果是，则允许该函数直接返回一个指向reflect.SliceHeader的指针，以便尽可能地将内存分配解除多余的工作。

该函数的具体代码实现可以参考Go语言标准库runtime包中malloc.go文件的源代码。这个函数在底层实现中使用了很多的unsafe包的操作，是比较复杂的实现逻辑。通过该函数，我们可以根据任意类型和长度来创建动态数组，并在程序运行时进行灵活的内存管理。



### profilealloc

在go语言中，profilealloc函数是一个调试和性能分析函数，它用于分析内存分配的情况。该函数使用的是当前线程堆空间的分配情况来生成一个分配记录。这个函数在runtime的malloc.go文件中定义，在调用中会使用gopark函数使当前线程进入休眠状态，然后生成分配记录。该记录包含当前线程的堆内存分配情况，标识线程所在的堆区域，以及分配的大小等信息。

这个功能主要用于分析应用程序的堆内存分配情况，帮助开发者找出内存泄漏和性能瓶颈等问题。通过profilealloc函数可以实时监控内存的分配情况，同时还可以输出分析报告，帮助开发者快速定位问题所在。该函数在调试和优化代码时非常有用，尤其是在处理大量数据时，可以帮助开发者快速找到内存泄漏和性能瓶颈，提高代码质量和性能表现。



### nextSample

在 Go 语言中，内存分配是由运行时库(runtime)负责的。malloc.go 这个文件是 runtime 的一部分，它具体实现了 Go 语言中的内存分配。而 nextSample 函数是 malloc.go 中的一个函数，用于管理内存分配的采样。下面详细介绍其作用：

在 Go 程序中，内存分配是一个非常重要的操作，对于性能和内存使用情况都有相当的影响。为了更好地了解应用程序的内存使用情况，Go 语言内置了一个内存分析工具 pprof 。在 pprof 中，可以通过访问调查报告来查看内存使用情况，同时还可以进行进一步的分析。而程序内部，内存分配的采样也是实现这个功能的重要组成部分。

在 malloc.go 中，nextSample 函数的作用是进行内存分配采样，记录内存分配的情况，并根据这些情况生成采样介质。这些采样介质被保存在 mcache 和 mheap 中。接下来，预留的额外存储空间将用于之后的新分配和垃圾回收。

但在实际使用中，由于采样和内存分配之间存在抵触，使用过多的采样会影响内存分配的速度和性能。因此，采样的数量不能太多，也不能过于频繁。

所以 nextSample 函数实际上是对采样过程的一个优化，确保在采样时能够保持性能，确保生成有效的采样介质，并减少采样时对内存分配本身的干扰，同时也确保内存分配的速度和性能不受影响。



### fastexprand

在Go语言中，fastexprand函数是一个快速的伪随机数生成器。该函数使用多项式计算来生成随机数。具体而言，它使用XORSHIFT算法实现了一个32位的线性同余算法，并使用一个32位的乘法多项式来将结果与状态进行混合。

fastexprand函数用于生成随机内存地址，以确保每个分配的内存块都具有不同的地址。这对于垃圾收集和内存管理非常重要，可以避免分代垃圾收集器发生内存碎片。

当Go程序需要分配内存时，会调用malloc.go文件中的相关函数来执行分配操作。例如，如果程序使用了make函数或new函数来创建新的对象，则会调用mallocgc函数来分配内存。在分配内存之前，该函数会调用fastexprand函数来生成一个随机数，用于分配新内存的地址。

总体来说，fastexprand函数是Go运行时的一个重要组件，用于支持内存管理和垃圾回收操作。它可以保证分配的内存块具有唯一的地址，并且具有足够的随机性来避免内存碎片。



### nextSampleNoFP

nextSampleNoFP函数是在Go语言运行时系统中的malloc.go文件中的一个函数，它的主要目的是为了获得下一个用于采样的PC值。

在Go语言中，程序在运行时会通过runtime包来进行内存管理。runtime包包括了各种函数和结构体，可以对程序的内存分配和释放等操作进行管理和优化。其中，malloc.go文件是runtime包中的一个核心文件，它定义了在堆上分配和释放内存的函数。

在这个文件中，nextSampleNoFP函数主要用于在进行Go程序性能分析时，获得当前的PC值。它会在Go程序中的每个采样点处方便地更新并记录PC值。这些采样点通常会在程序的一些热点位置中触发，通过记录这些位置的PC值，可以帮助开发者进行程序的优化。

具体来说，nextSampleNoFP函数会首先从当前的PC值（程序计数器）中获取一个哈希值，并将其保存到样本计数器（sampleCounter）中。然后，它会从记录样本位置的数组中获取下一个采样点的索引值，并将其保存到数组中。最后，函数返回当前的PC值，以便于在下一个采样点处使用。



### persistentalloc

在Go语言的运行时系统中，persistentalloc是一个用于分配persistent memory（持续性内存）的函数，即在进程重启后也会持久存在的内存。它通过调用mheap.palloc函数实现分配内存的功能。

该函数的作用是支持对某些需要持续存储的数据进行分配和释放，以满足程序对持久化数据的需求。比如可以通过该函数分配一块持久的内存用来存储程序的配置信息、日志等。

persistentalloc的实现源代码中，主要通过mheap.palloc函数分配一块指定大小的内存，并标记为不可回收状态，即进程运行期间保持一直存在。当不需要该块内存时，可以使用mheap.pfree函数主动释放内存。

在Go语言的标准库中，也提供了与persistent memory相关的库函数，比如sync.Map中的Load和Store方法，就支持将map中的数据持久化存储。同时，在Go语言社区中也有一些开源的persistent memory库，如NVM-Go，让开发者更加方便地使用和管理persistent memory。



### persistentalloc1

`persistentalloc1` 是 Go 语言运行时中与内存分配有关的函数之一，其主要作用是分配一个固定大小的内存区域，并将其标记为不可释放（也就是“持久”）。这意味着这个内存区域在生命周期内不会被垃圾回收器回收。

具体来说，`persistentalloc1` 函数的实现将开始地址和长度以及一个标志位保存在一个 `mheap` 结构中的 `persistent` 字段中，这样就可以标记这个内存区域成为“持久内存”。在以后的内存分配中，如果 `persistent` 字段中有标记位，则优先尝试从中分配内存，这样可以有效减少因为频繁分配和释放而导致的性能损失。

这个函数主要用于一些需要长时间保持的对象，例如 Go 中的 goroutine 调度器、内存池等等，这些对象在整个程序的生命周期内都需要保持内存，不会被释放。使用 `persistentalloc1` 可以有效减少程序因为频繁分配和释放内存而导致的性能损失，提高程序的执行效率。



### inPersistentAlloc

在Go语言中，inPersistentAlloc函数是在runtime包下的malloc.go文件中定义的。该函数实现了一种直接从操作系统申请内存的分配方案，被用于在程序运行期间动态分配大量内存时提高性能。inPersistentAlloc函数的主要作用是使用mmap系统调用，在运行时向操作系统请求一块连续的虚拟地址空间，并在分配的地址空间上进行内存分配。

在调用inPersistentAlloc函数时，可以通过传入一个整数类型的参数size，该参数指定了需要分配的内存大小。函数返回的是一个unsafe.Pointer类型的指针，该指针指向分配的内存块的起始地址。在函数调用结束后，分配的内存块可以被程序员使用，并可以随时访问其中的数据。

需要注意的是，由于inPersistentAlloc实现的是直接从操作系统申请内存的分配方式，因此使用该函数分配的内存块不会被Go自动垃圾回收处理。程序员需要手动释放所分配的全部内存，以避免出现内存泄漏的问题。



### init

在 `go/src/runtime` 目录中的 `malloc.go` 文件中，有一个 `init` 函数，它的作用是在 `runtime` 包被导入时进行一些初始化工作。

`init` 函数主要完成以下工作：

1. 初始化 `smallSizeMaxClass` 和 `largeSizeMaxClass` 数组

这些数组包含了从 8 字节到 1<<30（1GB）大的堆块的大小，以及对应的 span 的 class 大小。这些数组用于计算申请内存时需要的 class 大小。

2. 初始化 `mheap` 和 `memstats` 变量

`mheap` 变量代表了堆内存的管理器，用于分配和释放内存。`memstats` 变量包含了有关内存使用情况和内存分配器性能的统计信息。

3. 初始化 `central` 等变量

`central` 代表了中央堆，用于分配较大的对象。`tiny` 和 `tinyNoSplit` 代表了用于分配小对象的 tcache。`spanAlloc` 等变量代表了用于分配 span 在内存池中的对象。

4. 注册 `semaevent` 变量

在分配和释放内存时使用的信号量。

总的来说，`init` 函数初始化了各种数据结构和变量，为内存分配器的正常工作准备了必要的条件。



### alloc

在 Go 语言中，`malloc.go` 文件中的 `alloc` 函数用于为堆分配器分配内存。

具体来说，`alloc` 函数的作用是：

1. 从自由列表（free list）中寻找合适大小的空闲区块，如果存在，则直接分配；否则进入下一步。

2. 从堆空间中分配新的空闲区块，如果分配成功，则返回；否则执行下一步。

3. 如果分配失败，调用 `GC` 进行垃圾回收，并判断是否需要扩展堆空间。如果需要扩展堆空间，则调用 `sysAlloc` 分配更多的物理内存，并将其添加到堆中，然后再次尝试分配。

值得注意的是，`alloc` 函数还需要处理内存对齐等细节问题，以确保分配的内存区块满足应用程序的需求。同时，该函数还要记录分配的内存总量和内存分配次数等统计信息，以用于后续的性能分析和测试。

总之，`alloc` 函数在堆分配器中扮演着至关重要的角色，其效率和稳定性直接影响着 Go 程序的性能和可靠性。



### add

add这个func的作用是将一段连续的空闲内存块加入到空闲链表中。

具体地说，当一个内存块被释放时，会通过add函数将其加入到一个空闲链表中，以便之后的内存分配能够使用它。add函数会根据内存块的大小将其分配到相应的空闲链表中，这样可以使得分配更为高效。另外，add函数还会检查是否有相邻的空闲内存块，如果有的话还会将它们合并起来，以提高内存利用率。

总之，add函数是用来管理内存块的空闲链表的，它会将内存块分配到相应的链表中，并且能够合并相邻的空闲内存块，实现更高效的内存管理。



### computeRZlog

在go语言中，malloc.go文件是与内存分配（即动态分配和回收）相关的核心文件之一。其中的computeRZlog函数用于计算并返回虚拟地址空间中z的对数值（即log2(z)）。由于在内存分配时需要对内存进行对齐，因此计算z的值非常重要。

具体来说，computeRZlog函数的作用如下：

1.确定可用空间：通过计算计算z的对数值，可以确定可用空间的大小。

2.确定对齐方式：计算z的值还可以确定用于对齐的位数（即2^z），因此可以确定对齐方式。

3.减少内存浪费：通过使用适当的对齐方式，可以最大程度地减少内存浪费，提高系统性能和效率。

总之，computeRZlog函数在go语言的内存分配过程中起着重要的作用，可以帮助系统有效地管理内存，提高系统性能和效率。



