# File: mgclimit.go

mgclimit.go文件是Golang语言标准库中runtime包的一个文件，它的作用是为了限制应用程序中的内存使用。它通过设置内存分配的阈值来控制垃圾回收器的活动，以及减少闲置的内存占用。

具体来说，mgclimit.go文件中定义了两个全局变量：heapMinimum和heapGoal，它们分别表示堆的最小大小和目标大小。在程序运行时，这些变量的值会被动态调整，以便根据实际的内存使用情况来控制垃圾回收器的行为。例如，当heapGoal的值超过了heapMinimum时，垃圾回收器会开始运行，并尝试清理堆中不再使用的内存。

此外，mgclimit.go文件还定义了一个mgcSysStat结构体，用于记录系统的内存使用情况，包括当前总内存大小、已分配内存大小、已使用内存大小等，它被用于控制内存的分配和释放。

总而言之，mgclimit.go文件提供了Golang运行时环境中内存管理的核心机制，它的实现能够在保证运行效率的前提下，有效地控制应用程序对内存的占用，从而实现更加健壮的应用程序。




---

### Var:

### gcCPULimiter

gcCPULimiter变量是用于控制GC（Garbage Collection，垃圾回收）时占用CPU的百分比的变量。在mgclimit.go文件中，gcCPULimiter是定义为一个float64类型的变量，默认值为1.0。

在Go语言中，GC会在程序中运行一段时间后自动生效，以回收不再使用的内存。在执行GC期间，会占用CPU的一定比例来执行垃圾回收操作。gcCPULimiter变量的作用就是控制GC占用CPU的百分比。具体来说，当GC执行时，它会检查当前可用的CPU资源，计算出可以使用的CPU时间，并将这个时间乘以gcCPULimiter的值，得到最终GC占用CPU的时间。

例如，如果gcCPULimiter的值为0.5，表示GC最多可以占用可用CPU时间的50%。如果当前可用CPU时间为1秒，那么当GC执行时，它只会占用0.5秒的CPU时间，另外0.5秒的CPU时间会留给其他程序使用。

gcCPULimiter的使用可以帮助程序避免长时间占用CPU导致的性能问题，特别是当其他程序需要共享CPU资源时。






---

### Structs:

### gcCPULimiterState

在Go语言中，垃圾回收（GC）是自动进行的，由运行时（runtime）系统自动调用。在进行垃圾回收操作时，需要使用大量的CPU资源，因此为了在不影响程序正常运行的前提下优化垃圾回收的效率，Go语言引入了CPU利用率限制机制。

gcCPULimiterState结构体就是用于记录当前CPU利用率限制状态的数据结构。它包含以下几个主要的成员变量：

- lastTickCount：记录上一次确定限制状态时的时间戳；
- maxTickCount：记录计算出的最大可用时间戳；
- tickCount：记录当前已经使用的时间戳数量；
- depleted：标识当前是否已经用尽了可用的时间戳，即是否达到了CPU利用率限制的上限；
- lastDone：记录上一次垃圾回收操作的时间戳；
- curGCTime：记录当前垃圾回收操作消耗的时间戳数量。

该结构体在mgclimit.go文件中被大量使用，用于计算当前的CPU利用率限制状态，并根据状态调整垃圾回收操作的时间间隔。具体而言，当GC操作结束后，会根据当前的GC时间、上一次GC时间、CPU利用率限制状态等信息计算出下一次GC操作的时间间隔，以达到平衡垃圾回收效率和系统性能的目的。



### limiterEventType

在go/src/runtime中mgclimit.go文件中，limiterEventType这个结构体定义了垃圾回收器限制的事件类型。它是一个枚举类型，包含了以下几种事件类型：

1. actionEv：表示垃圾回收器做出了某种行动，例如开始执行垃圾回收或者调整了垃圾回收器的限制。
2. enableEv：表示垃圾回收器被启用了，开始真正执行垃圾回收。
3. disableEv：表示垃圾回收器被禁用了，停止执行垃圾回收。

这些事件类型会在垃圾回收器执行的过程中被用来传递信息。通过记录这些事件，可以更好地理解垃圾回收器是如何执行的，以及如何根据不同的情况进行优化。同时，它还可以用来监视垃圾回收器的行动，以及调整垃圾回收器的限制，以满足不同的应用场景需求。



### limiterEventStamp

在go/src/runtime/mgclimit.go中，limiterEventStamp结构体定义了垃圾收集限制器事件的时间戳，它包含以下字段：

- seq：标识事件的递增序列号。
- when：事件发生的时间戳，以纳秒为单位。

这个结构体的作用是记录垃圾收集限制器中重要事件的发生时间，例如当垃圾收集限制器开始限制标记阶段的并发数时或者限制器限制标记的最长时间时，都会记录下这些事件的发生时间。

这些记录的时间戳可以被用来监测垃圾收集的性能，并且可以作为调整垃圾收集参数的依据。例如，如果发现垃圾收集限制器在一段时间内频繁地限制并发标记数量或者限制标记的时间，则说明垃圾收集器需要更好的调整或者机器需要更多的资源。

总之，limiterEventStamp结构体提供了对垃圾收集限制器事件的跟踪和监测，帮助开发者更好地了解垃圾收集器的行为和性能，并对垃圾收集器进行优化和调整。



### limiterEvent

在Go语言运行时的mgclimit.go文件中，limiterEvent结构体是用于记录GC限制事件的结构体。当Go语言运行时触发GC时，limiterEvent结构体会被用来记录各种GC限制事件，例如内存超过了预设的限制，导致运行时需要执行GC来释放内存等。

limiterEvent结构体主要有以下几个字段：

- minBytes：引入当前限制事件的最小字节数；
- duration：引入当前限制事件的持续时间；
- cause：引入当前限制事件的原因；
- next：下一个GC限制事件。

当记录了一些限制事件之后，可以使用limiterEvent.getBaseTime()方法来计算总的GC限制时间。在运行时，如果GC限制事件超过了总的GC限制时间，则会触发运行时主动执行GC，释放内存。如果总的GC限制事件没有超过总的GC限制时间，则不会执行GC。

总之，limiterEvent结构体的作用在于跟踪运行时对内存的使用量，并通过记录GC限制事件来触发运行时主动执行GC，保证程序的内存使用在可控的范围内，避免内存溢出等问题。



## Functions:

### limiting

在go/src/runtime中，mgclimit.go文件的limiting函数用于限制堆内存的增长。堆内存是指用于存储动态分配的数据的内存空间，堆内存的增长需要操作系统提供的虚拟内存资源支持。如果程序一直在申请堆内存而不释放，会导致操作系统的虚拟内存资源不足，进而导致程序崩溃或系统崩溃。

在limiting函数中，首先获取当前堆内存占用的总量，然后判断是否超过了最大限制（指定的堆内存大小限制）以及触发GC的最小间隔时间（即上次GC时间距离当前时间是否已经超过设定的最小时间阈值）。如果满足其中任意一个条件，就会触发GC，回收一些不再使用的内存资源，以腾出空间给新的对象使用。

这样就可以通过限制堆内存的增长，来避免程序的内存占用过大而导致的性能问题或崩溃问题，从而保证程序的稳定可靠性。



### startGCTransition

startGCTransition函数是Go语言运行时的垃圾回收机制中的重要函数之一。它的作用是启动_GC()函数的执行，并且将当前的堆栈（g.stack）和全局状态（g.m.state）设置为GC执行中的状态，以便进行垃圾回收。

在Go语言的垃圾回收机制中，为了尽量减少GC的影响，使用了并发垃圾回收的技术。在并发垃圾回收中，当堆的内存使用量达到了一定阈值时，就会启动垃圾回收程序进行清理。而在启动垃圾回收程序之前，需要先进行一些状态的设置和检查。这些工作都是由startGCTransition函数来完成的。

具体来说，startGCTransition函数会先检查当前是否正在进行垃圾回收。如果是，就说明有其他垃圾回收程序正在运行，需要等待其完成后再执行本次垃圾回收。如果没有正在进行的垃圾回收，就会设置g.m.state为_Grunning并将g.stack标记为正在使用中。然后它会调用_GC()函数进行垃圾回收，并在垃圾回收完成后将g.m.state设置为_Grunning和将g.stack标记为未使用状态。

总之，startGCTransition函数是Go语言运行时垃圾回收机制中的一个重要函数，它确保将当前的执行状态设置为适当的状态，以便进行垃圾回收。它的执行是垃圾回收机制中非常关键的一部分，直接影响着应用程序的性能和稳定性。



### finishGCTransition

在Go语言的垃圾回收机制中，当一个P（Processor）处理器从运行Go代码的状态转换为停止Go代码的状态时，就会涉及到垃圾回收（GC）的过渡。

在mgclimit.go文件中，finishGCTransition函数的作用就是完成这个过渡。具体来说，该函数会做以下几件事情：

1. 将当前P的状态设置为_Pgcstop。这个状态表示P已经停止执行Go代码并准备参与垃圾回收。

2. 获取当前GC的信息，并将其保存到P的gcAssistBytes字段中。这个信息包括当前GC的目标heap大小、当前heap大小和标记阶段时需要扫描的根对象数等。

3. 根据当前P的状态和GC的信息来计算该P参与的GC的扫描比例。该值表示在GC的标记阶段中，该P将承担多少比例的扫描任务。

4. 将本地缓存中的heap字节数清零，防止GC期间继续分配新的对象。

5. 最后，将当前P添加到全局的待扫描P列表中。这个列表包括所有等待执行扫描任务的P，GC会从这个列表中选择P来执行扫描任务。

总的来说，finishGCTransition函数的作用就是准备当前P参与垃圾回收，并为该P分配适当的GC扫描任务。



### needUpdate

需要明确的是，Go语言中的`mgclimit`模块实现了协程堆内存的管理，包含内存的分配、释放以及垃圾回收等操作。而`mgclimit.go`文件中的`needUpdate`函数主要用于检查当前系统内存使用情况是否达到了内存限制阈值，若达到阈值则需要调整协程绑定的内存大小。

具体来说，`needUpdate`函数的作用主要有以下几个方面：

1. 检查当前系统内存使用情况是否达到了限制阈值

在垃圾回收过程中，我们需要检查当前系统内存的使用情况，判断是否需要进行调整。因为如果系统内存使用量已经达到了协程的内存限制上限，那么我们就需要增大协程的内存限制，否则可能会导致内存溢出等问题。

`needUpdate`函数中的实现逻辑是通过比较两个阈值来判断当前系统内存使用情况是否达到了上限。具体来说，我们定义了一个阈值`memLimitSys`表示系统内存的限制上限，另一个阈值`memLimitChange`表示系统内存需要调整的限制上限。通过比较这两个阈值，我们可以得知是否需要调整系统内存的限制。

2. 根据实际内存使用情况调整协程的内存限制

如果当前系统内存使用情况已经达到了内存限制阈值，我们就需要根据实际内存使用情况来调整协程的内存限制。具体来说，我们需要计算出当前内存使用量与系统内存限制上限之间的差值，并根据差值来调整协程的内存限制。

3. 避免过度调整内存限制

在调整内存限制时，我们需要注意避免过度调整导致协程内存效率降低的问题。因此，在`needUpdate`函数中我们设置了一个阈值`heapMinimum`，用于避免在内存使用量较小的情况下过度调整协程的内存限制。如果当前内存使用量与协程内存限制之间的差值小于`heapMinimum`，则不会进行内存限制的调整。

综上所述，`needUpdate`函数主要用于检查当前系统内存使用情况是否达到内存限制阈值，并根据实际情况来调整协程的内存限制，避免因内存限制不足导致程序崩溃或者内存浪费的问题。



### addAssistTime

在go语言的垃圾回收机制中，当当前的内存使用率超过了一定程度，垃圾回收机制就会被触发。在进行垃圾回收的过程中，可能会涉及到一些辅助线程（assist goroutine），这些线程会帮助垃圾回收线程完成一些额外的工作，从而提高回收的效率。在mgclimit.go文件中，addAssistTime这个函数就是用来记录辅助线程工作时间的。

具体来说，当一个辅助线程开始工作时，会调用addAssistTime函数，该函数将当前的时间戳与assistStartTime进行比较，得出该线程的工作时长，并将其累加到gcController.assistTime上。gcController结构体是垃圾回收的控制器，它负责记录各种垃圾回收的状态信息，并通过一些算法来控制垃圾回收的进程。

在addAssistTime函数的实现中，还包含了一些边界条件的处理，例如如果当前的时间戳小于assistStartTime，就会将startTime置为当前的时间戳，从而保证计算出来的时长是正确的。

总之，addAssistTime函数的作用是记录辅助线程的工作时长，从而帮助gcController控制垃圾回收的进程，提高回收的效率。



### addIdleTime

在Go语言的运行时中，可以通过设置一个全局变量（GOMAXPROCS）来控制运行时中的并发线程数。而在实际运行过程中，Go语言的运行时系统会动态进行协程的创建和销毁。由于这种动态管理的特点，当协程的数量过多时，运行时系统需要采取一些措施来保证程序的运行效率。

mgclimit.go是在运行时中用于管理协程数目的代码文件之一，其中的addIdleTime()函数的作用是调整系统的参数以便管理协程的数量。具体来说，该函数会根据当前运行时中闲置协程（无任务需要执行的协程）的数量来调整系统参数。当空闲协程数目大于一定阈值时，系统会增加每个协程的睡眠时间，从而减少协程的数量。反之，系统会减少每个协程的睡眠时间以增加协程数量。

调整协程数量是一个复杂的问题，需要平衡运行效率和协程利用率，以达到最优的处理效果。在实际使用过程中，Go语言的运行时系统会通过各种参数调整和智能算法来动态管理协程数量，从而提升并发性能。addIdleTime()函数是其中的一部分实现，用于在系统的空闲协程较多时进行调整。



### update

update函数是runtime包中mgclimit.go文件中的一个函数，它的作用是更新垃圾回收的限制。

在Go语言中，垃圾回收是自动进行的。当程序需要分配内存时，垃圾回收器会检查当前堆的使用情况，如果达到了一定的阈值，就会进行垃圾回收操作，通过回收已经不再使用的内存来释放空间。

update函数的作用是更新垃圾回收的限制。在调用update函数时，会更新一些与垃圾回收相关的限制参数，例如最大堆大小、最大对象个数、垃圾回收阈值等，使这些参数能够适应当前程序的内存使用情况。

具体来说，update函数会根据当前系统的物理内存大小和当前程序的内存使用情况，计算出一个新的最大堆大小和最大对象个数，然后将这些参数更新到运行时环境中。同时，它还会计算出一个新的GC阈值，并将其更新到每个P中。

通过调用update函数，我们可以优化垃圾回收的性能，使其不会浪费过多的时间在回收已经不再使用的内存上，也不会占用过多的内存资源。这样可以提高程序的运行效率，使其更稳定、更可靠。



### updateLocked

updateLocked函数位于mgclimit.go文件中，主要作用是更新线程堆栈缓存的大小限制。当goroutine执行时，它的堆栈大小是动态调整的。如果goroutine需要更多的堆栈空间，它会在堆栈中动态分配更多的空间。但是线程堆栈缓存大小是有限制的。在每次调度之前，线程需要检查自己堆栈缓存中的指针指向并将其标记为 快照。

updateLocked函数在每次垃圾回收时被调用。它首先检查当前的 堆栈使用情况，并计算出堆栈缓存的新大小限制。然后，如果新大小限制没有超过已分配的堆栈缓存，它将堆栈缓存大小设为新限制。否则，它会重新分配一个更大的缓存，并将其分配给当前线程。当然，这个操作需要协助调度器和垃圾回收器，因为它可能会改变当前线程的状态，例如需要重新调度或阻塞。

总之，updateLocked函数的作用是管理线程的堆栈缓存，动态调整堆栈缓存大小限制，并确保垃圾回收器和调度器能够正确工作。



### accumulate

在go语言中，mgclimit.go文件包含了与垃圾回收器相关的限制和算法，其中的accumulate函数用于计算当前堆大小（heapSize）与垃圾回收标记阈值（gcTrigger）之间的差值（delta）。

该函数在每次分配内存时被调用，以检查当前堆的大小是否超过了gcTrigger的阈值，如果超过了，则标记已分配的对象，然后执行一次垃圾回收操作。如果没有超过gcTrigger，函数将累加delta值，直到达到一个预定的目标大小，然后执行一次垃圾回收操作。

accumulate函数实现了动态调整垃圾回收的频率，以适应当前堆大小和内存使用情况，从而保证系统的稳定性和性能。它是go语言垃圾回收算法的关键之一，对于大型内存负载和高并发环境下的应用程序尤为重要。



### tryLock

tryLock函数的作用是尝试获取mgcLock锁。在go程序中，mgcLock是一个重要的锁，它用于维护垃圾回收、堆栈和并发编程的正确性。由于它被频繁使用，因此tryLock函数的设计是为了快速地获取锁，并且不会阻塞当前线程。

tryLock函数使用的是类似自旋锁的方式，它会先检查当前锁的状态是否处于解锁状态，如果是，则立即获取锁并返回true。如果当前锁的状态是锁定状态，则tryLock函数会返回false，表示获取锁失败。

在tryLock函数的实现中，它会使用原子操作来读取和设置mgcLock的状态，这样可以确保它在多线程环境下的正确性。此外，tryLock函数还会加上一个优化，即在尝试获取锁之前先判断当前goroutine是否已经持有了mgcLock，如果是，则直接返回true。

总之，tryLock函数的作用是为了在尽可能少地阻塞当前线程的情况下，快速地获取mgcLock锁，从而确保go程序的并发正确性和性能。



### unlock

在go/src/runtime/mgclimit.go文件中，unlock函数是用来释放锁的。在go的并发模型中，锁是一种常用的同步机制，用于保护共享资源的访问。在此文件中，全局管理器（global M）为堆分配器（heap allocator）提供了全局限制，以防止堆的增长无节制导致内存耗尽。这意味着当达到堆大小限制时，堆分配器将停止从操作系统申请更多的内存，并且只能使用已经申请的大小。 

当堆大小达到限制时，堆分配器将停止从操作系统申请更多的内存，并且只能使用已经申请的大小。此时，全局管理器需要对堆分配器进行保护，以确保它不会继续尝试增长堆。因此，当锁被堆分配器获取时，任何其他goroutine都无法访问或修改堆分配器的全局限制，并且只能等待直到锁被释放。

unlock函数的作用就是释放这个锁并允许其他进程访问或修改全局限制。这是非常重要的，因为只有当锁被释放时，其他goroutine才能继续操作堆分配器，包括尝试增长堆大小。因此，释放锁是一个非常重要的操作，它确保了在堆大小达到限制后，所有goroutine都能够协调工作以保护内存不被耗尽。



### resetCapacity

resetCapacity函数的作用是重置内存容量限制，指定堆最大容量。在Go语言中，垃圾回收机制使用了基于容量的策略来控制堆大小，即Go语言会将堆大小限制为最大容量（heapGoal）的两倍。当程序需要更多内存时，Go语言会分配更多堆容量，但如果超过上限，则会触发垃圾回收机制。

resetCapacity函数用于重置内存容量限制，并在内存容量限制被更新后触发垃圾回收机制。如果当前堆的大小超过了新的容量限制，则会触发垃圾回收机制来释放不再使用的内存。该函数的实现比较简单，主要是对heapLimit和heapGoal变量进行更新，并调用gcController.adjustGcPercent来重新计算垃圾回收百分比。

总之，resetCapacity函数是Go语言垃圾回收机制中一个重要的函数，用于控制堆大小和触发垃圾回收。它可以根据当前程序的内存使用情况来调整堆容量限制，避免程序出现内存泄露或溢出的情况。



### makeLimiterEventStamp

makeLimiterEventStamp函数用于创建一个阈值事件戳（limiterEventStamp）。这个阈值事件戳代表了一个在某个时间点之前发生的限制事件，用于控制系统中的协程数量。具体作用如下：

1.在并发协程数超过限制时，会触发限制事件，限制事件会对阈值事件戳进行更新，以记录该事件的发生时间和数量。

2.在协程数量降低到规定阈值以下时，会触发阈值事件戳的重置，以表示协程数量有了较大规模的改变。

3.在系统启动时，会初始化阈值事件戳，以保证协程数量在适当的范围内。

4.阈值事件戳还可以用于记录系统运行的时间，以便于对系统性能的分析和优化。

makeLimiterEventStamp函数会返回一个limiterEventStamp结构体对象，其包含了当前系统中可允许的最大协程数量、最近一次限制事件的发生时间、最近一次限制事件的协程数量等信息。通过这些信息可以有效地控制系统中的协程数量，避免因过多的协程引起的资源浪费和系统负荷过重等问题。



### duration

在go/src/runtime目录下的mgclimit.go文件中，duration函数用于返回GC预算的时间限制。

GC（Garbage Collection）是Go语言内存管理机制的核心，用于回收不再使用的内存。在GC过程中，Go语言会根据当前系统的内存使用率来预估需要多长时间完成GC操作。duration函数的作用就是根据当前系统内存使用情况和GC比例计算出当前应该使用的时间限制。

这个函数的实现主要是通过调用getSweepInProgessPeriod函数获取当前正在运行的Sweep时间间隔长度和Sweep完成的总时间，然后计算得出应该使用的GC时间限制。

该函数返回一个time.Duration类型的值，表示当前GC操作可用的时间限制。这样可以确保系统在回收不再使用的内存时能够充分利用资源，并且不会占用过多的时间影响程序的运行。



### typ

在Go的runtime中，mgclimit.go文件中的typ函数的作用是根据受限制的内存大小和arena的大小选择堆内存大小和结束标记的范围。

在Go的内存管理中，堆是所有内存分配的来源。当创建新的goroutine、调用函数或使用new、make等函数时，系统会从堆中分配内存。但是，由于堆内存使用可能会导致内存泄漏和性能问题，因此Go使用垃圾回收器将不再使用的内存回收。

在堆内存分配时，typ函数负责确定堆内存的大小和结束标记范围。由于堆内存使用可能会受到一定的限制，例如受限的设备资源或较低的容量，typ函数可以根据这些限制来选择堆内存大小和结束标记的范围。这样，系统可以根据实际需要分配最合适的堆内存。

此外，typ函数还可以通过计算内存分配区域的大小和数量来确定堆内存的用途和分配策略。这使得系统可以根据不同的使用情况灵活地调整内存分配策略，提高系统性能。

总之，typ函数是Go内存管理中的重要组成部分，它可以根据实际需求灵活地选择堆内存大小和内存分配策略，从而提高系统的性能和效率。



### start





### consume

在go语言中，内存（即堆）是由goroutine管理的一个资源。每个goroutine都可以申请并使用一定数量的内存，但是当太多goroutine同时申请内存时，它们可能会耗尽所有可用的内存，从而导致程序崩溃。为了避免这种情况，go运行时采用了许多机制来管理内存，其中之一就是mgclimit。

mgclimit是一个表示内存垃圾回收限制的变量。在mgclimit.go文件中的consume函数中，它的作用是用于计算每个goroutine可以使用的最大内存量。具体而言，consume函数会计算每个goroutine的堆大小限制，以确保堆在发生gc时不会过于庞大，从而导致gc操作时间过长。这样可以帮助保证程序的性能和稳定性。

在consume函数中，另一个重要的变量是max_allowed，它表示一个goroutine可以使用的最大堆大小，该值在程序启动时由go运行时动态计算。如果goroutine的堆大小超过了该值，便会触发内存回收操作以确保内存使用量不会过高。

总之，consume函数的作用是帮助管理内存垃圾回收操作，确保程序在运行时不会耗尽所有可用内存导致崩溃。



### stop

stop函数是goroutine调度程序的重要函数之一，其主要作用是停止当前正在运行的goroutine。具体来说，stop函数会将当前goroutine的M（线程管理器）的状态设置为阻止状态，以便调度程序可以选择另一个M执行其他goroutine。在实现时，stop函数会执行以下步骤：

1. 将M的状态设置为阻止状态。

2. 如果M处于locked状态，则释放锁。

3. 如果M处于系统堆栈上，则将其切换到调度堆栈上，并调用更高级别的ready函数。

4. 然后会不断地阻塞等待调度器选择另一个M来执行其他goroutine。

总之，stop函数是在goroutine之间切换的过程中起到关键作用的一个函数，它确保了每个M都能够充分地利用系统资源，并为goroutine的执行提供了保证。



