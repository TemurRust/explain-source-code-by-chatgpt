# File: mem_sbrk.go

mem_sbrk.go是Go语言运行时库（runtime）中的一个文件，它是用来实现Go程序的内存管理的。

具体来说，mem_sbrk.go中的代码实现了一个名为sbrk的系统调用，在GNU/Linux系统中它被用来分配一块连续的内存空间，并指定该空间应从进程的数据段尾部开始分配。在Go语言中，sbrk被用来为堆分配内存空间。

mem_sbrk.go文件中还实现了一些与内存分配相关的函数，如sysAlloc、sysFree等。这些函数被用来从操作系统中请求分配或释放内存。

总之，mem_sbrk.go文件是Go语言运行时库中实现内存管理的重要文件，它对应着底层的系统调用，为Go程序的堆分配和释放提供了支持。




---

### Var:

### bloc

mem_sbrk.go文件是Go语言运行时中的内存管理模块，它包含了一些实现内存管理的函数和变量。其中，bloc这个变量表示当前堆空间的末尾地址。

在程序运行时，堆空间是会动态地分配和释放内存的。当我们使用make()或new()函数申请新的内存时，Go语言运行时会通过bloc变量来确定在堆空间中分配内存的起始地址。同时，bloc变量的值也会被更新，以指示下一次分配内存时的起始地址。

除此之外，bloc变量也能够帮助运行时系统实现内存页对齐和内存管理。运行时系统会将内存分配按照页的大小对齐，以便更高效地使用硬件资源。此外，运行时系统也会对空闲的内存进行整理和合并，以提高内存利用率。

总之，bloc变量在Go语言运行时的内存管理中扮演着重要的角色，它与内存分配、内存页对齐和内存管理紧密相关。



### blocMax

在 Go 的运行时库中，mem_sbrk.go 文件用于实现 Go 语言中的内存分配功能。其中的 blocMax 变量用于限制单个内存块的最大大小。

具体地说，当请求分配一块内存时，运行时系统会计算出需要的内存大小，然后尝试从操作系统中申请对应大小的内存块。如果 blocMax 的值大于 0 并且请求的内存大于 blocMax，则运行时系统会将该内存分成多个小块进行分配，以避免分配过多的内存而导致操作系统出错。

这个变量的作用是为了防止内存分配过多，导致系统崩溃。在一些特殊情况下，如果程序需要分配比较大的内存块，可以通过修改 blocMax 的值来调整内存分配策略。不过一般情况下，应该避免直接修改该变量的值，因为这可能会影响程序的性能和稳定性。



### memlock

在Go的runtime中，mem_sbrk.go这个文件实现了堆的增长和内存分配的核心逻辑。其中，memlock变量被用来保护对物理内存的访问，以避免多个并发的Goroutine同时修改内存分配器状态。

具体地说，memlock是一个互斥锁，用于控制堆扩展和内存分配器状态的访问。在增长堆和分配内存之前，代码需要先获取memlock，以确保在此期间没有其他Goroutine可以访问内存分配器状态。这可以防止多个Goroutine同时修改堆大小和分配状态，从而避免出现竞争条件和数据损坏的情况。

需要注意的是，memlock是一个较为粗粒度的互斥锁，因为它会影响整个内存分配器的状态。这也就是为什么在Go 1.14中引入了mheap.lock和mheap_.lock等更细粒度的锁，以减少竞争和提高并发性能。



### memFreelist

在 Go 语言中，memFreelist 是一个用于管理内存分配器自由列表的数据结构，可以直接在 Go 编译器源码中的 go/src/runtime/malloc.go 文件中找到它的定义。它的作用是维护内存分配器分配和释放内存所使用的内部数据结构，以达到快速高效的分配和回收内存的目的。

具体来说，memFreelist 就是一个简单的链表结构，内存分配器使用它来缓存各种大小的内存块，以便下次分配内存时可以直接从这些已经缓存的块中选择一个最适合的内存块，而不需要重新申请内存或从系统中分配新的内存。

在 Go 中，memFreelist 的管理操作由内存分配器调度程序负责执行，包括向其中添加新的内存块、从其中删除已经被分配的内存块，并在需要时，重新分配所有空闲的内存块，以达到高效使用内存的目的。因此，它是 Go 语言运行时系统中一个非常重要的数据结构，对于提高内存使用效率和性能有着极大的帮助。






---

### Structs:

### memHdr

memHdr是一个表示内存块头部信息的结构体，它的作用是保存内存块的状态和大小信息，以便于对内存块的管理和操作。具体来说，memHdr结构体中包含了以下字段：

- arena memArena：当前内存块所属的内存池，用于支持内存的动态分配和回收；
- next, prev *memHdr：指向下一个和上一个内存块的指针，用于实现内存块的双向链表；
- size uintptr：当前内存块的大小，包括头部和实际数据部分的大小；
- free uint32：表示当前内存块是否可用，如果为0表示已被分配，否则表示未被分配。

通过使用memHdr结构体，runtime可以方便地对内存块进行分配、释放、合并操作，从而支持Go语言中的垃圾回收、内存池等特性。同时，memHdr结构体的设计也符合内存对齐的要求，可以保证内存的可靠性和效率。



### memHdrPtr

在go/src/runtime中mem_sbrk.go文件中，memHdrPtr结构体是用来描述内存分配的头部信息的。该结构体的定义如下：

```go
type memHdrPtr struct {
	next, prev *memHdrPtr
	size       uintptr
}
```

其中，next和prev字段是用来记录链表中的前后节点，size字段记录了当前节点的大小。这个结构体可以看作是一个双向链表的节点，每个节点代表分配的一段内存块的头部信息。

在Go的堆内存管理中，内存分配是采取“顺序分配”的方式，即把新分配的内存块挂在一个双向链表上，从而形成一个链表。新分配的节点的大小就是内存块的大小，可以通过memHdrPtr结构体的size字段来获取。

另外，链表中的每个节点是通过next和prev字段相互链接的，这样可以快速地查找出是否有足够大小的空闲内存块来分配。同时，采用链表的方式可以避免内存碎片的产生，提高了内存的利用率。

综上所述，memHdrPtr结构体在Go内存管理的过程中扮演了很重要的角色，它用来记录内存块的头部信息，并链接成一个链表，为内存的分配和释放提供了便利。



## Functions:

### ptr

在Go语言中，mem_sbrk.go文件的ptr函数用于实现内存分配器分配堆空间时通过系统调用申请一段连续的内存空间，并将其转换成uintptr类型指针，返回给分配器使用。

具体而言，该函数通过调用memSbrk函数向操作系统申请一段内存空间，并将返回的地址转换成uintptr类型指针，以便于内存分配器进行内存的管理和分配。同时，该函数还会记录内存分配器的总内存使用量和分配的堆空间的总大小等信息。

该函数的实现过程中，可能会出现内存不足的情况，此时会打印错误信息并返回0，表示内存分配失败。当系统调用成功且返回的地址非空时，该函数会返回一个uintptr类型指针，指向申请的一段连续的内存空间的起始地址。

总之，该函数在Go语言运行时系统中扮演着重要的角色，负责管理和分配内存，保障程序正常运行。



### set

在Go语言中，mem_sbrk.go文件中的set()函数实现了将一块连续的物理内存地址空间分配给程序使用的功能。具体来说，set()函数的主要作用是将指针sbrkBase指向指定大小的一块物理内存地址空间，并且设置新的指针sbrkEnd，用于表示可以使用的内存空间的结束位置。

在实现中，set()函数首先判断是否需要扩展堆空间，如果需要，则会通过系统调用sbrk()向操作系统申请更多的物理内存空间；否则，直接将已有的内存分配给程序使用。set()函数还会更新全局变量maxSbrkEnd，用于跟踪内存使用的情况。

set()函数的具体实现代码如下：

```
func set(size uintptr) {
    if sbrkEnd+size > maxSbrkEnd {
        if mheap_.debugMalloc > 0 {
            print("sbrk(", size, ") = ")
        }
        newEnd := sbrkBase + sbrkEnd + size - maxSbrkEnd
        newEnd = round(newEnd, _PageSize)
        if sysReserve(unsafe.Pointer(sbrkEnd), newEnd-sbrkEnd) != 0 {
            // This will die horribly below.
            print("runtime: cannot reserve more heap space\n")
            throw("runtime: cannot reserve more heap space")
        }
        if sysMap(unsafe.Pointer(sbrkEnd), newEnd-sbrkEnd, 0) != 0 {
            // This will die horribly below.
            print("runtime: cannot map heap arena\n")
            throw("runtime: cannot map heap arena")
        }
        maxSbrkEnd = newEnd
        if mheap_.debugMalloc > 0 {
            print(hex(sbrkEnd), "\n")
        }
    }
    p := sbrkBase + sbrkEnd
    sbrkEnd += size
    pClean(p+size, sbrkEnd-p-size)
}
```

总的来说，set()函数是Go语言运行时内存管理的重要组成部分，它负责为程序动态分配内存空间，并且在需要时向操作系统申请更多的物理内存。



### memAlloc

`memAlloc`是Go语言运行时系统中用于分配内存的函数。在Go语言中，程序员一般不直接调用`memAlloc`函数，而是通过`make`函数或者其他内部方法自动分配内存。

`memAlloc`函数的作用是请求系统分配一块内存。当请求的内存大小超出当前`mheap`管理的内存范围时，`memAlloc`会调用`sbrk`系统调用来扩大堆的大小。然后，`memAlloc`还会检查当前可用的内存是否完全被使用，如果是，就会调用`mheap`的`scavenge`方法执行垃圾回收。

在`memAlloc`函数中，真正的内存分配工作是由`sizedclasses`和`size_to_class`这两个函数完成的。最后返回的指针指向分配的内存块的首地址。

总之，`memAlloc`函数是Go语言运行时系统中非常重要的内存分配函数，它为程序员分配内存提供了便利，同时也保证了运行时系统的整体稳定性和性能。



### memFree

memFree是runtime包中mem_sbrk.go文件中的一个函数，其主要作用是释放内存。在go程序中，内存管理是由runtime包来负责的，memFree函数就是其中的一个重要函数。

在mem_sbrk.go文件中，memFree函数是用来释放一块或多块连续的内存的。该函数首先根据传入的参数，计算需要释放的总内存大小，然后遍历整个内存池，找到并释放对应的内存块。具体的实现细节如下：

1. 计算需要释放的总内存大小，包括头信息和实际数据部分。

2. 遍历整个内存池，寻找需要释放的内存块。

3. 根据需要释放的内存块和已分配的内存块进行比较，找到需要释放的内存块。

4. 释放内存块，并更新内存池中已分配内存块的信息。

总的来说，memFree函数是一个用于释放内存的通用函数，其实现依赖于内存池的设计和实现。在go程序中，memFree函数是由runtime包实现的，在程序运行时会自动调用。由于内存管理对于程序的性能和稳定性都非常关键，因此memFree函数的实现也非常重要。



### memCheck

memCheck函数是用于检查堆的空间是否足够分配数据的函数。当请求分配内存时，memCheck函数会检查堆的总空间是否已经达到了最大允许空间（maxHeap），如果已经达到最大值，则返回错误，否则返回nil。这个函数还有一个重要的作用就是对于小对象的内存分配，它会对内存池进行检查，避免不必要的向操作系统申请内存。

具体来说，memCheck函数会检查内存分配的大小是否小于fixedRootSize，如果是，则在内存池中查找已经分配但是未使用的内存块，如果找到了，则返回这个内存块的地址，否则将会调用alloc_m并向操作系统申请更多的内存。而对于大对象的内存分配，则不会使用内存池，而是直接调用alloc_m向操作系统请求内存。

在整个程序运行期间，memCheck函数是非常重要的，因为它保证了内存的分配与回收的正确分配，避免了内存泄漏和内存耗尽的情况。同时，内存池也大大减少了操作系统对内存的申请次数，提高了程序的运行效率。



### memRound

memRound这个函数的作用是将内存大小四舍五入到满足某些特定要求的最小值，以便更好地管理内存。

具体来说，这个函数将给定的大小加上小于等于页大小的最小值n（通常是8），然后将结果四舍五入到页大小的倍数。这么做的原因是：

1. 将内存大小四舍五入到页大小的倍数，可以方便内存分配和释放。例如，将内存按页大小对齐，可以避免内存碎片问题，让内存分配的效率更高。

2. 加上小于等于页大小的最小值n，可以确保分配的内存块大小足够大，避免过多的内存分配。例如，如果一个程序经常分配很小的内存块，每次都需要调用mem_sbrk来获取，会导致性能降低。加上一个最小值n后，可以确保每个内存块大小不会小于n，避免过多的内存分配调用。

总之，memRound这个函数的作用是将内存大小四舍五入到满足某些特定要求的最小值，以便更好地管理内存。



### initBloc

initBloc函数是Go语言运行时系统中mem_sbrk模块的初始化函数。这个函数主要的作用是将堆的起始地址和大小设置为首次通过系统调用获取到的内存块的地址和大小，并初始化其他与堆相关的数据结构及参数，如mheap、mcentral、arenas等。具体来说，initBloc函数主要的步骤包括：

1. 调用sysAlloc函数，通过系统调用分配一段内存，并返回内存块的起始地址。

2. 将内存块的地址和大小存储到全局变量heap_start和heap_size中，作为整个堆的起始地址和大小。

3. 调用mheap的init函数，将mheap结构体中的各项参数初始化，如arena_hint、arena_reserved、arena_reserved_limit、head等，同时将它们与当前堆相关的数据结构、参数和全局变量关联起来（如stat、pageAlloc、largeAlloc等）。

4. 调用mcentral的init函数，将mcentral结构体中的各项参数初始化，并将它们与mheap、mcache、centralCache、spanParameters等关联起来。

5. 调用arenas的init函数，为堆分配一定数量的arena，并将它们初始化，并将它们与mheap参数关联起来。

通过以上步骤，initBloc函数完成了堆的初始化工作，为后续的内存分配、回收等操作提供了基础的数据结构和参数。



### sysAllocOS

sysAllocOS函数是在Go程序中用于从操作系统申请内存的一个系统函数，它通常会直接调用操作系统提供的malloc函数。这个函数的主要作用是实现在heap（堆）上进行内存分配的功能，而堆是用于存储运行时数据结构的内存区域。

在Go语言中，内存管理很重要，因为它对程序的性能和稳定性有很大的影响。因此，sysAllocOS函数的实现非常关键，它需要考虑以下几点：

1. 要确保为每个分配的内存块保留足够的虚拟地址空间，以便在需要时可以使用更多物理内存。

2. 确认已获得足够的物理内存来支持所需的虚拟地址空间。

3. 在支持多线程运行的情况下，需要使用同步机制来确保不会出现同时分配同一段虚拟地址空间的情况。

4. atexit函数的注册，用于在程序结束时释放已分配的内存，并返回给操作系统。

总之，sysAllocOS函数是实际进行内存分配的核心，必须保证其高效、可靠，以便确保整个程序的性能和稳定性。



### sysFreeOS

sysFreeOS是一个函数名称，这个函数位于mem_sbrk.go文件中。它的作用是释放从操作系统中分配的内存空间。这个函数主要用在内存管理中的sbrk函数，它使用类似malloc和free的方式来管理内存分配。当sbrk不再需要一些内存分配时就会调用sysFreeOS来释放内存。

sysFreeOS使用madvise system call来将分配的内存页标记为无效并将其返回给系统。这个函数使用了操作系统提供的底层函数提供的功能和接口。对于一些低端的操作系统，调用这个函数可能会造成性能问题，但是对于像Linux这样更成熟的操作系统，这个函数的性能表现非常好。

总之，sysFreeOS是用来释放从操作系统中分配的内存空间的重要函数，它是内存管理中的一个不可或缺的组成部分。



### sysUnusedOS

在Go语言的运行时系统中，mem_sbrk.go文件中的sysUnusedOS函数是用来暂时释放不需要使用的内存给操作系统使用的函数。当Go程序需要分配更多的内存时，它可能仍然有一些未使用的内存块。使用sysUnusedOS函数可以将这些未使用的内存块释放回操作系统，以便其他程序可以使用它们。

该函数是使用一个系统调用来实现的，即调用sysUnused函数并将一些参数传递给它。在调用系统调用时，需要指定需要释放的内存块的起始地址和大小。此函数可以用于减少系统的内存占用量，提高系统的资源利用率。

总之，sysUnusedOS函数的作用是释放不需要使用的内存块给操作系统使用，从而提高系统的资源利用率，减少系统的内存占用量。



### sysUsedOS

sysUsedOS是runtime包中mem_sbrk.go文件中的一个函数，用于获取当前程序使用的物理内存大小。

在运行时，Go程序使用的内存可以分为两部分：堆和栈。堆是动态分配的，主要用于存储动态分配的对象，而栈则用于存储函数调用时的数据。当程序运行时，会不断地从操作系统申请和释放堆内存以满足程序的需求。

sysUsedOS函数通过调用操作系统提供的方法获取当前程序使用的物理内存大小。具体实现可以根据操作系统的不同而有所不同。在Linux上，sysUsedOS调用了getrusage系统调用来获取当前进程使用的物理内存大小；在Windows上，sysUsedOS调用了GlobalMemoryStatusEx函数来获取当前进程使用的物理内存大小。

该函数的作用是为了在程序运行时监控内存的使用情况，以便及时发现内存泄漏或是过度使用内存的问题。如果程序使用的内存超出了物理内存大小，会导致系统性能下降，严重的话会导致程序崩溃。因此，通过sysUsedOS函数获取当前程序使用的物理内存大小，可以帮助我们更好地管理程序的内存使用。



### sysHugePageOS

在Go语言的运行时系统中，mem_sbrk.go文件是用来实现内存管理的代码文件。在该文件中，sysHugePageOS是一个函数，其作用是为Go程序申请大页面的内存。

大页面内存是指比默认的4KB页面大小更大的页面，通常是2MB或者更大。这种大页面内存有几个优点：

1.减少页面表项：大页面意味着更少的页表项，这意味着可以更快地访问和修改内存。

2.提高空间局部性：大页面允许更多的数据在更少的物理页中，这提高了空间局部性，从而提高了缓存性能。

3.降低TLB缺失：由于大页面的页表项数量较少，因此它们可以更好地利用TLB缓存。这可以显著减少访问内存时的TLB缺失次数。

sysHugePageOS函数在Linux系统上使用mmap系统调用实现大页面内存分配。该函数首先确定内存的总大小，然后调用mmap函数来映射大页面内存。如果映射失败，则会返回nil。否则，返回映射到内存的地址和错误（如果有）。

总之，sysHugePageOS是Go语言运行时系统中的一部分，其目的是为Go程序申请大页面内存。这可以提高性能和内存利用率。



### sysNoHugePageOS

在Go语言的运行时库中，mem_sbrk.go文件定义了Memory SBRK函数，该函数负责管理内存的分配和释放。sysNoHugePageOS函数是其中的一个子函数，它的作用是检查当前操作系统是否支持巨页功能。如果支持，则禁用巨页功能。

巨页面是指一页超过4KB大小的内存页面，它可以提高内存访问效率和减少内存碎片。然而，在某些情况下，如果应用程序使用巨页，会导致性能下降和内存浪费。例如，在Kubernetes等容器化环境中，使用巨页可能会导致内存泄漏和无法回收的问题。

因此，sysNoHugePageOS函数在Go代码运行时检查当前系统是否支持巨页，如果支持，则禁用巨页功能，以避免性能问题和内存泄漏。具体实现方式如下：

1. 首先使用syscall包中的Sysconf函数获取当前系统的属性，其中_SC_NPROCESSORS_CONF表示系统的CPU数量，而_SC_PAGESIZE表示系统页面大小。

2. 如果系统页面大小大于4KB，则认为支持巨页功能。然后使用madvise系统调用，将系统页面设置为非巨页模式。

3. 如果系统页面小于等于4KB，则认为不支持巨页功能，函数返回。

在Go语言运行时库中，sysNoHugePageOS函数可以帮助避免由于使用巨页带来的性能问题和内存泄漏，从而提高程序的稳定性和可靠性。



### sysMapOS

在运行时（runtime）中，mem_sbrk.go文件实现了用于将内存与OS映射的函数。其中，sysMapOS（）函数用于将虚拟地址v起始位置开始的长度为n的地址空间映射到物理内存上，并返回新分配的地址空间的起始位置。

该函数的实现涉及到与操作系统的交互，因为它需要调用操作系统提供的函数来分配物理内存。在Linux系统中，sysMapOS（）通过调用系统调用mmap（）来完成此操作。mmap（）函数的作用是将一个文件或设备映射到进程的地址空间，并返回该区域的起始地址。

sysMapOS（）函数的主要作用就是实现内存的动态分配和管理。这个函数会把操作系统中可用的内存映射到进程的虚拟地址空间中，从而使得进程能够使用这些内存。在Go语言中，所有的内存分配都是通过runtime来完成的，因此mem_sbrk.go中的sysMapOS（）扮演了重要的角色。



### sysFaultOS

在Go语言的运行时中，mem_sbrk.go文件中的sysFaultOS函数作为一个方法，其主要作用是当内存分配失败时，它会被调用。具体来说，在使用操作系统接口进行动态分配内存时，如果请求的内存超出系统限制或者出现了其他错误，就需要调用该函数。

该函数的实现是基于Go语言的系统调用。具体来说，它会对请求的内存进行错误处理，例如日志记录，内存释放等，然后调用mmap将所有剩余的空闲内存映射到进程地址空间中。这样一来，内存就会被重新映射到进程的地址空间中，可以继续使用了。

总体来说，sysFaultOS函数在Go语言的运行时中扮演了一个非常重要的角色，它可以帮助我们有效地处理动态内存分配中可能出现的各种问题，并确保我们的程序在内存分配失败时能够正确地进行处理。



### sysReserveOS

sysReserveOS函数用于在操作系统层面分配一段虚拟内存地址空间。在Go运行时中，该函数会在需要分配一部分内存时被调用。

当Go程序需要分配内存时，runtime包会优先在堆上尝试分配，如果无法满足分配请求则会调用sysReserveOS函数向操作系统申请更多的虚拟内存地址空间。该函数的主要作用包括：

1. 向操作系统申请一段指定大小的虚拟内存地址空间。
2. 在操作系统中为该虚拟地址空间分配物理内存并映射到该虚拟地址空间。
3. 返回该虚拟地址空间的起始地址指针。

该函数会尝试调用操作系统特定的API来执行以上操作。其实现细节因操作系统而异，例如在Windows系统上会使用VirtualAlloc等API来向操作系统申请内存，而在Linux系统上则可能使用mmap系统调用等。

需要注意的是，该函数并不会显式调整操作系统分配的物理内存大小，因此在使用完毕后需要调用sysUnused函数来通知操作系统释放该虚拟地址空间以及其对应的物理内存。



