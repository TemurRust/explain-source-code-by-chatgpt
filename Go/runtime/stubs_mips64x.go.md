# File: stubs_mips64x.go

stubs_mips64x.go文件是Go语言标准库运行时包中的一个子文件，它主要提供针对mips64x架构的运行时函数的桩代码。这些桩代码在编译或运行时用于解决符号链接错误，因为它们实现了mips64x架构中不包含Go语言代码所需的函数。 

在Go语言标准库中，有一些函数需要底层平台的支持才能正常运行，比如内存分配函数malloc、goroutine的调度器等。而针对不同的平台，由于各自的硬件架构和操作系统特性的不同，这些函数的实现方式也会有所不同。而stubs_mips64x.go文件中提供了针对mips64x架构的这些函数的桩代码，这些代码实现了运行时所需的函数调用流程，并在编译或运行时连接到其他底层平台的库或系统函数，以提供完整的运行时环境。

比如，在stubs_mips64x.go文件中实现了以下几个函数：

func libcCall(fn uintptr, arg unsafe.Pointer, n uintptr) uintptr 
func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) unsafe.Pointer
func semacreate(mp *m) uintptr
func setitimer(mode int32, new, old *itimerval) int32 

这些函数在运行时中被频繁调用，为了确保Go程序在mips64x平台上顺利运行，stubs_mips64x.go文件提供了针对这些函数的具体实现。其他的Go源文件可以引用这些函数，并通过预编译器的方式将它们与操作系统和硬件平台的其他代码链接起来。

总之，stubs_mips64x.go文件是Go语言的标准库在mips64x架构上的支持文件，它通过提供具体的桩代码实现了标准库在该平台上所需的底层功能，确保Go程序在该平台上顺利运行。

## Functions:

### load_g

load_g是一个用来加载goroutine的函数，在MIPS64X架构下，这个函数是一个stub，也就是目标代码中的一个桩函数，其实现在运行时库中，并且可以被替换或者拦截。

该函数的作用是加载goroutine的上下文，包括各寄存器的值和栈的地址等信息。当一个goroutine切换到另一个goroutine的时候，就会调用这个函数来将上下文保存到原来的goroutine中，并将目标goroutine的上下文加载进来，从而实现goroutine的切换。

load_g函数会检查g结构体成员的布局和位置，以确保跨平台时不会出现问题，并且根据mIPS64X架构的特点来调整寄存器和栈的位置等参数。在实现过程中，也会考虑到在多核并行计算机上同时处理多个goroutine的情况，使用了一些特殊的锁和同步机制来保证数据的一致性和正确性。

总之，load_g函数在MIPS64X架构下是一个非常重要的函数，它保证了goroutine的正常切换和使用，并且考虑了架构的特点和计算机的并行特性，为goroutine的高效运行提供了良好的保障。



### save_g

在 mips64x 架构的处理器中，因为寄存器数量有限，调用函数时需要将参数等内容保存到内存中，以便在函数执行完后恢复。save_g 函数就是用来保存 G（goroutine）结构体的，在调用 Go 函数时，它会将 G 结构体的信息存储到已分配的内存中。G 结构体包含了goroutine的信息，包括goroutine的状态、栈、任务队列等等。当一个新的goroutine被创建时，它需要一个G结构，而save_g的作用就是创建并初始化一个新的G结构体。在调用之后，G结构体就会被存储在内存中，以便后面程序运行时的使用。



### asmcgocall_no_g

asmcgocall_no_g函数是用于在MIPS64架构的处理器上执行Go函数的。这个函数实现了Go与汇编代码之间的交互，它接收一个指向函数的指针以及一组参数，然后调用函数并返回结果。

在具体实现中，asmcgocall_no_g函数首先会将参数存放在寄存器中，然后使用JAL指令跳转到GOGOSCHED函数，这个函数会把Go调度器的上下文保存在栈中，并跳转到mcall函数中，这个函数会执行真正的Go函数，最后返回结果并恢复CPU的状态。

这个函数实现了跨ABI调用，它通过将参数存放在正确的寄存器当中来保证调用能够正确执行。同时它还使用了一些优化来提高调用的性能，例如使用寄存器来传递参数以减少内存访问等。在整个Go程序中，这个函数能够让Go与底层的MIPS64架构的处理器进行高效的交互，从而暴露了更多的CPU特性，提高了Go程序的执行效率。



### getcallerfp

在mips64架构中，函数调用过程中参数和返回值都是通过寄存器来传递的，而函数调用的栈帧却没有明确的指针作为入口。getcallerfp()函数就是为了获取调用者的栈帧指针（frame pointer），以便在栈上正确的定位参数和返回值。

具体来说，getcallerfp()函数使用mips64汇编来实现，其核心语句为：

```
MOVV($ra, 0($sp))
ADDU($sp, $sp, $(x*8))
```

该语句首先将调用者的返回地址保存到栈顶，接着将栈指针向上移动x个位置，以获取对应的栈帧指针。

需要注意的是，由于mips64中，栈指针可能指向一个16字节对齐的地址，而真实的栈帧指针（如$fp寄存器）可能没有对齐，因此在获取栈帧指针时需要考虑这一点，具体实现可以参考stubs_mips64x.go中的源码。

总之，getcallerfp()函数是mips64架构中非常重要的一个函数，它为运行时系统提供了必要的信息，以便支持正确的函数调用和返回操作。



