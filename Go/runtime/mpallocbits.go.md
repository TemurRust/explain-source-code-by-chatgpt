# File: mpallocbits.go

mpallocbits.go文件是Go语言运行时的一部分，主要用于内存分配管理和垃圾回收。它实现了一个位图数据结构，用于跟踪可用内存块的状态。

具体来说，mpallocbits.go文件维护了一组位图，每个位代表一小块内存（默认为8字节）。这些位可以被设置为0或1，表示相应的内存块是否可用。内存分配器在分配内存时找到一个连续的0位序列，将它们标记为1，并返回对应的内存块地址。垃圾回收器在遍历堆中的对象时，使用这些位来判断对象是否已经被标记为垃圾，从而释放占用的内存。

mpallocbits.go文件的工作原理如下：

1. 定义一组位图，每个位代表一个内存单元（默认为8字节）。

2. 内存分配器在请求内存时，查找位图中的连续0位序列，并将它们标记为1。

3. 分配器返回已标记的内存单元的地址。

4. 垃圾回收器在清理内存时，扫描堆中的对象，并使用位图中的位来标记已死亡的对象。

5. 同时，位图还提供了访问堆中内存段中未使用位数的方法，帮助分配器来优化其操作。

总之，mpallocbits.go文件提供了一个可扩展的，高效的内存分配算法，并实现了一个位图数据结构，帮助跟踪和管理内存的使用和释放。这个算法是Go语言内存管理的核心组成之一，具有很高的性能和可靠性。




---

### Structs:

### pageBits

在Go语言的运行时系统中，mpallocbits.go文件定义了一个名为pageBits的结构体，它用于管理内存分配器分配的内存页的状态。具体而言，pageBits结构体用于表示一系列内存页中每个页面的状态，这些状态可能包括已分配、空闲、已清零等等。通过这个结构体，Go语言的运行时系统可以更高效、更可靠地管理内存，实现更好的性能和稳定性。

在pageBits结构体中，有几个重要的字段，包括pageShift、pagesPerArena、wordsPerPage、arenaL1Bits和arenaL2Bits等。其中，pageShift表示每个页面的大小，pagesPerArena表示每个Arena中包含的页面数量，wordsPerPage表示每个页面占用的字数，arenaL1Bits和arenaL2Bits则表示Arena的数量和一级缓存的位数。这些字段的设置可以根据具体的硬件和应用场景来进行优化，以提高内存管理的效率和可靠性。

总之，pageBits结构体是Go语言运行时系统中非常重要的一个组成部分，它为内存分配器提供了必要的状态信息和管理功能，使得Go语言的程序可以更高效地利用和管理内存，从而实现更好的性能和稳定性。



### pallocBits

pallocBits 是一个记录每个 P（处理器）可用的 PallocData 的位向量。它的作用是用于跟踪处理器的内存分配情况。每个 PallocData 用于保存可供 P 使用的可用内存 bitmap，其中每个比特位表示一个连续的固定大小内存块是否已被分配。

由于多处理器的环境中，每个处理器都可以独立地分配内存，因此需要一种机制来追踪哪些内存块已被分配，哪些内存块仍然可用。因此，pallocBits 向量跟踪每个处理器可用的内存块，以便其他处理器和系统可以可靠地检索已经分配的内存块。



### pallocData

在 Golang 的 runtime 中，mpallocbits.go 文件中包含了一些与内存分配和管理相关的代码。其中，pallocData 结构体被用于描述一块内存区域的分配情况，具体来说，它记录了从 Heap 区域中分配出的 P 管理器的数量以及对应的分配情况。

更具体地说，pallocData 结构体包含以下字段：

- size uintptr：表示该区域的大小，以字节为单位。
- endSys uintptr：指向该区域的末尾位置。
- bitmap []uint8：这是一个字节数组，用于记录从该区域中分配的一组 P 管理器的状态。具体来说，每个 bit 表示一个 P 管理器的分配情况，1 表示已经被分配，0 表示未被分配。
- next *pallocData：连接到下一个 pallocData 结构体，形成一个链表结构。

通过记录每个 P 管理器的分配情况，pallocData 可以被用于快速地确定哪些 P 管理器可以被分配或释放。同时，由于每个 pallocData 结构体描述的区域大小不同，因此也可以避免在不同大小的内存区域之间进行不必要的遍历，提高内存管理的效率。

总之，pallocData 结构体在 Golang 的内存管理中起着重要的作用，可以帮助 Golang 更加高效地分配和管理内存，提高程序的运行效率和性能表现。



## Functions:

### get

get函数是用于给一个字节大小的内存块分配一段连续的位图。这段位图用于记录该内存块的每个字节是否已经被分配或释放。

在具体实现中，get函数会首先检查是否存在足够的空闲位图来满足请求。如果存在，则选择一段空闲位图，将其标记为已分配，并返回该位图的起始地址。

如果没有足够的空闲位图，则会调用more函数向操作系统申请更多的内存，并将其划分为位图块来使用。

通过使用位图来管理内存分配，可以实现高效的内存管理和最小化内存浪费。同时，位图还可以提高内存访问的速度，因为位图块可以映射到物理内存的一页，从而可以实现快速的内存访问和修改。



### block64

block64函数的作用是为一个64字节的内存块分配管理位图（allocation bit map）。在Go语言中，内存分配时使用了位图算法，不同大小的内存块使用不同大小的位图进行分配管理。对于大小为64字节的内存块，使用64位的位图进行管理。

具体而言，block64函数将一个64字节的内存块对齐到最近的64的倍数，并计算出这个内存块所需要的位图大小。然后从全局的堆空间（heap）中查找是否有足够大的空闲位图，如果找到了则将其标记为已用状态，并返回内存块和位图的地址；如果没有找到，则会尝试向操作系统申请更多的堆空间。

值得注意的是，block64函数只处理大小为64字节的内存块，对于其他大小的内存块则由其他相关函数进行分配管理。这些函数包括block32、block48、block128等等，它们的实现方式类似于block64。



### set

在Go语言的运行时系统中，mpallocbits.go文件定义了对于内存分配的一些基本操作。其中，set这个函数的作用是将一个bit数组中的指定位置设置为1。

具体来说，此函数的定义如下：

```
// set sets the i'th bit in the slice.
func (s *uint128) set(i uint) {
    if i < 64 {
        s.lo |= 1 << i
    } else {
        s.hi |= 1 << (i - 64)
    }
}
```

其中，参数s是一个长度为128位的无符号整数，i则是要设置的位数。这里需要注意的是，数组中的第0位位于最低位，即数组的第0个元素表示64位无符号整数的低64位，第1个元素则表示高64位。

根据set函数的实现可以看出，当i小于64时，函数会将s的低64位的第i位设置为1；当i大于等于64时，函数会将s的高64位的第i-64位设置为1。

这个函数的作用通常是在内存分配时使用，用于标记哪些内存块已经被分配。通过设置对应的bit位，就可以记录内存块的使用情况。在Go语言中，运行时系统使用一个位图来表示堆上的内存分配情况，set函数就是用来操作这个位图的。

总之，set函数是Go语言运行时系统中用于管理内存分配的基本函数之一，它的作用是设置一个bit数组中的指定位为1。



### setRange

setRange()函数是Go语言运行时系统中mpallocbits.go文件中的一个函数，用于将位图中一段连续的比特位设置为给定的值。Go语言运行时系统使用setRange()函数来管理内存分配，提高内存分配和回收的效率。

具体来说，setRange()函数的主要作用是在指定的位图范围内设置特定的位值。该函数包含了五个参数，分别是：mem *byte、off、n uintptr、val uint8和valOff uint8。其中，mem表示要设置的位图的内存地址，off表示要设置的起始比特索引，n表示要设置的比特数，val表示要设置的比特值，valOff表示要设置的比特值的起始偏移量。

setRange()函数首先根据起始索引计算出要设置的比特的位置，然后根据比特数分配内存。接下来，函数将要设置的比特值复制到刚分配的内存区域中，最后将内存区域的位图中对应的比特位设置为指定的值。

在Go语言运行时系统中，setRange()函数主要用于管理位图中的空闲内存空间，以便在需要时分配给新的对象。当创建新的对象时，运行时系统会检查位图中的空闲空间，并使用setRange()函数来设置位图中的空闲空间，以便将其分配给新对象。这种管理方式可以帮助运行时系统更加有效地使用内存资源，提高系统的性能和效率。



### setAll

setAll函数的作用是将给定的位图中的所有位都设置为1。

在go/src/runtime/mpallocbits.go文件中，该函数被用来初始化一些位图，包括：

1. arena_used_bits - 用来记录各个arena中已使用的页的位图
2. span_freelist - 用来记录各个span是否可用的位图

在这些位图中，所有的位都应该被初始化为0或1，以表示相应的页面或span是否可用。在初始化时，我们需要将所有位设置为1或0，以便在后续操作中进行正确的分配和释放。

这里需要注意的是，go语言中的位图是由一个[]byte类型的slice实现的，一个字节可以表示8个位。所以，在设置位图的某个位时，需要先计算出这个位所在的字节位置和字节内位置，然后再修改相应的位。这个过程在setAll函数中被执行。 

具体实现可以参考如下代码： 

```
func setAll(b []byte, v bool) {
    if v {
        for i := range b {
            b[i] = 0xff
        }
    } else {
        for i := range b {
            b[i] = 0
        }
    }
}
```

该代码首先判断需要设置的值是0还是1，然后分别遍历位图中的每个字节，将其设置为0或1。



### setBlock64

setBlock64是在Go语言运行时中的mpallocbits.go文件中定义的一个函数。该函数的作用是将一个64位数的位图设置为特定的值。

在Go语言中，内存管理器需要维护一组位图，以追踪哪些块的内存是空闲的。位图中的每一个位对应一个内存块，如果该位为1，则表示该内存块是空闲的，否则表示该内存块已经被分配。

setBlock64函数的参数是一个64位数的指针，它指向需要设置的位图。该函数通过将该64位数与一个掩码（mask）进行按位与操作，将指定的位列设置为1，其他的位则保持不变。具体来说，setBlock64函数实现将一个特定的块标记为当前可用，并在这个过程中保持锁定。

这种内存管理技术是Go语言的一种高效的内存管理方式，可以有效地确保内存的安全性和高性能。通过使用位图来跟踪内存块的使用情况，Go运行时可以快速地分配和释放内存，在没有造成过多的内存碎片的同时，提高了内存的利用率。



### clear

在Go语言中，mpallocbits.go文件是用于内存管理的一部分实现。其中，clear函数的作用是将指定字节范围内的bit位全部清零。

具体来说，clear函数的参数是两个uintptr类型的指针，分别指向需要操作的字节范围的起始地址和结束地址。函数内部会先计算出这个范围的字节数，进而将对应的bit位全部设置为0。

这个函数的主要应用场景是在分配内存时，需要对新申请的内存进行清零，以避免其中包含敏感信息或无法预测的旧数据。通过调用clear函数，可以快速高效地对内存进行清零操作，提高程序的安全性和稳定性。

总之，mpallocbits.go文件中的clear函数是Go语言中内存管理的一个重要组成部分，它可以有效地清零指定范围内的bit位，保障程序的安全性和稳定性。



### clearRange

在Go语言中，每个Goroutine都有一个分配器（allocator），用于动态分配内存，这样就不需要手动管理内存。runtime/mpallocbits.go中的clearRange函数用于清除一段内存区域上的标记位，标记位表示内存是否已经被分配或释放。当需要分配内存时，分配器需要通过扫描标记位来查找可用的内存块。如果标记位没有被清除，就可能导致分配器误认为该内存块仍然被占用，从而无法对其进行分配。

clearRange函数的作用是将一段内存区域上的标记位全部清零，这样可以确保该区域的内存块处于可用状态。这个函数通常在回收内存时被调用，例如当Go程序执行垃圾回收时，就需要将已经标记为不再使用的内存块的标记位清除掉，以便它们被重新分配。此外，在管理内存池时，也可能需要使用这个函数来清除内存池中的标记位，以便其中的内存块可以重新使用。



### clearAll

在go/src/runtime中，mpallocbits.go这个文件是用于跟踪和分配内存的。其中的clearAll函数用于清除分配器位图中所有的位，使其全部置为0。

分配器位图用于跟踪哪些内存块已经被分配或释放。当分配器需要分配内存时，它会扫描位图，找到一个可用的未分配内存块，并将其标记为已分配。当内存块被释放时，分配器会将其标记为未分配。

在程序运行过程中，分配器位图会不断地被修改和更新。为了避免在分配器位图中留下脏数据，必须定期清除它。clearAll函数就是用于清除位图中的所有位。

具体来说，clearAll函数会将分配器位图中每个字节的值都置为0。这样做的好处是，可以在下一次分配时，从位图的开头开始查找可用内存块，而不必担心之前已经使用过的位。

总之，clearAll函数是一个重要的内存管理函数，它确保了分配器位图的正确性，使分配器能够更有效地管理内存。



### clearBlock64

在Go语言的运行时（runtime）中，mpallocbits.go文件包含了一些与内存分配和管理相关的函数。其中，clearBlock64是一个清除连续内存块的函数，用于在内存回收时清除并移除这些内存块的分配位图。

该函数的具体作用是将一个大小为64字节的内存块中的所有位设置为0，以便使该内存块可以重新分配给新的对象。该函数的实现采用了CPU指令级并行化来提高清除的速度，从而使内存回收的效率更高。

总的来说，clearBlock64函数是Go语言内存分配和管理的关键组成部分之一，它可以帮助程序在运行时更好地管理内存使用，提高程序的性能和稳定性。



### popcntRange

popcntRange函数是一个内部函数，用于计算在一个字节切片（byte slice）中指定范围内的二进制位中，值为1的位数（即"population count"的缩写）。这个函数主要用于mpallocbits.go文件中的分配器中，用于计算哪些字节被当前的goroutine占用。

具体地说，popcntRange函数的参数包括：

- b：一个字节切片（byte slice），表示某个区域内的一组二进制位。
- off、n：指定要计算的二进制位范围，即[b[off], b[off+1], ..., b[off+n-1]]。

函数内部使用了一些基本的位运算操作（如与、右移等）和一些常量（如0x55、0x33等），通过一个循环，将指定范围内二进制位中1的数量累加到变量p上，最后返回p的值。

总的来说，popcntRange函数主要用于高效地计算指定范围内的二进制位中1的数量，用于分配器中的占用位计数等操作。



### summarize

summarize函数是runtime中mpallocbits.go文件中的一个辅助函数，其主要作用是在分配器中对空闲的内存块进行分段统计，计算出包含哪些连续的内存块可以满足分配需求。

具体而言，summarize函数会接收一个表示空闲内存块的位图，然后根据位图中的信息，计算出哪些连续的块可以被归并为一个大块。这些大块通常是以连续的物理地址为基础的，可以被用于分配大内存对象。

summarize函数利用了一个双指针算法，通过在位图上移动两个指针，可以找到所有连续的内存块，并按照大小顺序对它们进行排列，最终得到一个连续的内存块列表。这个列表可以被传递到其他函数，用于分配大块内存对象。

总之，summarize函数在分配器中扮演了一个重要的角色，它可以帮助我们更高效地分配内存并避免内存碎片化。



### find

在Go语言的运行时系统中，每个操作系统线程都有其独立的内存分配器。mpallocbits.go文件是分配器的实现代码之一，其中的find函数用于分配内存块。

find函数接收两个参数：n和order。其中，n是需要分配的内存块大小（以字节为单位），而order是确定内存块大小级别的值。每一个级别对应着一组固定大小的内存块。在find函数中，order通常是通过计算n的二进制位数来确定的。

具体来说，find函数会搜索给定级别的内存块链表，以查找足够大的内存块来分配。如果找到合适的内存块，则将其从链表上取下并返回其地址。如果没有找到合适的内存块，则会通过其他函数来向操作系统申请更多的内存。

同时，find函数还会对已分配的内存块进行初始化和标记，以防止内存泄漏和未定义行为。这是Go语言运行时系统中非常重要的一部分，目的是确保程序能够正常运行且不会出现内存相关的问题。



### find1

mpallocbits.go文件中的find1函数用于在位图中查找第一个为1的位。在Go语言的运行时中，内存的分配和释放都需要使用位图来管理，因为位图可以提高内存分配和释放的效率。具体来说，当需要分配一块内存时，运行时会先在位图中查找一个未被分配的连续的空间，然后将该空间标记为已被分配；当需要释放一块内存时，运行时会根据该内存的地址计算对应的位图下标，然后将该位标记为未被分配。

find1函数的实现比较简单，它使用了位运算技巧，通过不断地将整个位图按位与上其补码的方式来查找第一个为1的位，即未被分配的连续空间的起始位置。当找到第一个为1的位时，函数返回该位在位图中的下标，即该连续空间的起始地址。如果位图中没有连续的空间可用，函数返回-1。

总之，find1函数是Go语言运行时中内存管理的关键组成部分之一，它的作用是查找未被分配的连续内存空间。



### findSmallN

findSmallN是用于查找小对象分配位图的函数，它的功能是根据小对象的大小（小于等于32字节），返回对应的分配位图索引值。也就是说，它的作用是确定分配位图中的哪一位表示可以用于分配该对象的内存块。

具体实现如下：

- 如果大小小于等于8，则返回其大小除以2的整数值-1；
- 如果大小小于等于16，则返回7；
- 如果大小小于等于32，则返回7+（大小减去16的整数值）。

值得注意的是，分配位图是用于回收已分配内存区块的标记数据结构，通过追踪垃圾收集器和自由列表的状态，记录哪些内存块被分配和使用，哪些没有被使用，因此，对于不同大小的对象，需要使用不同的位图来追踪其内存分配情况。而对于小对象，通过findSmallN函数返回的索引值可以很快地定位到分配位图中对应的位，从而查看其分配状态。



### findLargeN

findLargeN是用于在分配堆空间时选择最合适的大小的函数。它接受一个假定的空间大小，并返回大于或等于该大小的可用内存块的大小，但不能超过最大块大小。

具体来说，它会从内存块的位图中搜索可用的连续空间块，并将其大小与请求的大小进行比较。如果找到的块大小大于请求大小，则返回该大小。如果找到的块大小等于请求大小，则返回该大小。如果找不到足够大的块，则返回最大块大小。

这个函数的作用是帮助分配器选择最优的内存块以减少内存浪费和碎片化。



### allocRange

allocRange函数在Go语言运行时（runtime）中的mpallocbits.go文件中。

这个函数主要用于在一个地址范围中查找是否有内存块可用。在一个范围内查找内存块时，它会检查范围内的位图，并查找是否存在一系列连续的可用内存块。

它使用两个输入参数。第一个参数是白名单起始地址，第二个参数是范围的大小。在执行时，它会返回地址和大小，这些地址和大小代表连续可用内存块的起始地址和大小。

该函数在Go语言中的内存管理方面扮演着重要的角色。它帮助Go运行时系统管理内存并避免内存泄漏。在程序需要动态添加或删除内存块时，该函数可以查找可用地址并分配内存。



### allocAll

在go/src/runtime/mpallocbits.go文件中，allocAll函数的作用是将给定的内存块标记为已分配，并返回其内存地址。

在Go语言中，分配内存是由内存分配器管理的，该分配器使用了一种称为mcache的缓存机制来提高内存分配的效率。allocAll函数是mcache的一部分，它的作用是将所有的未分配空间都标记为已分配空间，并将其返回给调用者。

具体来说，allocAll函数中会调用mcache的alloc函数来进行内存分配。alloc函数会分配一块大小为mp_.allocChunkBytes的内存空间，并将其标记为已分配空间。然后，allocAll会使用一个循环遍历未分配空间列表中的所有块，并将它们标记为已分配空间。最后，allocAll会返回第一个已分配空间的指针。这个指针就是分配给调用者的内存地址。

总之，allocAll函数是内存分配器中的一个重要功能，它能够高效地将未分配空间标记为已分配空间。这有助于提高内存分配的效率，并减少内存碎片的产生。



### free1

func free1(p heapBits, size uintptr) {
	// 根据使用的大小size来获取heapBits，并将其设置为0
	hbits := p[:size/heapBitSpan]
	for i := range hbits {
		hbits[i] = 0
	}
	// 如果存在对于heapBits数组的内存预分配，则返回预分配的一部分内存
	if size == heapArenaBitmapBytes && runtime.allocToCache(mheap_.centralCache, p) {
		return
	}
	// 释放heapBits所在的页框
	_p := uintptr(unsafe.Pointer(&p[0]))
	sysUsed(_p, _p+size, nil, 0)
}

free1函数实现了将一个已经使用过的heapBits标记为未使用，从而将其返回给内存池。具体来说，它会将使用的heapBits设置为0，然后归还该heapBits所在的页框。如果该heapBits是从central cache的缓存中预分配的，则会将一部分内存返回到缓存中，以便下一次快速地分配内存。该函数是整个分配器中非常重要的一个函数，因为它支持将内存重新分配和回收。



### free

在Go语言的运行时(runtime)中，mpallocbits.go文件中的free函数主要负责将某些内存块的状态改变为"空闲"，以便可以重新使用这些内存块。

具体来说，当程序使用malloc或new函数动态分配内存时，Go语言运行时系统会将需要的内存块从操作系统中获取，并进行管理。在这个过程中，所有分配的内存块都会被标记为"已分配"状态，以表示这些内存块已被程序使用，不能再次分配给其他变量或对象。

但是，当程序执行完一些操作后，有些内存块可能已经不再需要了，但是它们的状态仍被标记为"已分配"。为了使这些内存块再次可用，我们需要将它们的状态改为"空闲"。这时，就需要使用free函数。

具体来说，free函数所接收的参数是指向一段已分配内存块的指针。当调用free函数时，运行时系统会将该内存块的状态改为"空闲"，表示该内存块可以被重新分配给其他变量或对象。

需要注意的是，free函数只能用于已分配的内存块，否则可能会导致程序崩溃或出现其他错误。此外，由于Go语言使用垃圾回收机制，程序通常不需要手动调用free函数，因为垃圾回收机制会定期检查所有已分配内存块的使用情况，并自动回收不再需要的内存。



### freeAll

mpallocbits.go文件是Go语言的运行时库中的一个文件，它实现了一些管理内存分配的功能。其中，freeAll这个函数的主要作用是将一个分配器中所有未使用的内存块都释放掉，以便重新分配。

具体地说，这个函数会遍历分配器中已经分配的所有内存块，并将它们标记为未使用，然后将这些内存块加入到一个链表中。最后，这个函数会利用OS级别的函数将这些内存块返回给系统，以便重新利用。

这个函数的实现涉及的一些关键概念包括：

- 分配器（allocator）：负责分配内存的模块，可以通过调用系统的malloc函数或者其他机制来获取所需的内存。
- 内存块（memory block）：分配器返回的内存单位，通常包含一定字节数的连续内存。
- 标记（marking）：将内存块的状态标记为已使用或未使用。
- 链表（linked list）：将多个内存块按照一定顺序连接起来的数据结构。

总的来说，freeAll函数的作用是回收分配器中未使用的内存块，以便后续的内存分配可以重用这些内存块，从而提高程序的内存利用率。



### pages64

在Go语言中，内存管理的核心是在运行时runtime包中实现的。其中，mpallocbits.go文件的作用是实现了对于小对象内存分配的细致管理。

pages64函数是其中的一个重要函数，它的作用是为指定大小的内存块分配物理内存页。在Go语言中，内存分配的粒度是以页为单位的，而不是以字节为单位的。因此，当需要为一个小对象分配内存时，需要将其大小舍入到最接近的2的整数次幂，并将其分配到相应的页面中。

这个函数会首先计算出所需的物理内存页的数量，然后循环申请对应数量的物理内存页，并将其映射到虚拟地址空间中，并返回映射后的虚拟地址。如果内存不足，会通过系统调用去向操作系统请求额外的物理内存页。该函数还会为将要分配的小对象设置一些标志，用于标识其内存块的状态。

需要注意的是，该函数只适用于在64位环境下运行的程序，因为在32位环境下，物理内存是以4KB为一页的，而在64位环境下，物理内存是以64KB为一页的。

总体来说，pages64函数是Go语言中用于对小对象内存分配进行细致管理的一个非常重要的函数，其功能可以让程序更加高效地利用内存资源，同时也可以提高应用程序的性能表现。



### allocPages64

allocPages64是一个函数，它位于go/src/runtime/mpallocbits.go文件中。它的作用是为64位指针分配一个连续的内存分页。

在Go语言中，指针通常是64位的。在内存中分配大量的64位指针会导致内存碎片化问题，因为默认情况下，Go运行时使用8字节对齐的堆分配内存。这意味着它在分配内存时每次都会分配8字节的倍数，并且可能会留下未使用的字节，从而导致内存浪费。

为了解决这个问题，Go运行时使用可变长度内存页（Variable Length Memory Pages，VLP）来最大程度地利用内存，并减少不必要的浪费。allocPages64函数负责分配这些VLP页面并返回一个用于分配64位指针的内存块。

具体来说，allocPages64函数会先从VLP可用列表中查找可用页面。如果找到，则将页面从列表中分离，并返回页面的首地址。如果找不到可用页面，则会分配新的页面后返回其首地址。

此外，allocPages64还会添加一个字节的页头到分配的页面中，用于跟踪页面的状态和大小等信息。这个页头的大小取决于VLP的架构和设置，通常为4或8字节。

总之，allocPages64函数是Go运行时的一部分，为64位指针分配连续的内存分页，并帮助解决了内存碎片化问题，从而提高了程序的性能和可靠性。



### findBitRange64

findBitRange64是在mpallocbits.go文件中的一个函数，用于在一个64位的无符号整数中查找连续的0位或1位。

具体来说，它接收三个参数：words是一个数组，表示一堆64位的无符号整数；n是这个数组的长度；和need是想要查找的位的值，0表示查找0位，1表示查找1位。

它会遍历words的每一个元素，对每一个元素进行以下操作：

1. 如果这个元素等于0，表示这64位都是需要的值，比如需要查找0位，那么就返回0～63（因为这些位都是0）；如果需要查找1位，那么就返回-1，表示没有连续的1位。

2. 如果这个元素等于-1，表示这64位都是相反的值，那么就继续循环下一个元素。

3. 如果这个元素不全是0或者1，那么就对这64位进行二分查找，找到最长的一段连续的满足条件的位，并返回这段连续的位的起始位置和长度。

最后，将所有元素得到的结果合并起来，返回最长的一段连续的满足条件的位的起始位置和长度。

这个函数的作用是用于在内存池中查找连续的空闲位或已分配的位，以便进行内存的分配和回收。



### allocRange

allocRange函数的作用是从Heap内存中分配n个连续字节大小的内存块。这个函数是通过在内存映射表上分配位图的方式来实现的。

具体来说，当执行allocRange函数时，它会遍历Heap内存中的每一个page，查询该page是否被标记为已使用。对于每一个连续的未使用page集合，如果这个连续的page集合中的字节数大于等于n，则分配这个集合，并将每个page标记为已使用。如果能找到这样的连续page集合，则返回这个集合的头部指针。

此外，allocRange函数还会处理Heap内存中的残余内存，如果还有未使用的连续字节数小于n，就将该连续内存直接分配出去。

总的来说，allocRange函数是在Heap内存中寻找并分配连续内存块的函数，是Go语言实现内存管理机制的重要组成部分。



### allocAll

在Go语言的运行时(runtime)系统中，mpallocbits.go文件中的allocAll函数是用来为一个mheap（内存堆）分配内存空间的函数。其中，mheap是Go语言中用于管理内存的重要组成部分之一。

当需要分配一个大块内存时，Go语言的运行时系统会使用allocAll函数从系统中申请一大块内存空间，并将这个内存空间划分为一组小块。然后，这些小块被用于分配给调用方所需的内存块。

这个函数的主要作用是将可用的内存空间按照特定的算法进行划分和管理，以确保大量的内存操作可以高效地进行。它使用一种被称为span的数据结构来管理内存块。span是一段连续的内存空间，被划分为固定大小的块。当一个新的内存分配请求到达时，mpallocbits.go文件中的allocAll函数会检查可用span列表中是否有适合请求大小的span，如果有，则将其分配给请求，否则会从操作系统获取更多内存，并对其进行管理。

总之，allocAll函数是Go语言运行时系统中的关键组成部分之一，用于动态管理内存分配和释放，确保内存管理的高效性和可靠性。



