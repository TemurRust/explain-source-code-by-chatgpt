# File: mpagealloc_32bit.go

mpagealloc_32bit.go是Go语言运行时（Runtime）中用于实现32位操作系统下内存分配的模块。在32位架构中由于地址空间的限制，Go语言运行时需要对内存分配策略进行一些特殊的优化和处理，以充分利用可用的内存空间。

该模块实现了一种分页式的内存管理算法，即将连续的物理内存划分为若干页（通常为4KB），每个页可作为分配的最小单位。当程序需要分配内存时，会从一个空闲页列表中找到一个可用的页，并将其分配给程序。当程序释放内存时，会将内存所在的页重新加入到空闲页列表中。

该模块还考虑到了内存对齐的问题，即内存地址需要满足特定的对齐要求才能被正常使用。为此，该模块实现了一个对齐函数，确保所有分配的内存地址都满足对齐需求，从而提高内存利用率和程序性能。

总之，mpagealloc_32bit.go是Go语言运行时中非常重要的一部分，实现了32位架构下的内存分配优化和对齐处理，保证了程序在32位平台下的正常运行和高效性能。




---

### Var:

### levelBits

在go/src/runtime中的mpagealloc_32bit.go文件中，levelBits这个变量是用来控制每个span块的大小的。 在翻译成汉语之前，需要先了解一些背景知识。

在32位系统中，最大的一个地址空间是4GB。将这个地址空间拆分成大小为8KB的块，则总共有2^32/2^13=2^19个块。对于每个块，我们只需要保存一些元信息（比如是否被分配、是否被使用等等）。然而，即使只有这些元信息，也会消耗不少的内存空间。

为了优化这个问题，可以使用一个类似二叉树的结构来存储元信息。具体来说，将2^19个块分成两个等分，即左子树和右子树，每个子树又各自划分成两个等分，形成四个子树，如此递归下去，直到每个块都成了叶子节点。因此，这个二叉树有19个级别（level），每个级别包含2^(19-level)个块。

为了更加方便地操作这个二叉树，我们可以使用一个类似于数组的数据结构来存储这个二叉树。具体来说，将第i级别的块存储在数组的位置2^i到2^(i+1)-1之间。因为第0级别只有一个元素，所以可以不考虑。

此时的问题是：我们需要设置每个块的大小，而这个大小应该是和块所在的级别有关的。显然，每个级别包含的块数是在递减的，因此每个级别包含的块大小也应该在递增。使用levelBits这个变量，我们可以计算每个块的大小，即1<<(10+level-levelBits)。其中，10是每个块的大小默认为2^10=1024字节，level是块所在的级别，levelBits是一个变量，它用来控制每个级别中间隔了多少个块之后，块的大小加倍。在具体的实现中，levelBits的值可以通过简单的概率计算来得到，以保证每个级别的内存占用差异不会过大。



### levelShift

在mpagealloc_32bit.go文件中，levelShift是一个常量，其值为13。它的作用是在32位操作系统中获取内存页面的大小，由于32位操作系统最大的内存寻址范围只有4GB，因此在获取内存页面大小时需要进行特殊处理。具体来说，levelShift与maxLevel一起用于计算和确定每个arena的页大小。页大小的计算取决于一个arena的大小，它会根据指定的maxLevel值来生成。在这个过程中，levelShift表示了页面大小的最小限制。

在32位操作系统中，程序可以访问的实际内存范围（即虚拟内存）最大只有4GB，而真正的物理内存是远大于这个范围的。为了让32位操作系统可以访问更大的物理内存，操作系统会采用一些技术，例如分页或虚拟内存。在go的运行时中，为了充分利用32位操作系统上的物理内存，需要对每个arena在内部进行分页。每个arena都会被分为大小相等的块，这些块被称为页。levelShift常量的值被用作页大小的最小限制，以确保操作系统能够有效地管理页面。

因此，levelShift在mpagealloc_32bit.go文件中的作用是为了定义32位操作系统中arena的页面大小，并确保其最小限制。



### levelLogPages

变量levelLogPages是一个表示系统内存分配器的级别的值，它用于决定分配内存的粒度大小。在go/src/runtime/mpagealloc_32bit.go文件中，这个变量的值被设置为13，表示分配器使用的粒度大小是2的13次方，也就是8192个字节（或8KB）。这个值是根据实际场景和性能考虑得出的经验值。

在级别稍低的情况下，每个分配请求都将得到比实际需要更多的内存，以便保持内存分配的粒度和对齐。高级别的级别说明更少的内存被“浪费”，但也可能导致内存碎片和更频繁的分配。因此，选择一个适当的级别对于内存分配器的性能和可靠性非常重要。

在Go语言中，分配器通过自适应性地调整粒度大小来平衡性能和内存使用。如果某些大小的分配请求变得更为常见，它们可能会尝试逐渐使用更小的粒度以减少浪费。相反，如果分配请求变得更加分散，并且没有足够的大分配请求来支配样本，那么它们可能会选择逐渐使用更大的粒度来避免过度透支内存。所以，levelLogPages变量的设置具有重要的作用，它直接影响Go语言内存分配器的性能和效率。



### scavengeIndexArray

在Go语言中，mpagealloc_32bit.go文件是在32位平台上使用的内存管理器实现。其中，scavengeIndexArray变量是用来记录空闲页框的索引的数组。

在Go语言中，内存管理器会将堆空间分成等大小的页框（page）。当内存空间不足时，内存管理器会优先回收空闲的页框来满足新的内存分配请求。scavengeIndexArray就是用来记录哪些页框是当前空闲的。

具体来说，scavengeIndexArray是一个由uint32类型组成的数组。每个元素表示一个页框的状态，包括：

- 已经分配：表示该页框已经被分配给某个对象。
- 空闲：表示该页框当前是空闲的，可以分配给新的对象。
- 头部页框：表示该页框是一块连续内存的第一个页框，用于记录当前连续内存块的元信息。

由于scavengeIndexArray记录的是已经分配的页框和空闲的页框，因此内存管理器可以快速地找到空闲的页框来分配新的内存空间，从而提高内存分配的性能。

总的来说，scavengeIndexArray是Go语言32位平台上内存管理器的核心数据结构之一，它记录了内存分配和回收的状态，使得内存管理器可以快速地响应分配请求并管理内存空间。



## Functions:

### sysInit

在Go语言的运行时(runtime)中，mpagealloc_32bit.go文件实现了在32位架构下的内存页分配器。这个文件中的sysInit函数用于初始化分配器，并将其与操作系统的函数接口进行连接。

具体而言，sysInit函数会执行以下几个步骤：

1. 调用meminit函数进行内存管理器的初始化。
2. 调用minit函数，对所有的M（机器线程）进行初始化。
3. 调用newm函数，用于每个P（processor）创建一个M。
4. 调用sysAlloc函数，分配一块kernel栈的内存。
5. 调用osStackInit函数，初始化该栈。
6. 调用resetcpu函数，将CPU的状态重置为初始状态。
7. 调用setG0函数，设置G0寄存器指向G的初始值。
8. 调用schedInit函数，初始化调度器。
9. 调用mp.procid.alloc函数，创建一个Proxy对象，并将其与M的ID关联。
10. 调用mp.pageAlloc.init函数，初始化内存页分配器。
11. 最后将分配器与操作系统的函数接口进行连接。

总的来说，sysInit函数是在32位架构下Go语言运行时的初始化函数，主要是对运行时所有的组件进行初始化，并连接内存页分配器与操作系统函数接口。



### sysGrow

mpagealloc_32bit.go文件中的sysGrow函数是runtime包中的一部分，它的主要作用是增加当前进程的虚拟内存空间大小，并且会将映射到该空间的物理内存也相应地增加。

该函数的实现涉及到与操作系统的交互，因此其主要功能由syscall包提供。具体来说，sysGrow函数首先会通过调用os调用mmap实现分配更多的虚拟内存空间。然后，它会调用syscall包提供的madvise函数以告知操作系统如何使用该内存页和何时释放它们。

此函数的另一个关键功能是实现与32位操作系统的兼容性，因为在32位操作系统上，每个进程能够访问的虚拟内存空间总量是有限的，通常为4GB或更少。因此在使用时需要小心管理虚拟内存，避免出现内存耗尽的情况。



### sysInit

在go/src/runtime/mpagealloc_32bit.go中，sysInit函数是在进程初始化时调用的。它的目的是初始化一些全局变量和数据结构，为后续的内存分配操作做好准备。

具体来说，sysInit函数会调用initHeap函数来初始化堆内存，并在堆内存中分配一段空间作为可用内存池。它还会设置页表映射，以确保堆内存能够被正确地映射到虚拟地址空间中。此外，sysInit函数还会初始化用于跟踪内存分配情况的统计信息，并为内存分配器的控制参数设置默认值。

总的来说，sysInit函数的主要作用是在进程启动时初始化一些必要的内存分配器参数和数据结构，为后续的内存分配操作做好准备。它是内存分配算法的一个重要组成部分，确保系统能够正常地分配和管理内存。



### sysGrow

在go/src/runtime/mpagealloc_32bit.go文件中，sysGrow是一个函数，其主要作用是将操作系统分配的虚拟地址映射到物理地址空间，从而将内存分配给进程使用。

具体来说，sysGrow函数通过调用操作系统的虚拟内存分配函数，申请一段连续的虚拟地址空间，然后将这段虚拟地址空间与物理地址空间建立映射关系。这样，当进程使用这段虚拟地址空间时，就会被映射到相应的物理地址，从而实现了内存的分配。

需要注意的是，sysGrow函数主要用于在32位架构下进行内存分配，其实现过程中会考虑到内存的地址空间限制等问题，确保分配的内存不会超出系统的最大地址空间。此外，由于sysGrow函数是通过操作系统的底层函数实现的，因此在不同的操作系统下可能会略有不同。



