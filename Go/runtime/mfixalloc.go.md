# File: mfixalloc.go

mfixalloc.go是Go语言中运行时系统（runtime）的一部分，主要用于分配固定大小的内存块（即“定长内存池”），也就是将一大块内存按照固定大小进行划分，以便在程序运行期间快速分配和回收内存。

mfixalloc.go文件中主要包含了以下函数：

- *mheap.fixalloc()：该函数用于初始化定长内存池对象，包括固定块大小、内存总大小、空闲块链表等，并返回一个新的定长内存池对象。
- *mheap.alloc()：该函数用于分配一块固定大小的内存块，它会先从定长内存池的空闲块链表中查询是否有可用内存块；如果没有可用内存块，则调用系统调用申请更多内存。
- *mheap.free()：该函数用于释放已分配的内存块，它会将该内存块放回到定长内存池的空闲块链表中，以便其他程序可以重复利用该内存块。

通过使用定长内存池，可以减少动态分配内存的开销，从而提高程序的执行效率和可靠性。同时，固定块的大小也可以使得程序运行期间的内存使用更加稳定，减少内存碎片和内存泄漏等问题。




---

### Structs:

### fixalloc

fixalloc结构体主要用于固定大小的内存分配管理，在Go语言的运行时库中被广泛使用。

该结构体有以下成员变量：

- size：每个对象的大小，以字节为单位。
- typ：指向每个对象的类型描述符（Type）。通常，内存池中的所有对象都应该使用相同的类型描述符，因此该变量可以共享。
- lock：互斥锁，用于保护cache和list成员。
- list：一个空闲链表，记录所有空闲的对象。
- cache：本地cache，在所有空闲对象的链表上之前，每个P可以保留一些对象，以提高访问速度和可扩展性。

在fixalloc结构的生命周期内，它可以初始化一块大的内存块，然后把它切成一系列大小相同的小块，并将每个小块添加到空闲链表中。某个goroutine需要一个新对象时，可以从cache或空闲列表中获得一个，如果没有可以使用的对象时，它可以分配另一个大的内存块，重复上述过程。

与普通的malloc相比，fixalloc有以下优点：

- 回收对象时不需要标记和扫描，因此不会对垃圾收集器产生压力。
- 空闲对象可以被缓存在本地cache中，提高了访问速度。
- 可以使用固定大小的小块分配器来降低碎片。

这些优点使得fixalloc成为一种高效的内存分配方式，在Go的运行时系统中得到广泛的应用。



### mlink

在Go语言的runtime库中，mfixalloc.go文件中的mlink结构体用于表示一组fixed-size对象的链表。它的定义如下：

```
type mlink struct {
    ptr uintptr
    next *mlink
}
```

其中，ptr字段表示该对象的地址，next字段表示下一个mlink对象的地址。

在Go语言中，fixed-size对象的内存分配是通过mallocgc函数完成的。当需要分配n字节的fixed-size对象时，runtime会从对象的链表中找到一个大小为n的对象，然后将其从链表中删除并返回，这样就完成了一次内存分配。当这个对象不再使用时，它会被放回到链表的头部，以便在下次内存分配时能够快速找到。

在mlink结构体中，ptr字段记录了对象的地址，next字段则可以用于将该对象与链表中的其他对象连接起来，以便快速找到和删除对象。因此，mlink结构体在Go语言runtime库中扮演着非常重要的角色，对于fixed-size对象的内存分配和回收有着至关重要的作用。



## Functions:

### init

在go/src/runtime中mfixalloc.go这个文件中的init这个func主要是用来初始化用于分配固定大小对象的内存分配器。

具体来说，init函数实现了以下任务：

1. 初始化了由mcache结构体组成的指针数组mcache0和mcache1，其中mcache结构体是一个缓存对象池，用于存储固定大小的对象；
2. 初始化了由mcentral结构体组成的指针数组central，其中mcentral结构体是一个中央缓存对象池，用于向mcache结构体提供对象；
3. 初始化了由对象大小组成的指针数组sizemap，其中每个元素的值表示相应大小对象所需要的空间大小；
4. 初始化了由指针数组buckets和nbookets组成的指针结构体mbuckets，其中buckets数组存储对象大小为sizemap中大小的倍数的对象，nbookets存储buckets数组的长度；
5. 利用初始化好的mcache0和mcache1以及sizemap，central，buckets和nbookets构造了适用于分配固定大小对象的内存分配器mfixalloc。

总的来说，init函数在go的运行时中扮演着重要的角色，它初始化了go程序所需的内存分配器，保证了程序在运行时的稳定性和性能。



### alloc

在Go语言中，内存的管理是由运行时系统（runtime）进行的。mfixalloc.go文件中的alloc函数是一种特殊的内存分配函数，用于从堆中申请指定大小的内存块，同时能够保证内存分配的对齐方式和内存块的大小。

具体来说，alloc函数的主要作用包括以下几个方面：

1. 根据所需内存大小进行对齐：由于硬件系统的限制，内存分配的大小通常需要进行一定的对齐。alloc函数会根据所需内存大小，在运行时计算出最小的对齐单位，并将内存大小向上取整，使分配的内存大小满足对齐要求。

2. 分配内存块：在对齐后，alloc函数会从堆中分配所需大小的内存块，并记录相应的元数据信息，包括内存地址、内存大小和对齐方式等信息。

3. 修改内存类型：alloc函数还可以修改内存块的类型，将其从托管内存（managed）更改为非托管内存（non-managed）。托管内存由Go语言的垃圾回收器进行管理，而非托管内存则由调用者自行管理。

通过alloc函数对内存的分配和管理，Go语言可以更加高效和灵活地进行内存分配，同时保证了内存分配的正确性和安全性。



### free

在 Go 语言中，**mfixalloc.go** 文件是 runtime 包中用于内存管理的一个核心文件。这个文件中定义了一些函数，其中一个就是 `free()`。

`free()` 函数的作用是将一片已经分配的内存块释放掉，以便重新使用。在 Go 语言中，内存分配采用了一种称为堆的数据结构来管理。为了更好地利用堆空间，runtime 包中定义了一些内存管理函数，可以高效地分配和释放内存空间。

具体来说，对于一个已经分配的内存块，当它不再需要使用时，可以使用 `free()` 函数释放掉。这个函数会将这个内存块从堆中删除，并将其标记为可用空间，以便下次分配时可以直接使用。在实际使用中，`free()` 函数通常由内存管理器自动调用，而不是手动调用。这样可以确保内存使用的高效和安全性。

总之，`free()` 函数是 runtime 包中用于释放内存的一个核心函数，通过调用它可以将已经分配的内存块释放掉，以便重新使用。



