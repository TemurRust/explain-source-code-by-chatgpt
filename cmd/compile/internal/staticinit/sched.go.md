# File: sched.go

sched.go是Go语言中的一个调度器文件，它实现了Go语言程序的调度器。调度器是Go语言的运行时系统的一部分，负责管理和调度所有Go协程的执行。 

在Go语言中，所有的协程都由调度器来管理，调度器知道每个协程的状态，例如：阻塞、就绪、运行等等。调度器会根据协程的状态来决定哪个协程应该运行，这样可以保证多个协程之间的相互协作和并发执行。

调度器负责实现Go语言的一些核心特性，例如：goroutine的轻量级切换、基于通道的并发编程、GC垃圾回收等等。该文件实现了调度器的主要功能，包括：

1. 协程的调度：sched.go负责 Go 协程的创建、运行和结束。它还负责协程的切换、调整和优先级处理。

2. 初步处理系统调用：当Go程序执行系统调用时，sched.go会做一些初步的处理，例如：把当前协程暂停、切换到其他协程执行等等。

3. Channel的处理：sched.go会监控 Go 程序中的 Channel，当 Channel 中有消息到来时，调度器会选择合适的协程来处理该消息。同时，调度器也会监控 Channel 的缓存情况，如果 Channel 的缓存满了，调度器会暂停该协程的执行，直到 Channel 中的消息被消费。

4. 垃圾回收：Go语言中的垃圾回收是由调度器来实现的。sched.go会监控 Go 程序中的内存使用情况，并在需要的时候进行垃圾回收。

总之，sched.go是Go语言内置的调度器模块，它很好地支持了并发编程和资源管理，使得Go语言程序可以充分利用多核CPU和异步I/O等硬件资源，实现高性能的并发编程。




---

### Var:

### varToMapInit

在go/src/cmd/sched.go文件中，varToMapInit变量用于确保全局变量gvarToMap只被初始化一次。

当变量gvarToMap被首次调用时，varToMapInit值为0，它初始化gvarToMap并将varToMapInit设置为1。此后，每次gvarToMap被调用时，它只是返回已经被初始化过的全局变量。

它的作用是在多个goroutine间共享全局变量gvarToMap，减少初始化的开销，提高性能。



### MapInitToVar

在Go语言中，MapInitToVar是一个布尔值，它的作用是标记编译器是否将map初始化表达式分配给一个新的变量。如果被设置为true，则编译器会为map初始化表达式创建一个新的临时变量并将其分配给该变量，如果为false，则编译器会将map初始化表达式直接分配给map变量。

具体地说，当MapInitToVar被设置为true时，源代码中的语句：

```
m := map[int]string{1:"one", 2:"two", 3:"three"}
```

将被编译为：

```
tmp := map[int]string{1:"one", 2:"two", 3:"three"}
m := tmp
```

而当MapInitToVar被设置为false时，源代码中的语句：

```
m := map[int]string{1:"one", 2:"two", 3:"three"}
```

将被编译为：

```
m := map[int]string{1:"one", 2:"two", 3:"three"}
```

通过控制MapInitToVar的设置，编译器可以优化map变量的分配过程，从而提高程序的性能。但需要注意的是，对于大部分应用程序而言，MapInitToVar的设置并不会对程序的性能产生显著影响，因此大部分程序员可以忽略它的存在。



### statuniqgen

首先，sched.go是go编程语言的一个源代码文件，位于/go/src/cmd目录下。该文件中包括了与调度器相关的代码，以及调度器运行时的统计信息和调度策略等。

在sched.go文件中，statuniqgen变量是一个用于生成唯一标识符的计数器，类型为uint64，初始值为1。该变量在调度器内部用于生成唯一的goroutine标识符，以便在统计和监测调度器性能时使用。每当调度器创建一个新的goroutine时，statuniqgen就会自增，并将这个唯一标识符分配给新的goroutine。

statuniqgen变量的作用是确保每个goroutine都有唯一的标识符，以便于调度器能够准确地监测和跟踪它们的状态和性能。这些标识符通常只在调度器内部使用，但有时也会暴露给外部监测系统或应用程序使用。



### mapinitgen

在Go语言中，mapinitgen是一个全局变量，定义在sched.go文件中，用于在程序启动时初始化map类型的哈希种子。哈希种子是一个随机的数值，在哈希计算过程中起到关键作用，因为同样的输入数据在使用不同的哈希种子计算时会产生不同的输出结果。

mapinitgen的值被用作内置map类型的哈希种子，即mapType的hash0字段。这个哈希种子是在程序启动时生成的，随后被赋值给所有的内置map类型。这样生成的哈希种子是伪随机的，并且在每个程序运行周期内都是恒定不变的。这样就保证了程序在使用map类型时能够获得较好的哈希质量，并且在不同的运行周期中能够产生相同的哈希值。这对于一些需要对数据进行哈希操作的应用程序而言是非常重要的。

总之，mapinitgen变量在Go语言中起到的作用是生成内置map类型的哈希种子，保证程序在使用map类型时能够获取到较好的哈希质量。






---

### Structs:

### Entry

Entry结构体是一个代表goroutine的数据结构，它主要用于调度器在运行时管理goroutine的状态和调度。具体来说，Entry结构体包含了以下字段：

- atomic.Value指针：用于存储goroutine的执行函数和参数的函数指针和参数值。
- goid字段：代表goroutine的唯一ID。
- flags字段：表示goroutine的状态和标志位，具体标识了goroutine是否被抢占、是否被阻塞、是否是系统栈等。
- waitlink字段：用于等待goroutine的链表链接。
- schedlink字段：用于调度链表链接，其中包括了不同优先级的链表。

Entry结构体的主要作用是存储goroutine的信息，以便于调度器在运行时管理和调度。可以说Entry结构体是调度器中最重要的数据结构之一，完全负责了goroutine的状态管理和调度。通过Entry结构体，调度器能够有效地管理所有goroutine，确保它们按照预期执行，并协调它们的执行时间，从而实现高效的并发执行。



### Plan

Plan结构体定义了一个调度计划，它用于描述一组待调度的任务以及它们的调度顺序和其他相关信息。

Plan结构体包含以下字段：

- P无符号整数类型，表示计划分配到的处理器数量；
- M无符号整数类型，表示计划分配到的运行时的数量；
- Spans  []span类型，表示任务的调度信息，即如何在处理器和运行时之间分配任务的详细计划。每个span表示一段时间，在这段时间内，处理器要执行的任务和分配给每个运行时的任务进行了说明；
- Nodes  []*NodeInfo类型，表示正在使用或者可能用来调度任务的节点的列表。每个节点都有一个标示符和一组运行时，每个运行时有一个对应的处理器；
- Work  []*gc.Work类型，表示待调度的任务列表。

Plan结构体的作用是提供一个清晰的抽象概念来描述待调度任务的状态，并且为Task Scheduler（任务调度程序）提供一个工具箱来进行任务的分配和调度决策。同时，它可以帮助开发人员更好地理解和分析任务的调度瓶颈，以及改进调度策略，提高程序的运行效率。



### Schedule

Schedule结构体是Go语言中调度器的核心结构体，负责管理可运行的goroutine队列，以及为将要运行的goroutine分配P（Processor）和M（Machine）。

具体来说，Schedule结构体包含了以下字段：

- runnable队列：存储可运行的goroutine。
- createdTempGoroutine队列：存储创建、等待分配P和M的goroutine。
- idleP队列：存储空闲的P。
- gcController相关字段：用于协调垃圾回收和调度。
- work struct：记录正在运行的goroutine的信息。

调度器通过Schedule的方法完成协程的调度、创建、唤醒、切换等操作。其中，调度器会根据系统资源分配和负载情况，为每个运行的goroutine分配一个P，并在P上运行当前的goroutine。

总之，Schedule结构体是Go语言调度器的核心，它负责管理资源分配和协程调度，为Go程序提供了高效而稳定的并发处理。



## Functions:

### append

在Go语言中，`append`是一个内置函数，用于将元素追加到切片的末尾。在`sched.go`文件中，`append`函数用于将任务添加到工作队列中以供执行。

具体来说，`sched.go`文件是Go语言运行时系统的一部分，它实现了Go语言程序中的协程调度器。在调度器中，有一个名为 `work` 的工作队列，用于保存需要执行的任务。每当协程完成一个任务后，它会从工作队列中获取下一个任务并执行它。

当程序需要向工作队列中添加任务时，调度器会使用`append`函数将任务添加到队列的末尾。如果工作队列已满，`append`函数会自动将其扩展以容纳更多的任务。这使得调度器能够有效地处理大量的并发任务，而不需要过多地关注内存管理和扩容的问题。

总之，`append`函数在Go语言的调度器中起着至关重要的作用，它使得程序能够高效地管理和执行大量并发任务。



### StaticInit

sched.go文件中的StaticInit函数是一个系统初始化函数，用于在系统启动时为调度器设置一些默认参数。它主要做以下几件事情：

1. 设置调度器的默认时间片大小（默认为10ms）。这个时间片指的是一个goroutine执行的时间，超过这个时间就会被强制调度出来，让其他goroutine获得执行机会，防止某个goroutine长时间占用CPU资源。

2. 设置调度器的最大P（Processor）数目。P是指用于执行goroutine的逻辑处理器，在多核处理器上可以并行执行多个goroutine，从而提高整个程序的并发能力。这个参数默认为256，可以根据实际需求进行修改。

3. 初始化调度器的全局数据结构。调度器维护了多个队列用于保存当前运行的goroutine以及等待运行的goroutine。这个函数会初始化这些队列以及其他一些与调度器相关的数据结构。

4. 启动调度器的监控线程。调度器会在后台运行一个监控线程，用于检测所有的goroutine是否都处于阻塞状态。如果是，那么调度器会把它们都放到等待队列中，等待新的事件触发。这个函数会启动这个监控线程，从而保证整个程序的运行稳定性。

总之，StaticInit函数是一个非常重要的初始化函数，它使得调度器可以在程序启动时就具备基本的工作能力，为后续的goroutine调度和管理提供了基础。



### recordFuncForVar

sched.go中的recordFuncForVar函数用于记录变量的所有读和写操作，以便在将来的调度和追踪中使用。具体来说，它会创建一个新的trackedVar结构体，其中包含有关变量的信息，包括变量的名称、类型、所在的函数、读写操作的数量和位置。

函数的输入参数包括变量的名称、类型和包名称，它会返回一个trackedVar结构体的指针。如果变量已经被跟踪过了，它会返回该变量的现有trackedVar指针。

这个函数在Go语言运行时进行调度和追踪时起着重要的作用，因为它能够帮助调度器更好地理解代码的执行情况，以便更有效地进行调度。



### tryStaticInit

tryStaticInit函数是调度器中的一个私有函数，用于初始化静态M，也就是未绑定goroutine的M。静态M是在调度器初始化时创建的，它们用于处理所有可用的P。

具体来说，tryStaticInit函数会尝试给一个静态M绑定一个P并启动它。如果没有可用的P，tryStaticInit会返回false，调用方将等待并重试。否则，它将返回true，并且新的M将会开始处理队列中的goroutine。

在调度器运行时，可以动态添加/删除P，并调度可用的M来处理P中的goroutine。但是，静态M没有绑定P，因此需要尝试绑定P以便让它们参与调度。这正是tryStaticInit函数的作用所在。



### staticcopy

sched.go是Go语言的调度器实现的文件，其中的staticcopy函数是用来将调度器的Goroutine状态从一个P(处理器)复制到另一个P的函数。

在Go语言中，调度器采用了M:N的线程模型，即M个内核线程会被分配给N个Goroutine来执行。每个内核线程都会绑定一个处理器，即P，而每个P都会运行一个运行队列来执行Goroutine。

staticcopy函数主要作用是在不同的P之间复制Goroutine的上下文，包括寄存器的值、栈指针、堆栈等。这个函数在Goroutine在不同的P之间切换时非常有用，因为它可以帮助保持各个P之间的状态一致性。

当Goroutine被调度器切换到另一个P时，它的上下文状态需要被复制到另一个P中，在该P上执行。这个复制操作是由staticcopy函数来完成的。通过这种方式，调度器可以使Goroutine在不同的P上执行，从而实现负载均衡并提高系统的性能。

总的来说，staticcopy函数在Go语言调度器的实现中非常重要，它帮助保持各个P之间的状态一致性，并提高了调度器的性能和稳定性。



### StaticAssign

在go语言中，每一个goroutine都会被分配到一个P（处理器），P用于执行goroutine。StaticAssign函数是在调度Goroutine时选择P的策略函数之一，它的作用是为新的Goroutine选择一个P。

具体来说，StaticAssign函数使用Round Robin算法按照P的数量依次将新创建的Goroutine分配给每个P。如果其中一个P的Goroutine队列长度大于其他P的队列长度，则新的Goroutine将首先分配到该P，以保持负载均衡。

需要注意的是，在StaticAssign函数中，P的数量是静态分配的，如果存在多个物理处理器，则可以使用环境变量“GOMAXPROCS”来设置P的数量。

总之，StaticAssign函数是在goroutine和P之间建立一种位置关系，确保每个goroutine都被动态地分配到合适的CPU以保证系统的良好运行。



### initplan

在 Go 语言中，`init` 函数是一种特殊的函数，它会在程序运行时自动执行。而在 `sched.go` 文件中，`initplan` 函数是一个类似于 `init` 函数的函数，它会在调度器初始化时自动执行。`initplan` 函数的作用是初始化任务队列，并生成一个计划列表，用于指导任务的执行顺序。

具体来说，`initplan` 函数会首先创建两个全局变量，即 `runqhead` 和 `runqtail`，它们分别指向任务队列的头部和尾部。然后，`initplan` 函数会通过遍历 `allp` 数组中的所有 P(`P` 表示 processor，代表处理器)，为每个 P 初始化一个局部任务队列 `localq`，并将其添加到计划列表中。最后，计划列表按照一定的规则排序，以确定任务的执行顺序。

总之，`initplan` 函数的作用是创建一个可执行的计划列表，为后续的任务调度打下基础。



### addvalue

addvalue函数是在goroutine调度模块中用于向调度器中增加一个调度上下文的函数。

调度上下文包括了一个goroutine的状态、程序计数器（PC）和堆栈起始地址等信息。当一个goroutine被调度器选中进行执行时，需要先将其对应的调度上下文加载到处理器的寄存器中，以便继续执行该goroutine。

在调用addvalue函数时，首先会检查当前是否有空闲的调度上下文，如果没有则会通过newproc函数新建一个goroutine，并将其调度上下文添加到调度器中。如果有空闲的调度上下文，则将调度上下文和goroutine关联，并添加到调度器的调度队列中，以便后续进行调度。

addvalue函数还会根据goroutine的状态将其加入不同的调度队列中。其中，就绪状态的goroutine会被加入runnable队列中，等待调度器进行调度。如果一个goroutine正在等待某个事件，比如通道读写操作，那么它会被加入对应的等待队列中，等待事件发生后再被调度器唤醒。

总之，addvalue函数是goroutine调度模块中一个核心的函数，负责将goroutine的调度上下文添加到调度器中，并进行合适的队列管理，以确保各个goroutine能够正确地被调度执行。



### staticAssignInlinedCall

staticAssignInlinedCall函数是Go语言中用于静态分配基于goroutine的函数调用时执行的函数。静态分配是指编译器在编译时确定函数的调用者和被调用者，并使用内联技术将它们合并，从而消除了函数调用的开销和栈操作。

具体来说，staticAssignInlinedCall函数的作用是将基于goroutine的函数调用分配给指定的Goroutine，从而避免了创建新的Goroutine和调度器的开销。它会将被调用函数的参数和调用者的信息传递给目标Goroutine，然后将Goroutine状态设置为等待调用完成。当被调用函数执行完毕后，staticAssignInlinedCall会将结果返回给调用者，并恢复Goroutine的执行状态。

这个函数在Go语言的并发编程中扮演着重要角色，它可以帮助程序员更高效地利用Goroutine和调度器的优势，同时避免了因过多创建Goroutine而导致的内存泄漏和性能问题。



### StaticName

在Go语言中，每一个函数都有一个名称，方便我们在源代码中进行调用。但是，在实际的运行过程中，函数的名称通常并不是唯一的，比如在一个大型的程序中，可能会有多个函数被命名为相同的名称。这就会导致调用时的混淆和错误。

为了解决这个问题，Go语言提供了一个名字静态检查机制，即每个函数在编译时都会被赋予一个唯一的标识符，并且在编译时就确定了这个标识符，从而避免了函数名字的混淆和错误。

StaticName函数就是实现这个静态检查机制的函数之一。它的作用是返回一个函数的唯一标识符，代码中会用到它来进行函数调度。

具体来说，StaticName函数的实现过程如下：

1. 首先，定义了一个静态变量fnId，用于记录函数的唯一标识符。它的初始值为0。

2. 然后，定义了一个函数类型StaticFn，用于存储函数的信息，包括函数的唯一标识符和函数名字。

3. 接着，定义了一个名为newStaticFn的函数，它的作用是根据函数名字创建一个StaticFn对象，并且为它分配一个唯一的标识符。标识符的值是静态变量fnId的当前值，并且每次为一个新的函数分配标识符时，fnId的值都会自动递增。

4. StaticName函数的实现比较简单，只需要调用newStaticFn函数创建一个StaticFn对象，并返回它的标识符即可。

总之，StaticName函数的作用是为每个函数创建一个唯一的标识符，从而避免函数名字混淆的问题，这对Go语言的静态检查机制和函数调度有很大的帮助。



### StaticLoc

StaticLoc是一个函数，它的作用是将函数体中的静态变量分配给可使用的堆栈帧上。在Go语言的调度器中，每个执行的goroutine都有一个自己的堆栈帧，它是一个由存储器分配器管理的连续存储器块，用于存储局部变量和函数调用返回地址等信息。

当函数的局部变量是静态变量时，它们不是存储在堆栈帧中的，而是存储在一个特殊的区域中，被称为.data节。这样做的好处是使得静态变量可以在多个goroutine之间共享，而不需要将它们复制到每个堆栈帧中。但是，这也会导致性能问题，因为在访问这些变量时需要通过内存指针的方式进行，而不是直接从堆栈帧中读取。因此，Go语言中的静态变量很少使用。

StaticLoc函数的作用是将函数的静态变量分配到堆栈帧上，这样可以避免上述的性能问题。它通过将静态变量的地址计算偏移量，根据当前堆栈帧的大小重新计算地址，并使用新的地址来访问静态变量。这样做会将静态变量的值复制到堆栈帧上，使得它们可以直接被访问，从而提高程序执行效率。

需要注意的是，StaticLoc函数只能用于包含静态变量的函数中，并且静态变量的地址不能在函数外部使用。如果这些要求不满足，则会导致不可预测的结果。



### isSideEffect

isSideEffect函数在Go语言编译器的调度器（scheduler）中用于检查某个操作（instruction）是否具有副作用。

副作用（side effect）是指每次执行该操作都会改变计算的状态。例如，修改内存中的值、写入文件或者发送网络数据包等操作都具有副作用。由于具有副作用的操作会影响程序的行为和结果，因此调度器需要确定哪些操作具有副作用，以便进行正确的调度。

isSideEffect函数使用了Go语言中的反射技术，通过检查操作所对应的函数是否具有“readonly”标记来判断是否具有副作用。如果函数没有“readonly”标记，则认为该操作具有副作用。反之，则认为该操作不具有副作用。

在调度器中，如果发现两个操作之间存在数据依赖关系，并且其中一个具有副作用，那么就需要把具有副作用的操作放到另一个操作的前面，以保证程序的正确性。因此，isSideEffect函数在调度器中起到了非常重要的作用。



### AnySideEffects

AnySideEffects是一个函数，用于确定给定函数是否具有副作用。 
副作用是指函数对其他部分的影响，除了返回值之外。例如，函数可能会更改全局变量或文件状态。

该函数通过使用go/ast包来检查函数的语法树来确定函数是否具有副作用。 

如果函数具有副作用，该函数返回true；否则返回false。 

该函数对于检查函数是否适合进行并发执行非常有用，因为并发执行需要函数不存在副作用，以避免竞争条件和意外的结果。



### canRepeat

canRepeat函数在Go语言的调度器（scheduler）中起到了非常重要的作用。调度器是Go语言运行时的核心组件之一，它负责协调和管理所有的goroutine，使得它们可以在运行时合理地调度和执行。

在调度器中，每个goroutine都由一个G结构体来表示，G结构体包含了一个指向该goroutine的函数指针、goroutine的栈等信息。调度器会在需要时将不同的goroutine插入到不同的运行队列（runqueue）中，然后通过调度算法选择下一个要执行的goroutine。

canRepeat函数的作用是判断某个goroutine是否可以被重复执行。在调度器中，有些goroutine的执行只需要进行一次，比如GC（垃圾回收）任务，而有些goroutine则可以被重复执行，比如系统监控任务。canRepeat函数就是用来判断某个goroutine是否可以被重复执行的。

具体来说，canRepeat函数接受一个G结构体作为参数，然后判断该goroutine是否可以被重复执行。如果该goroutine不可以被重复执行，则返回false，否则返回true。canRepeat函数的代码实现相对较简单，可以参考以下示例代码：

func canRepeat(gp *g) bool {
    // 如果该goroutine已经被标志为不可重复执行，则返回false
    if gp.neverrestart {
        return false
    }
    // 如果该goroutine是系统监控goroutine，则返回true
    if gp.sysmonwait != 0 {
        return true
    }
    // 其他情况均不可重复执行
    return false
}

总之，canRepeat函数的作用是在调度过程中判断某个goroutine是否可以被重复执行，从而帮助调度器更好地进行任务调度。



### getlit

在Go语言的调度器源代码sched.go中的getlit函数是用于获取任务队列中优先级最高的任务的函数。

具体来说，它会遍历任务队列中的所有任务，找到优先级最高的任务并返回它的指针。在查找过程中，会先遍历本地任务队列中的任务，如果找不到则遍历全局任务队列中的任务。

getlit函数的实现过程中，引用了其他几个变量和函数，包括：

- localQueue：本地任务队列；
- globalQueue：全局任务队列；
- p：代表当前的P（处理器）；
- allp：所有的P（处理器）；
- dequeueLocal函数：用于从本地任务队列中删除一个任务；
- dequeueGlobal函数：用于从全局任务队列中删除一个任务；
- runnext函数：用于将一个任务从等待队列中转移到运行队列中。

getlit函数的作用是帮助调度器在任务调度时选择优先级最高的任务。如果当前处理器已经有任务在运行，那么就会直接返回该任务的指针；如果本地任务队列中有优先级高于当前任务的任务，那么就会返回队列中优先级最高的任务；否则会搜索全局任务队列，找到并返回优先级最高的任务。这样，调度器就可以高效且公平地调度所有任务，保证每个任务都有机会被执行。



### isvaluelit

该函数的作用是判断一个表达式是否为字面量，即该表达式是否直接由常量值组成，而不是由函数调用、变量等组成的表达式。

具体实现为，首先判断该表达式是否为常量表达式，常量表达式即所有操作数都是常量的表达式，如果是，则表示该表达式是字面量；如果不是，再判断该表达式是否为单个字面常量，则同样表示该表达式是字面量。

该函数在调度器中的作用是，确定一个任务的执行顺序。当调度器需要比较两个任务的优先级时，如果其中一个任务的某个表达式为字面量，则认为该任务的优先级更高，会先执行该任务。而如果两个任务中都不存在字面量表达式，则比较它们的优先级值，按照优先级值来决定执行顺序。



### subst

在go/src/cmd/sched.go文件中，subst函数是一个字符串替换工具，用于在使用调度方案时替换掉已经被使用过的关键字。它会将作业中的特殊关键字，例如$G和$M，替换为实际的goroutine ID和任务ID。

具体来说，当调度程序需要处理新的作业时，它会首先进行预处理，检查和替换作业中的关键字。预处理过程将作业中的所有关键字替换为它们所代表的实际值。这个过程是由subst函数完成的。

subst函数的主要作用是使用正则表达式匹配字符串，将其中包含的关键字替换成对应的实际值。例如，如果字符串 "$G" 匹配了正则表达式，则该函数会将其替换为相应的goroutine ID.这种替换可以让调度程序更好地识别和跟踪各个goroutine之间的关系，在按照特定的调度方案决定将它们分配到哪个线程上时更加精确和高效。

总之，subst函数在调度程序的工作原理中扮演着重要的角色，使得调度方案更加精确、高效，同时也更加智能化和灵活。



### truncate

在 Go 语言的调度器中，每个 goroutine 都有一个自己的执行模式，其中包括该 goroutine 所需的系统资源及其优先级等。而在某些情况下，当一个 goroutine 从某个集合中移除（比如从某个队列中被取出来并执行），它需要重新调整它的执行模式，以便更加适合当前的上下文。

在 sched.go 中，truncate 函数就是实现以上逻辑的关键函数。该函数接收一个参数 g，代表一个 goroutine。truncate 函数主要做以下几件事：

1. 如果该 goroutine 在 Gwaiting 队列中，将其设置为 Gwaiting | Gscanwaiting (即在等待扫描队列中扫描)。

2. 对该 goroutine 的队列 ID 进行重新计算，并更新其 MQP（M、G、P）状态。

3. 如果该 goroutine 是 Gsyscall 状态，还需要设置它的 M 状态为 Msyscall。

4. 将该 goroutine 加入到全局 schedt 中的某个（新的或旧的）队列中，以便下一次调度时能够快速地访问。

5. 如果有某个 P 正在空转，它会从空转的队列中移出并让它执行该 goroutine。

总之，truncate 函数实现了 goroutine 的重新调整和重新加入队列的工作，以便更好地适应当前的上下文，并尽可能地提高调度效率和系统性能。



### addStr

addStr()函数是用来辅助生成调度器的调试信息的。它接收一个字符串和一个整数参数，将字符串写入到调度器的日志记录中，并在后面添加一个以这个整数参数值为ID的调度器实体的标识符。该函数的作用是方便开发人员跟踪调度器在执行过程中的状态。

具体地说，addStr()函数会将当前goroutine的调度器状态信息输出到调度器的日志记录中。这些信息包括当前的任务队列、所有可运行的goroutine和它们的位置、所有阻塞的goroutine和它们的状态、以及任何其他服务状态信息等。通过这些信息，开发人员可以更好地了解调度器的运行情况和性能瓶颈，从而优化调度器的性能。

在调试期间，程序员可以在必要时在代码中插入addStr()函数调用，以获取更多的上下文信息。这有助于识别和解决由于竞争条件和其他问题而导致的性能问题和死锁问题。

总之，addStr()函数是一个非常有用的调试工具，可以帮助开发人员更好地理解和优化调度器的行为。



### tryWrapGlobalMapInit

tryWrapGlobalMapInit这个函数的作用是在程序初始化时尝试初始化全局的调度器映射表。

在Go语言的并发模型中，每个进程都有一个调度器，用于协调不同的goroutine的调度和执行。在调度器中，有一个映射表，用于记录每个P（处理器）上运行的所有goroutine的信息。这个映射表是全局共享的，因此需要在程序初始化时进行初始化操作。

tryWrapGlobalMapInit的实现方法是利用 sync.Once 类型实现的懒惰初始化，确保全局映射表只被初始化一次。具体实现过程是：首先定义了一个全局变量 globalMap，然后定义一个 initGlobalMap 变量，它的类型是 sync.Once。在 tryWrapGlobalMapInit 函数中，使用 initGlobalMap.Do 方法调用 initGlobalMapFunc 函数进行全局映射表的初始化。由于 Do 方法只会执行一次，因此保证 globalMap 只被初始化一次。最后，返回 globalMap。

总之，tryWrapGlobalMapInit 函数是在程序启动时初始化全局调度器映射表的方法，避免了重复初始化，提高了程序的性能。



### AddKeepRelocations

AddKeepRelocations函数是用于将某些符号标记为需要保留的，并在重定位时防止链接器删除这些符号的重定位信息。这个函数在链接时会被调用，它会将需要保留的符号关系信息记录到一个全局列表中，以便在后续的重定位阶段中使用。

在一些特殊的情况下，一些符号必须保留下来，比如在动态链接库中使用的全局变量，或者由一些手写汇编实现的函数等。在这种情况下，AddKeepRelocations函数就是必要的。

该函数接收一个参数，即符号名，它会将指定的符号标记为需要保留的，使得在链接器重定位时不会丢失其重定位信息。在Go语言中，这个函数通常会在汇编文件中被调用，将在汇编文件中实现的函数和全局变量标记为需要保留的，以保证它们的正确链接。



### OutlineMapInits

OutlineMapInits函数在sched.go文件中定义，是用于为某些较为特殊的变量（包括 schedvar和space）、辅助数据结构（包括DominatorTree和Pending中的map）以及某些临时用途的map初始化提供一个通用的方法。这个函数的实现可以通用到所有其他使用到这些变量的地方。

具体来说，OutlineMapInits函数实现时，首先会检查变量类型，如果是schedvar或者space类型的变量，则通过初始化函数将它们的属性初始化；如果是DominatorTree类型的变量，则通过doms.init将它们的属性初始化；如果是Pending类型的变量，则递归遍历变量中的map，并将其初始化为需要的map类型。如果变量是map[string]interface{}类型，则会遍历其中的每个元素并检查它们的类型，如果是map[string]interface{}类型则会递归调用OutlineMapInits进行初始化，如果是interface{}类型则将其替换成相应的值类型。如果是其他类型的变量，则直接返回。

这个函数的作用是为这些特殊的变量和数据结构提供一个通用的初始化方法，可以保证它们在使用的时候都具有正确的属性和结构。



