# File: bitset.go

bitset.go 文件是 Go 语言标准库中的一个实现了位图的包。其主要作用是实现针对整数集合的高效位操作，如位的设置、复位、翻转、统计、查询等操作。

位图是一种通过位来表示状态的数据结构，它可以节省大量的内存空间，并且具有高效的集合操作特性。在bitset.go 中，位图的实现是通过一个 uint64 数组来存储位的状态，其中每个 uint64 变量可以存储 64 个位的状态。同时，bitset.go 还提供了一系列针对 uint64 数组的位操作函数，可以方便地对位图进行操作和查询。

具体来说，bitset.go 文件中主要包含了以下函数：

- New：创建一个新的位图。
- Set：设置指定位置的位为 1。
- Reset：重置指定位置的位为 0。
- Flip：翻转指定位置的位。
- Test：查询指定位置的位是否为 1。
- Count：统计位图中值为 1 的位的数量。
- String：将位图转换为字符串形式进行输出。

通过这些函数，可以方便地实现对位图的操作，处理整数集合等问题。例如，可以使用 bitset 来表示指定范围内的质数集合，然后使用位操作函数来进行质数的查找和统计。总之，bitset.go 是一个很实用的包，可以方便地进行位操作。




---

### Structs:

### bitset8

bitset8是go语言中位集（BitSet）的一种实现方式。BitSet是一种利用位操作来存储和操作大量布尔值的数据结构。它通常用于需要高效地执行大量布尔操作的场景，比如位图算法、压缩存储等。

bitset8结构体中定义了一个长度为8的无符号整型（uint8）数组bits，它表示了一个包含8个布尔值的位集。每一个整型数的二进制表示中的每一位都代表了对应位集中的一个布尔值。如果该位的值为1，则表示该布尔值为真（true）；如果该位的值为0，则表示该布尔值为假（false）。

通过对bitset8结构体的实例进行位操作，我们可以轻松地对8个布尔值进行查询、设置和清除等操作。具体来说，我们可以使用bitset8结构体中的以下方法：

- func (b *bitset8) Set(pos int)：将pos位置上的布尔值设置为真。
- func (b *bitset8) Clear(pos int)：将pos位置上的布尔值设置为假。
- func (b *bitset8) Test(pos int) bool：查询pos位置上的布尔值是否为真。
- func (b *bitset8) Count() int：计算位集中为真的布尔值个数。

在实际使用过程中，我们可以使用多个bitset8结构体来表示更复杂的位集。例如，如果要表示一个长度为32的位集，我们可以使用4个bitset8结构体来表示。



### bitset16

bitset16是一个用于存储16位二进制位的数据结构，可以实现快速的位操作。它被设计用于命令行工具和包中的数据结构的优化，如cmd/go和encoding/binary等。

bitset16的底层实现是一个uint16位的位向量，其中每个位表示一个二进制位。bitset16可以通过使用位运算符来执行位操作，如与(&)、或(|)、异或(^)和非(^)等。它还提供了一些方法来操作位向量，如Set（设置位）、Clear（清除位）、Toggle（反转位）和Len（获取位向量长度）等。

由于bitset16只使用16位，它的内存占用比较小，因此适合用于存储小规模的位向量数据。同时，由于它的位操作速度很快，它也可以在时间效率上提供更高的性能。

总之，bitset16是一个用途广泛的数据结构，适用于需要快速位操作的场景。



## Functions:

### set

bitset.go中的set函数是位集合的基本操作之一，其作用是将位集合中的某一位设为1。该函数接受一个参数pos，表示待设置的位的位置（从0开始计数），然后将位集合中该位置的二进制位设为1。

具体实现方式是使用位运算符来操作二进制位，在代码中使用了位移运算符<<和按位或运算符|。首先，将数字1左移pos位，得到一个只有pos位置为1的二进制数，然后使用按位或运算符将它与bitset中的二进制数进行或运算，最终得到一个新的位集合，其中第pos位为1。

函数执行完毕后，位集合中指定位置的二进制位就会被设置为1，使得该位成为“已经出现”的标识。这在一些算法中非常有用，例如布隆过滤器和位图算法等。

具体代码如下：

```go
func (s *bitset) set(pos uint) {
    word, bit := pos/wordSize, pos%wordSize
    s.ensure(word)
    s.words[word] |= 1 << bit
}
```

其中，wordSize表示一个uint64类型的二进制位数（即每个字可以存储的位数），s.ensure函数用于确保bitset中有足够的空间来存储指定位置的二进制位。



### get2

bitset.go文件中的get2函数是用来获取BitSet中两个相邻位置上的bit值的函数。该函数的定义如下：

```go
func (b *BitSet) get2(i int) (uint64, bool) {
    if i < 0 || i >= len(b.words)*_W-1 {
        return 0, false
    }
    word, o := i/_W, uint(i%_W)
    return (b.words[word] >> o) & 3, true
}
```

其中，参数i表示BitSet中的索引值，即位于BitSet中的第i位。该函数返回一个uint64的值和一个bool型值，第一个值表示两个相邻位置上的bit值，第二个值表示是否获取值成功。

在函数内部，首先进行判断，如果i小于0或者大于BitSet中的所有索引值，即超出了BitSet的范围，则返回0和false。否则，将i除以_W（即64），得到word和o两个值，即在第word个元素的第o位上的bit值。

最后，返回word和o位置上的值右移o位，即得到两个相邻位置上的值，即(b.words[word] >> o) & 3。 由于我们希望获取两个相邻位置上的值，因此最后的结果需要和3做与操作。



### set2

set2函数是一个辅助函数，用于将位图中的连续的两个位设置为1。它的作用是在位图中设置两个相邻的位，以表示一对连续的值（例如，一个范围）被标记为存在。

具体实现是通过先将uint64类型的输入变量x左移一位，再与原始x做位运算（按位或操作）。这样就实现了将两个相邻的位设置为1的目的。

示例代码：

```go
func set2(x *uint64, i uint) {
    *x |= 3 << i // 将x左移i位，然后或上3来设置相邻的两个位
}
```

这个函数常用于位图中的范围查询，例如查找一组整数是否存在于位图中。在这种情况下，使用set2可以更方便地设置位图中的两个相邻位，以表示一对连续的值。



### set

bitset.go中的set函数用于将指定位置的位设置为1。它有两个输入参数：pos是待设置位的位置，v是待设置的值（默认为true）。

具体来说，当pos表示的位为0时，set函数将其设置为1；当pos表示的位已经是1时，set函数不执行任何操作。

这个函数是由BitSet类型调用的，BitSet是一个表示位集合的类型。在bitset.go中的BitSet类型中，有一个内部变量words，它表示位集合的二进制位。set函数可以通过修改words中的特定位将特定的位设置为1。

举个例子，如果我们有一个BitSet类型的变量b，想要将第5个位置的位设置为1，我们可以这样调用set函数：

b.set(5, true)

这会将b中的words数组的第一个元素中的二进制位的第5位设置为1。如果我们再调用b.set(5, false)，那么第5个位置的位就会被设置为0。

总之，set函数是用于操作BitSet类型的工具函数之一，它提供了一种简单的方法来设置BitSet中特定位的值。



