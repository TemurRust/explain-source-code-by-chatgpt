# File: sigqueue_plan9.go

sigqueue_plan9.go是Go语言标准库中runtime包中的一个文件。它的作用是在Plan 9操作系统上向进程发送信号。

Plan 9是一种分布式操作系统，采用了一些独特的设计理念和实现方式。在Plan 9中，所有的I/O都是以文件的形式进行的，包括设备和进程间通信。因此，Plan 9中的信号发送也是通过文件操作来实现的。

sigqueue_plan9.go文件中定义了一个sigqueue函数，用于向指定进程发送信号。该函数的参数包括进程ID和信号编号，它会通过读写/devproc文件来实现信号的发送。

由于Plan 9的信号发送方式与其他操作系统有所不同，因此在实现Go语言的runtime库时需要针对Plan 9进行特殊处理。sigqueue_plan9.go就是其中的一个实现文件，它确保了Go语言在Plan 9系统上能够正确地发送信号并进行进程间通信。




---

### Var:

### sig

在Go语言的运行时（runtime）中，sigqueue_plan9.go 文件中的 sig 变量是一个全局变量，其作用是帮助处理信号量（signal）。

在具体介绍其作用前，需要先了解什么是信号量。

信号量是一个在操作系统中常用的概念，它是用来通知进程事件发生或异常情况的一种机制。当某个进程接收到信号量时，它需要采取相应的操作。在Linux和UNIX操作系统中，信号量有很多种，例如 SIGKILL, SIGTERM, SIGINT等等。每个信号量都有一个唯一的编号，并且可以用数字或名称来表示。

在Go语言中，sigqueue_plan9.go文件中的sig变量是一个Chans和其对应的mutex的数组，这个数组的长度是signalBufNum，即64。每个Chans和mutex都是用于处理特定信号量的，比如SIGINT或者SIGKILL等等。

这个数组的作用是将信号量存储在数组中。当一个信号量被触发时，会将其放入对应的Chans中，同时给mutex加锁避免并发问题。在接下来的处理中，会逐个处理被触发的信号量，取出对应的Chans中存储的信号，然后进行相应的处理。

因此，sig变量的作用是为了帮助Go语言的运行时处理各种信号量，并且避免信号量的并发问题。






---

### Structs:

### noteData

在Go语言的运行时库（runtime）中，sigqueue_plan9.go文件包含了与操作系统信号相关的代码。其中noteData结构体是用来将信号和它的附加数据（例如文件描述符）传递给操作系统的。

具体来说，noteData结构体包含以下字段：

- sig uint32：表示信号的编号；
- t *timers.Timer：表示计时器的指针；
- link *noteData：表示链表中的下一个noteData结构体的指针；
- fn uintptr：表示在处理该信号时要调用的函数的地址；
- arg unsafe.Pointer：表示传递给该函数的参数。

在Go语言中，当某个协程被阻塞在某个系统调用中，而另外一个协程需要给这个协程发送信号时，就会将这个信号封装成一个noteData结构体，并将其添加到链表中。然后，主循环会不断地从链表中取出noteData结构体，并根据其中的信息进行相应的操作，例如调用fn字段指定的函数，并将arg字段传递给它。

总之，noteData结构体在Go语言的运行时库中扮演着将信号和附加数据传递给操作系统的重要角色。



### noteQueue

在Go语言的运行时系统中，sigqueue_plan9.go文件定义了一个名为noteQueue的结构体，该结构体用于管理操作系统信号与Go语言信号之间的转换。具体来说，它充当了一个队列的角色，用于保存待处理的操作系统信号。

noteQueue结构体是一个FIFO（First-In-First-Out）队列，因此，它通过记录队列中的第一项和最后一项来管理队列的操作。队列中每个元素都是一个指向note类型的指针，note类型是一个系统级别下的表示Go语言信号的结构体。当操作系统发送信号时，信号处理程序会接收到该信号并将其转换为一个note类型的实例，并将该实例插入到noteQueue的队尾中。

Goroutine在调用程序sigtramp（这是一个包含汇编语言代码的函数，它与操作系统的信号系统进行交互）时，可以从noteQueue中获取该信号对应的note实例。然后，Goroutine可以根据note实例中指示的信息执行相应的操作。

注意，noteQueue是一个计划9操作系统特有的结构体，只在Plan 9操作系统上使用。在其他操作系统中，可能会使用不同的结构来进行信号与Go语言信号之间的转换。



## Functions:

### push

在go/src/runtime/sigqueue_plan9.go文件中，push函数是用来将一个sig实例添加到队列中的函数。这个队列是用来缓存等待发送到goroutine的信号。

push函数的作用是将sig实例添加到sigQueue中，在添加之前会先检查sigQueue是否已经满了，如果已经满了，则会跳过添加操作并返回false。如果sigQueue未满，则会将sig实例添加到队列中，并返回true。

队列的大小是通过#define SIGQUEUE_MAX 1024这个宏定义来指定的，目前默认为1024。当队列中的元素数量达到了这个值时，将不能继续向队列中添加新的元素，否则会导致队列溢出。

push函数是在信号处理函数中调用的，它的作用是将全局变量sigQueue中的sig实例添加到队列中。这些sig实例可能是在多个goroutine中发出的，所以需要使用互斥锁来确保对sigQueue的访问是线程安全的。



### pop

pop() 函数是用来从一个信号处理器队列中取出队头的处理器并返回其指针的。在sigqueue_plan9.go 文件中，这个函数主要是用于从处理器队列中获取队头来处理信号。

具体来说，当操作系统接收到一个信号并需要处理它时，它会将信号相关信息打包成一个 sigInfo 结构体，并将该结构体放到对应的信号处理器队列中。这个队列是用一个指向处理器的指针来表示的，即 sigHandlers 数组。

当 pop() 函数被调用时，它会获取 sigHandlers 队列的头元素（即队头），并将其返回。如果队列为空，pop() 函数会返回 nil。在 sigqueue_plan9.go 文件中，pop() 函数的返回值通常会被传递给其他相关的函数来处理信号。

总之，pop() 函数是用来从信号处理器队列中获取队头的处理器的，并将其返回供其他函数使用。它是 Go 语言 runtime 包中与信号处理相关的核心函数之一。



### sendNote

sendNote函数是在Plan 9上发送通知信号的实现。通知信号是在Unix系统上的信号通知的一个变体，它允许发送额外的信息，以向接收者提供有关事件的更多上下文。在Plan 9上，它被用来通知进程一些系统的相关事件。

sendNote函数的主要作用是根据给定的注释、进程ID和相关信息发送通知。它会创建一个新的sigqueue对象，将相关信息填充在其中，然后将对象添加到接收进程的sig队列中。这样，接收进程就可以从队列中读取通知并进行相应的操作。如果接收进程没有阻塞sig队列，则sendNote函数将立即返回，而不会阻塞发送者。

sendNote函数的实现非常复杂，因为它必须考虑许多不同的情况，如进程不存在、信号过多等。但是它的基本原理是相同的：将消息放入接收进程的sig队列，接收进程将从队列中读取消息并采取相应的措施。



### signal_recv

sigqueue_plan9.go文件中的signal_recv函数的作用是从sigrecv向当前goroutine发送信号。

在Plan 9操作系统中，每个进程都有一个sigrecv线程，该线程在接收到信号时将信号放入进程信号队列中。signal_recv函数会从该进程信号队列中接收信号，并在当前goroutine上启动一个新的恐慌来处理该信号。此函数主要用于将POSIX信号转换为Plan 9信号，并将信号发送给goroutine以便进行相应的处理。



### signalWaitUntilIdle

signalWaitUntilIdle函数是在Plan 9系统上等待所有信号处理程序结束后发出SIG_IDLE信号的函数。它的作用是确保所有的信号处理都已经完成，防止在处理信号时嵌套产生新的信号，导致死锁或其他问题。

具体来说，当系统接收到信号时，它会调用signalHandler函数，该函数负责处理信号并进行相应的操作。信号处理程序可能会涉及许多复杂的操作，例如修改全局变量、调用系统函数等，如果在处理信号时有新的信号发生，将可能导致不可预测的后果。

因此，signalWaitUntilIdle函数用于等待所有正在运行的信号处理程序完成，以确保不会在处理信号时嵌套产生新的信号。同时，它还需要防止由于调用系统函数或锁等操作导致的无限循环等问题发生。

在实现中，signalWaitUntilIdle函数会使用一个计数器来追踪当前正在运行的信号处理程序的数量。每当一个信号处理程序启动时，计数器会递增，当信号处理程序结束后，计数器会递减。当计数器为0时，表示所有的信号处理程序已经完成，此时函数会发送SIG_IDLE信号通知其他等待的程序可以继续执行。

总之，signalWaitUntilIdle函数用于确保系统在处理信号时保持稳定，避免因信号处理程序之间相互干扰而导致的问题。



### signal_enable

sigqueue_plan9.go文件中的signal_enable函数是用于在Plan 9系统上启用同步信号处理的函数。它的作用是为正在运行的goroutine启用指定信号的同步处理。在Plan 9系统上，处理信号的主要方式是通过向goroutine发送一个信号量。当信号量被接收时，goroutine将中断当前的程序执行并开始处理信号。

当进程中有多个goroutine时，为了防止多个goroutine同时处理同一个信号，我们需要使用同步信号处理技术。这个函数会将给定的信号添加到goroutine的信号掩码中，并且对于使用了sigaltstack的goroutine，还会添加sigstack信号，这个信号是用来告知goroutine使用替代堆栈。使用sigaltstack可以有效地避免在处理信号时发生栈溢出。如果该函数执行成功，那么进程现在将可以对该信号进行同步处理了。

总之，在sigqueue_plan9.go文件中的signal_enable函数是启用同步信号处理的关键函数，它通过添加信号到goroutine的信号掩码中，从而使goroutine能够在接收到信号时正确地中断并处理信号。



### signal_disable

func signal_disable() 

signal_disable函数用于禁用信号处理程序，即将进程中的所有信号视为忽略。调用该函数后，处理任何信号的进程将不会受到信号。这在一些特殊情况下是很有用的，如在通过goroutine实现必须对状态进行操作的线程时，可能需要临时禁用信号来确保状态一致性，以避免在处理信号时产生竞争条件。 

在具体实现中，signal_disable函数使用了go内建的os和syscall包中的相关操作系统调用来禁用信号处理程序。首先，通过syscall包中的Sigemptyset()函数创建了一个空的信号集，然后使用sigprocmask()函数将该信号集作为阻止进程接收的新信号集。最后，signal_disable函数将当前信号掩码存储在sigmask全局变量中。 

需要注意的是，当一个信号已经发送给进程时，即使该信号已被阻止，并且信号处理程序被禁用，该信号的处理程序也会在处理完当前的系统调用后执行（即系统调用的信号结束点）。



### signal_ignore

sigqueue_plan9.go文件中的signal_ignore函数是一个函数类型，它在调用时会忽略传入的信号。该函数会被用来处理SIGPIPE、SIGURG、SIGWINCH等信号，以避免在发生这些信号时导致程序中断或崩溃。

具体来说，signal_ignore函数使用了Plan9的signal()函数来设置信号的行为。它将信号的处理器设置为SIG_IGN，表示完全忽略该信号，不会阻塞，也不会打断系统调用。这样，当程序收到这些信号时，它们将被默默地忽略，不会影响到程序的正常运行。

在Unix系统上，有很多信号在默认情况下会导致程序终止或崩溃。signal_ignore函数的作用就在于将这些信号的行为修改为忽略，以保证程序的健壮性和稳定性，避免因信号导致的异常行为和错误。

总的来说，signal_ignore函数是Go语言运行时的一个重要组成部分，它能够确保程序在面对特定的信号时能够处理得当，避免因信号导致的异常行为和错误，从而提高程序的稳定性和健壮性。



### signal_ignored

signal_ignored是在Go语言运行时中，对于特定信号的处理函数之一。

在Unix、Linux、macOS等系统中，每个进程都有自己的信号处理表。当系统中发生某个特定的事件时，例如键盘按下、进程收到终止信号等，系统会向进程发送一个信号。进程可以通过修改信号的处理函数，来决定如何响应该信号。

signal_ignored函数就是用来处理那些被忽略的信号的。在signal_ignored函数中，会将进程中的该信号的信号处理函数设置为SIG_IGN（即忽略该信号），从而达到忽略该信号的目的。

在sigqueue_plan9.go文件中，signal_ignored函数主要用于处理一些在Plan 9操作系统中无法实现的信号。例如，SIGVTALRM信号需要计时器，而在Plan 9中没有类似的机制，只能通过忽略该信号来达到相同的效果。



